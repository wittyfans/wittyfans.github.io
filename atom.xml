<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wittyfans</title>
  
  <subtitle>学则不固,知则不惑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wittyfans.com/"/>
  <updated>2018-03-19T15:23:12.591Z</updated>
  <id>http://wittyfans.com/</id>
  
  <author>
    <name>wittyfans</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《颜氏家训》读书笔记</title>
    <link href="http://wittyfans.com/reading/%E3%80%8A%E9%A2%9C%E6%B0%8F%E5%AE%B6%E8%AE%AD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/reading/《颜氏家训》读书笔记.html</id>
    <published>2018-03-19T15:22:01.000Z</published>
    <updated>2018-03-19T15:23:12.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>颜氏家训在中国广为人知，所谓古今家训，以次为祖。<br>上周在书店看到此书，随便翻阅了一下便买了下来，一是因为书便宜，才22块，二是我购得这本为精简版，即根据王利器的书作为底本，重新编排的，适合作为一本入门书。</p></blockquote><a id="more"></a><h1 id="颜氏家训"><a href="#颜氏家训" class="headerlink" title="颜氏家训"></a>颜氏家训</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>颜氏家训在中国广为人知，所谓古今家训，以次为祖。<br>上周在书店看到此书，随便翻阅了一下便买了下来，一是因为书便宜，才22块，二是我购得这本为精简版，即根据王利器的书作为底本，重新编排的，适合作为一本入门书。</p><h1 id="序致"><a href="#序致" class="headerlink" title="序致"></a>序致</h1><ul><li>兄弟关系不同于旁人，相互期望过高就容易产生不满，而彼此关系亲密，不满也容易消除。</li><li>兄弟不和睦，子侄就不会相互爱护，子侄不爱护，整个家族子弟的关系都会疏远，感情淡薄。</li><li>妯娌之间，非常容易产生误会，之所以这样，是因为处理大家庭中的事物大家都各怀私心，肩负责任时，又挂念着个人恩怨，与其让她们住在一起，还不如让她们分开。</li><li>继母残虐孤遗，离间骨肉之事常有，再娶之事，慎之慎之！</li><li>按照一般人的秉性，后夫大都宠爱前夫的孩子，后妻则必定会虐待前妻的子女；这不是因为妇人天生嫉妒性情强，男子本身容易成迷诱惑。前夫的子女，不敢与自己的子女争夺家产，在这种情况下，后夫会从小照顾扶养他，日子一长自然会产生爱心。前妻的孩子，年龄地位一般都在自己的子女之上，无论做官，读书，还是娶妻，出嫁，没有一样不要提防的，所以后母大都会虐待他们。父母宠爱异姓孩子招致自己的孩子怨恨，继母虐待前妻孩子则会使兄弟之间反目成仇，凡是家里存在这种问题的，都是家庭的灾祸啊。</li></ul><h1 id="治家"><a href="#治家" class="headerlink" title="治家"></a>治家</h1><ul><li>风化教育都是由上而下推行的，父亲不慈爱则子女不孝顺，兄长不友爱则弟弟不恭敬，丈夫不情义则妻子不温顺。假如父亲次爱有加而子女忤逆不孝，兄长友爱备至而弟妹倨傲不恭，丈夫情谊深厚而妻子盛气凌人，那这些人就是天生的凶恶之徒，只能用暴力去威慑他们，不是教育感化所能改变的（曾国藩则强调对待家人，言语不可过激，如果家人执意而为，那就旁听侧记的提醒）。</li><li>妇人的秉性，大多宠爱女婿而虐待儿媳，宠爱女婿则儿子的不满就会产生，虐待儿媳，则女儿的谗言就随之而至。这是家庭中常出现的弊端，不能不戒。</li><li>借别人的书籍，应该爱护，如果借来时就有损坏，就替别人修补好。</li></ul><h1 id="慕贤"><a href="#慕贤" class="headerlink" title="慕贤"></a>慕贤</h1><ul><li>世间的人大多见识不明，对传闻的人和事很看重，对亲眼所见的东西则很轻视；对远方的事物很感兴趣，对近处的事物则不放在心上；从小长大的人，如果谁成了贤达之士，人们也往往对他轻慢侮弄，缺乏应有的礼貌和敬重。而处在他乡异县的人，凭着那么点名声，就能让大家伸着脖子，踮起脚跟，如饥似渴地盼望一见。其实远处的还不如近处的。</li></ul><h1 id="勉学"><a href="#勉学" class="headerlink" title="勉学"></a>勉学</h1><ul><li>人生在世，那些圣明帝王尚且需要勤奋学习，何况普通百姓呢？</li><li>不能以有学问的贫贱，去和没学问的人的富贵相比。</li><li>人们看到乡邻亲戚中有优秀的人物，就让自己的子弟铁慕他们，向他们学习，却不知道让自己的子弟向古人学习，这是多么糊涂啊？世人只知骑胺马，披错甲，手持长 矛强弓，就认为自己能当将军，却不知道了解天时，洞悉地理，栓衡形势优劣，审察把握兴盛衰亡的种种奥妙。一般人只知道当宰相的裏承旨意，统领百官，为国积财储粮，就说自己也能当宰相；却不知道侍奉鬼神，移风易俗，调节阴阳，荐贤举能的种种周密的工作。只知道地方官不能聚敛私财，公事尽快办理，就说自己能治理百姓；却不知道诚心待人，为人楷模，御民有术，止风灭火，变恶为善的种种方法。只知道依照法令条律，判刑宜早，赦免宜迟，就说自己能秉公办案；却不知道同績观罪、分剑追财，用假言诱使奸诈者暴露，不用反复审问而弄清案情。推而广之，甚至那些农夫、商贾、工匠，厮役、僮仆，渔民、屠 夫，喂牛的、放羊的，他们中间都有杰出之士，可以作为学习的榜样。</li><li>尚书说：“喜欢提问则知识充足”，礼经又说：“独自学习而没有朋友共同商讨，就会孤陋寡闻”，看来学习要共同切磋，互相启发，才能更加明白。</li></ul><h1 id="名实"><a href="#名实" class="headerlink" title="名实"></a>名实</h1><ul><li>人的双脚所踩的范围，不过几寸，但是走在尺多宽的小路上，常常会失足掉下悬崖，这是为什么呢？因为这些地方两边都没有空余的地方。君子立世也是这个样子，最真诚的话，人们一定不会相信。最高洁的行为，反倒会招致某些人的怀疑，这些都是因为人的一言一行，声望名誉有余地的缘故。</li></ul><h1 id="止足"><a href="#止足" class="headerlink" title="止足"></a>止足</h1><ul><li>欲望不可以放纵，志向不可以满足，宇宙还可以达到边缘，人的本性则没有尽头，只有减少欲望，知道满足而止，给自己立个限度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;颜氏家训在中国广为人知，所谓古今家训，以次为祖。&lt;br&gt;上周在书店看到此书，随便翻阅了一下便买了下来，一是因为书便宜，才22块，二是我购得这本为精简版，即根据王利器的书作为底本，重新编排的，适合作为一本入门书。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="家书" scheme="http://wittyfans.com/tags/%E5%AE%B6%E4%B9%A6/"/>
    
      <category term="国学" scheme="http://wittyfans.com/tags/%E5%9B%BD%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>阅读：Java虚拟机</title>
    <link href="http://wittyfans.com/uncategorized/%E9%98%85%E8%AF%BB%EF%BC%9AJava%E8%99%9A%E6%8B%9F%E6%9C%BA.html"/>
    <id>http://wittyfans.com/uncategorized/阅读：Java虚拟机.html</id>
    <published>2018-03-18T14:11:59.000Z</published>
    <updated>2018-03-18T14:14:31.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JVM(Java虚拟机)是一个抽象机器。 它提供了一个可以执行Java字节码的运行环境，让Java可以在不同的硬件软件平台运行，它的工作是什么呢？</p></blockquote><a id="more"></a><h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="Java虚拟机是什么？"><a href="#Java虚拟机是什么？" class="headerlink" title="Java虚拟机是什么？"></a>Java虚拟机是什么？</h2><p>JVM(Java虚拟机)是一个抽象机器。 它提供了一个可以执行Java字节码的运行环境，让Java可以在不同的硬件软件平台运行，它的工作是什么呢？简单的说就是加载代码、验证代码、执行代码、提供运行时环境。它通过内部许多的组件来实现这些功能，这些组件包括：</p><ol><li>类加载器</li><li>方法区，就是存放已经被虚拟机加载了的信息，如类信息，常量，静态变量等。</li><li>Java虚拟堆，就是存放Java对象实例的地方；也是垃圾收集器主要管理的地方，所以也叫GC堆，一般都采用分代收集算法去管理。</li><li>Java虚拟机栈，定义了内存模型，java中每个方法执行的时候都会创建一个栈来存储局部变量，动态链接等数据，在java中，进入一个方法的时候，该方法需要的内存空间是已经确认了的，不可中途修改；如果申请的内存超过限制，就会报StackOverflow错误。</li><li>程序计数器寄存器</li><li>本地方法堆栈</li><li>执行引擎</li><li>虚拟处理器<ul><li>解释器：读取字节码流，然后执行指令。</li><li>即时(JIT)编译器：它用于提高性能，JIT编译的同时有类似字节代码部分的功能，从而减少编译所需的时间。编译器是指从Java虚拟机(JVM)的指令集到特定CPU的指令集的转换器。</li></ul></li></ol><h2 id="常用的Java虚拟机"><a href="#常用的Java虚拟机" class="headerlink" title="常用的Java虚拟机"></a>常用的Java虚拟机</h2><ul><li>Sun Classic/Exact VM，世界上第一款商用 Java 虚拟机</li><li>Sun HotSpot VM，Sun推出的优化版</li><li>BEA JRockit /IBM J9 VM，专注于服务器端应用</li><li>IBM J9 ，一款设计上从服务器端到桌面应用再到嵌 入式都全面考虑的多用途虚拟机。</li><li>Azul VM/BEA Liquid VM，特定硬件平台专有的虚拟机，特点是高性能，可直接管理硬件</li><li>Apache Harmony/Google Android Darvik VM，Android 平台的核心组成部分之一</li><li>Microsoft JVM及其他。</li></ul><h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>检测到New指令的时候，首先检测是否已经存在该参数（是否能在常量池中定位到一个类的符号引用，是否已经被加载、解析和初始化过），如果没有，就执行相应的类加载过程。</p><p>但是有一个问题，在进行内存分配的是，如果A线程给一个对象分配了内存，但此时还没有修改内存指向的指针，与此同时B线程又吧这个内存分配了出去，这就会报错。</p><p>有两种方式解决，第一种是排队，按顺序来。第二种是，这些线程放到不同的内存区域去分配资源，也就是说线程一开始管的地盘（本地线程分配缓冲（TLAB））就不一样，如果这个TLAB用完了，再排队，可通过-XX:+/-UseTLAB参数来设定排不排队。</p><p>接下来就处理，对象是哪个类的实例、如何才能找到类的元 数据信息、对象的哈希码、对象的GC分代年龄等信息。</p><p>然后就按照程序猿的意思去初始化对象咯。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>主要有三个部分：对象头、实例数据和对齐 填充。</p><p>先介绍对象头，主要有两个部分：</p><ul><li><p>第一部分用于存储对象自身的运行时数据（哈希 码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的 存储官方称为Mark Word）</p></li><li><p>另一部分是类型指针（即对象指向它的类元数据的指针，JVM通 过这个指针来确定这个对象是哪个类的实例）。</p></li><li>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</li></ul><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序需要通过Java虚拟机栈（定义了内存模型）上的Reference数据来操作堆（Java虚拟堆，就是存放Java对象实例的地方）上的具体对象，Reference访问对象的方式有两种，句柄和直接指针。</p><ol><li>如果直接使用句柄访问，java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息。</li><li>如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相 关信息，而reference中存储的直接就是对象地址。</li></ol><h2 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h2><p><strong>学习目标</strong></p><ul><li>了解内存区域</li><li>根据异常快速定位是哪个区域溢出</li><li>什么样的代码会导致溢出</li><li>如何处理溢出</li></ul><p><strong>Java堆溢出</strong><br>我们在JVM参数中，加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure><ul><li>堆的大小固定为20M且不可扩展</li></ul><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。</p><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。 对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>本机内存可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆 最大值（-Xmx指定）一样。</p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p>GC（即Garbage Collection，垃圾收集，垃圾回收）要完成3件事：</p><ol><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ol><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><p>Java内存的<strong>程序计数器、虚拟机栈、本地方法栈</strong>，3个区域随线程而生，随线程而灭；</p><p>栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存 基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性， 在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟 随着回收了。</p><p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。</p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>无法解决互相引用循环的问题，主流的Java虚拟机已经放弃这种方法。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>就是搜素引用链，如果发现某个对象没有被引用了，就可能要被销毁，但是真正的销毁还是要看一些条件，即对象被引用的情况：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li>第一次，即发现对象没有与GC Roots相连接，这时候会去判断是否有必要执行finalize方法，如果有必要就会放入F-Queue队列，随后会由一个虚拟机 自动建立的、低优先级的Finalize线程去执行它。这个执行并不会等待其运行结束，防止阻塞 和崩溃。</li><li>finalize方法是对象逃过死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize方法中拯救自己—只要重新与引用链上的任何 一个对象建立关联即可。但是一个对象的finalize方法只能被执行一次</li></ol><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的回收率很低。一般回收只回收两部分的内容，一是废弃的常量。而是无用的类。第一种简单，而无用的类就需要去判读了，需要满足3个条件：</p><ol><li>该类的所有实例都已经被回收，也就是说java堆中不存在这个类的任何实例。</li><li>加载这个类的ClassLoader也已经被回收。</li><li>这个类对应的对象没有在任何地方被引用。</li></ol><p>可以通过了-Xnoclassgc参数对类的回收进行配置。</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝 生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 </li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴 随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直 接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>也即是，先标记需要回收的对象，然后标记完成后统一回收，这个标记的过程就是使用可达性算法来实现的。<br>但是也有缺点：</p><ul><li>标记和清除的效率都不高</li><li>清除后的标记会产生碎片</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>就是将内存分区，每次只使用其中的一部分，当这个部分用完了，就把还存活的对象复制到另一个地区去，再把使用过的内存清理掉。<br>这种办法不需要考虑碎片的问题，只需要动一动指针就好了。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>跟标记清除一样，但是标记完成了之后，它会让所有的存活对象向一边移动，然后直接清除掉另外一边的内存。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>即根据对象的特征去分开管理。存活时间短的放在新生代，长的放在老年代。时间短的可以采用复制算法，而老年代存活率高，可以使用标记清理或者标记整理。</p><h2 id="HotSopt的算法实现"><a href="#HotSopt的算法实现" class="headerlink" title="HotSopt的算法实现"></a>HotSopt的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>枚举根节点也就是去找到引用的对象，但进行这个操作的时候，会停顿所有的Java执行线程，GC不可能经常去做中断这个操作，会加重系统的负荷，但也不能一直不做这个操作，让枚举操作等待很久，所以需要有一个频率去控制，而HotSpot实现的方式就是在“特定的位置”放置安全点，也就是说在特定的位置记录OopMap（一种数据结构，用来找到引用对象）。<br>我们一般采用主动式中断的思想，即简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="Serial-Collecor收集器"><a href="#Serial-Collecor收集器" class="headerlink" title="Serial Collecor收集器"></a>Serial Collecor收集器</h3><p>这是一个单线程的分代收集器。它在进行垃圾搜集的时候，必须暂停其他所有的工作的线程，直到它收集结束。</p><p>新生代：单线程复制收集算法；<br>老年代：单线程标记整理算法；</p><p>Serial一般在单核的机器上用。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial无法充分利用物理及的资源，因此出现了ParNew收集器。它跟Serial的区别主要是在新生代的收集方式上，一个是多线程，一个是单线程。</p><h3 id="parallel-Scavenge收集器"><a href="#parallel-Scavenge收集器" class="headerlink" title="parallel Scavenge收集器"></a>parallel Scavenge收集器</h3><p>新生代的收集齐，使用复制算法，又是并行的多线程收集器。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial的老年代版本，单线程。使用标记整理算法。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>老年代版本的收集器，使用多线程和标记整理算法。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>基于标记，清除。了解决老年代暂停时间过长而设计，同样基于收集器“标记-算法”实现。</p><ul><li>新生代：收集和Parallel Collector新生代收集方式一致。</li><li>老年代：GC和程序同时进行。</li></ul><p>分四个阶段：</p><ul><li>初始标记(initial mark):暂停一会，找出所有活着对象的初始集合。 </li><li><p>并行标记(concurrent marking)：根据初始集合，标记出所有的存活对象，由于程序在 运行，一部分存活对象无法标出。此过程标记操作和程序同时执行。</p></li><li><p>重新标记(remark):程序暂停一会，多线程进行重新标记所有在②中没有被标记的存活对 象。</p></li><li><p>并行清理concurrent sweep：回收所有被标记的垃圾区域。和程序同时进行。</p></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>面向服务端的垃圾收集齐，CMS的替代版。特点是能充分利用多CPU、多核环境下的硬件优势，并且中断造成的停顿是可以预测的。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>对象优先在Eden分配，大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将 发起一次Minor GC；</li><li>大对象直接进入老年代，那些需要大量连续内存空间的Java对象，比如很长的字符串、数组，这些对象会直接分配在老年代；</li><li>长期存活的对象将进入老年代，虚拟机其实给每个对象都定义了一个对象年龄计数器。对象在Survivor区中，每“熬过”一次Minor GC，年龄就增加1岁。当它的年龄增加到一定程度（默认为15岁），就将 会被晋升到老年代中。</li></ul><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么就是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许<strong>担保失败</strong>。</p><p>如果允许，那么会继续检查老年代最大 可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不 允许冒险，那这时也要改为进行一次Full GC。</p><h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>知识、经验是关键基础，数据是依据，<strong>工具</strong>是运用知识处理数 据的手段。</p><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>这些JDk工具就是对jdk/lib/jar的类库做个包装，主要的实现代码都在tools类库中，例如:</p><ul><li>虚拟机进程状况工具jps，列出正在运行的虚拟机进程，并显示本地虚拟机唯一ID。</li><li>虚拟机统计信息监视工具jstat，它可以显示本地或者远程虚拟机进程 中的类装载、内存、垃圾回收、JIT编译等运行数据</li><li>java配置信息工具jinfo，实时的查看和调整虚拟机各项参数。</li><li>Java内存映像工具jmap，也可以获取dump文件，查询 finalize执行队列、java堆和永久代的详细信息。如空间使用率、当前用的是哪种收集器等。</li><li>虚拟机堆转储快照分析工具jhat，与jmap搭配使用的，用来分析dump生成的快找，jhat内置了</li><li>java堆栈跟踪工具jstack，这个命令用来生成虚拟机当前的线程快照，一般会生成threaddump或者是javacore文件。</li></ul><h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p>JDK中主要有两个可视化工具，JConsole和VisualVM。</p><p>JConsole 在 JDK/bin目录下，启动JConsole后，会自动搜索jvm进程。</p><p>VisualVM 多合一故障处理工具，这是一个集成多个JDK命令行工具的可视化工具。可以通过插件扩展许多功能，比如显示环境信息，进程配置，监视CPU，GC，堆，等等。</p><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一 定都得定义在文件里。Class 文件是一组以 8 位字节为基础单位的二进制流。</p><p>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存 储数据，这种伪结构中只有两种数据类型：无符号数和表</p><p>Class文件格式不依赖于特定硬件及操作系 统、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。</p><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>就是把类的数据从Class文件加载到内存，然后对数据进行校验，转换解析，初始化，最后就可以被虚拟机直接使用了。</p><h3 id="类是怎么加载的？"><a href="#类是怎么加载的？" class="headerlink" title="类是怎么加载的？"></a>类是怎么加载的？</h3><ol><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>其中</p><ul><li>验证、准备、解析 3 个部分统称为连接（ Linking）</li><li>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的</li><li>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开 始，这是为了支持 Java 语言的运行时绑定</li></ul><p>虚拟机规定，有且只有5种情况必须对类进行初始化：</p><ul><li>1） 遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条指令时</li><li>2） 使用 java.lang.reflect 包的方法对类进行反射调用的时候。 </li><li>3） 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类 的初始化。 </li><li>4） 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类）， 虚拟机会先初始化这个主类。 </li><li>5） 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例 最后的解析结果 REF_getStatic、 REF_putStatic、 REF_invokeStatic 的方法句柄，并且 这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>加载，就是找到要怎么加载这个数据的方法（通常是静态的），然后根据这个数据转化成可以运行的数据机构，再放到方法区。</li><li>验证，即确保Class文件中的数据符合虚拟机的要求</li><li>文件格式验证</li><li>元数据验证，字节码的语义分析</li><li>字节码验证，数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证</li><li>准备，这个阶段进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变 量将会在对象实例化时随着对象一起分配在 Java 堆中。</li><li>解析，虚拟机将常量池内的符号引用替换为直接引用的过程。</li><li>初始化，执行类构造器<clinit>方法。</clinit></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</li><li>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不 同，那这两个类就必定不相等。每一个类加载器，都拥有一个独立的类空间。</li><li>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：<ul><li>一种是启动类加载器（ Bootstrap ClassLoader）， 这个类加载器使用 C++ 语言实现[ 1]， 是虚拟机自身的一部分；</li><li>另一种就 是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继 承自抽象类java.lang.ClassLoader。</li><li>有三种系统提供的类加载器，启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader）。</li></ul></li></ul><hr><p>To be continued.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JVM(Java虚拟机)是一个抽象机器。 它提供了一个可以执行Java字节码的运行环境，让Java可以在不同的硬件软件平台运行，它的工作是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《穷理查智慧书》读书笔记</title>
    <link href="http://wittyfans.com/reading/%E3%80%8A%E7%A9%B7%E7%90%86%E6%9F%A5%E6%99%BA%E6%85%A7%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/reading/《穷理查智慧书》读书笔记.html</id>
    <published>2018-03-18T14:06:37.000Z</published>
    <updated>2018-03-18T14:07:47.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本杰明·富兰克林最迷人的创造品之一。了解他从一个社会地位低下的商人到建国之父的发展之路，《穷理查智慧书》可谓占据了中心位置，它也为了解殖民时期的美国打开了一扇迷人的窗户。从那个虚构的文学人格中，展现出富兰克林独有的智慧，这份才智依然能让现在的读者眼前一亮，有所启迪。<br><a id="more"></a></p></blockquote><h1 id="富兰克林"><a href="#富兰克林" class="headerlink" title="富兰克林"></a>富兰克林</h1><ul><li>哲学家、政治家、外交家、作家、科学家、商家、发明家和音乐家</li><li>美国人心目中“伟大的公民”</li><li>美国独立战争时重要的领导人之一，参与了多项重要文件的草拟，并曾出任美国驻法国大使，成功取得法国支持美国独立。</li><li>本杰明·富兰克林发明了避雷针，最早提出电荷守恒定律。</li><li>发明了双焦点眼镜，蛙鞋等等。</li><li>英国皇家学会院士。美国首位邮政局长。法国经济学家杜尔哥评价富兰克林：“他从苍天那里取得了雷电，从暴君那里取得了民权。”</li><li>美利坚开国三杰之一，被美国的权威期刊《大西洋月刊》评为影响美国的100位人物第6名</li></ul><h1 id="穷理查智慧书"><a href="#穷理查智慧书" class="headerlink" title="穷理查智慧书"></a>穷理查智慧书</h1><p>《穷理查智慧书》是本杰明·富兰克林最迷人的创造品之一。了解他从一个社会地位低下的商人到建国之父的发展之路，《穷理查智慧书》可谓占据了中心位置，它也为了解殖民时期的美国打开了一扇迷人的窗户。从那个虚构的文学人格中，展现出富兰克林独有的智慧，这份才智依然能让现在的读者眼前一亮，有所启迪。 </p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>无女人与炉火之房屋，犹如无灵魂或精神之身体。</li><li>荷包瘪，心事重。</li><li>爱之深，责之切。 </li><li>当心煮过两次的肉和修好的旧敌。 </li><li>行医的年轻易犯错，理发的年老易破头。 </li><li>姑娘、客人和雨天，男人三天就厌倦。 </li><li>检验金子的是烈火，检验女人的是金子，检验男人的是女人。 </li><li>躺下同狗睡，起来满身虱。近朱者赤，近墨者黑。 </li><li>食物越肥美，意志越薄弱。 </li><li>多心多安全，小心小风险。 </li><li>把酒好交流，决策要清醒。 </li><li>喝酒快者买单慢。 </li><li>笨蛋的心在口中，智者的口在心上。 </li><li>要面包的人，什么都能出卖。</li><li>要摘玫瑰别怕刺，老婆貌美易惹事。 </li><li>凡事因愤怒而起，必将以羞愧终。 </li><li>勤则万事易，懒则万事难。</li><li>无爱的婚姻，必有婚外情</li><li>劝服别人时要谈利益，不要空讲道理。 </li><li>善待朋友留住他，善待敌人拉拢他。 </li><li>不懂得服从命令的人，也不会施令指挥他人。 </li><li>若要复仇，冷静为先。</li><li>怪哉，靠谎言为生的人，却难以欺骗自己。 </li><li>伤痛之处易受磨难，骄傲的人常遭冒犯。 </li><li>娶媳可以挑，嫁女要趁早</li><li>赠出的物品耀眼，收下的东西晦暗。 </li><li>睡得早，起得早，健康聪明财路好。 </li><li>对上级谦恭是本分，对平级谦恭是礼貌，对下级谦恭是高尚。</li><li>心态衰老的年轻人，将成为一个年轻的老人。 </li><li>纠正一个错误胜过找出两次错误；但找出一个错误胜过两次犯错。</li><li>如果你知道如何让支出少于收入，就如拥有点金术。</li><li>鱼放三日臭熏天，客访三日被人嫌。 </li><li>拥有并不等于财富，只有懂得享用才是。 </li><li>亚麻勿近火，青年勿沾赌</li><li>缺席者必有过错，出席者必有理由。 </li><li>说得多，误解多。</li><li>生活饱暖的人知书达理。仓廪实而知礼节。 </li><li>人中豪杰均胸怀大志。 </li><li>爱、咳嗽和烟味，皆难隐藏。 </li><li>对谁泄露你的秘密，就等于对谁出卖你的自由。 </li><li>和吝啬鬼谈钱，定将一无所获。 和女人谈年龄，得不到好脸色。 </li><li>读书，但不能滥读书。 </li><li>不必要的东西买得太多，不久你就得卖掉必需品。 </li><li>钱是胆、衣是毛</li><li>懒骨头！若不是为了让你善用，上帝何须给你四肢！ </li><li>倾城美色，难助大事。 摧山之力，不成大志。 富可敌国，那又奈何。 高贵之心，无匹敌者。 </li><li>空口袋，站不直。肚里没货，心中没谱。 </li><li>舌头软绵绵没有骨头，动一动能敲断脊梁骨。 </li><li>当你说话时，看着对方的眼睛；当对方说话时，看着他的嘴巴。</li><li>观察所有人，尤其是自己</li><li>追求美德，直至拥有，余下诸事，顺从天意。 </li><li>婚姻若不门当户对，名为夫妻却如主仆。 </li><li>记住别人对你的帮助；忘掉你对别人的帮助。 </li><li>善加利用时间，才有更多空闲。</li><li>无兽不成林。 </li><li>发现自己无所事事时，应该感到羞愧难当。 </li><li>二十岁时意志主导，三十岁时智慧统治，四十岁时判断做主。<br>-若是无人认错，争吵永无止境</li><li>当骗子们吵架，诚实的人得到了他们的东西；当神父们争吵，我们弄清了真相。 </li><li>起床晚，一天忙，入深夜也难完工。 </li><li>脑力劳动者不应该像体力劳动者吃那么多，他们的消化能力跟不上。 </li><li>人们对看不见的事物，看法往往一致；而对看得见摸得着的事物，看法却时时变化。 </li><li>飞黄腾达时谦逊明智，毕竟兴盛衰败皆有时，而自大者一朝落魄，悲惨境遇没人同情。 </li><li>让所有人了解你，但别让人看透你：水浅被人趟，心浅遭人欺。 </li><li>面包是昨天的好，肉是今天的鲜，酒是去年的香。 </li><li>工人干活靠手，老板干活用眼</li><li>人无礼数，百美难补。 </li><li>怨记忆力差的多，恨判断力差的少。 </li><li>母亲轻佻，女儿命苦</li><li>预防恶习容易，改正恶习困难。 </li><li>下决心以后改正的人，绝对不会马上改。 </li><li>好妻子和好身体，是男人最大的财富。 </li><li>要让妻子息怒，最好奉上礼物。 </li><li>缺点知道自己丑陋，于是带上美丽的面具。 </li><li>女人和美酒，赌博和谎言， 让欲望更深，令财富减少。 </li><li>判断力如此重要，所有人都应需要。拥有它的人很少，却没一个人想要。 </li><li>舌头总是碰到痛牙齿。 </li><li>得点小毛小病，方知健康宝贵。 </li><li>与蠢人一起生活，成天吃吃喝喝；与智者一起生活，时时勤于思索。 </li><li>慷慨不在于付出很多，而在于给得适得其所。 </li><li>言语显智慧，行动见真心。</li><li>贫穷不是耻辱，对贫穷感到耻辱才是。 </li><li>沉迷于穿着打扮，无疑是个不幸； 满足欲望前，先看兜里有多少钱。 </li><li>造访朋友增进友情，但别太频繁。 </li><li>比金子更宝贵的是什么？钻石。比钻石更宝贵的呢？美德。 </li><li>苍蝇避沸水，忙人无闲客。</li><li>挥霍通常比贪心带来更多不公。 </li><li>严厉往往意味着仁慈，仁慈往往也意味严厉。 </li><li>有求必应得太快，要求很快又上门。 </li><li>好脾气越能忍，要忍的就更多</li><li>一个不负责任的女儿背后是一个难管教的妻子。 </li><li>性格太顺从，就是和自己过不去。 </li><li>说大话的人未必是傻瓜，但相信他的人一定是。 </li><li>从天而降的权力易让人傲慢，突如其来的自由易让人放纵；良好行为需要循序渐进地培养。 </li><li>认为金钱无所不能的人，很可能会为了钱无所不为。 </li><li>时运不济时，没人知道你是谁；时来运转时，你却忘了自己是谁。 </li><li>盛赞不如薄赏。 </li><li>最想要的礼物不会白得，而要付出。 </li><li>河流中，最轻的东西漂在上面；腐败的政府里，最没用的人掌管大权。 </li><li>戴手套的猫抓不住老鼠。</li><li>友谊无需客套，但得要有礼貌。 </li><li>柳枝柔弱，但能捆绑柴火。</li><li>人生易老，财有尽时，未雨需绸缪； </li><li>知识属于勤勉的人；财富属于细心的人；权力属于大胆的人；天堂属于道德的人。 </li><li>两枝干柴点燃绿枝。 </li><li>狼皮每年换，本性却难移。</li><li>学习他人的人聪明。 控制冲动的人强大。 知足的人富有。 但没人可以做到。 </li><li>对所有人彬彬有礼； 助很多人一臂之力； 和一些人交情甚好； 和一个人结为挚友； 说到敌人一个没有。 </li><li>衣服上多一块补丁，口袋里多一分钱</li><li>懒鬼睡觉，你勤耕种； 庄稼满仓，可卖可藏。</li><li>为学识沾沾自满，好比被光弄花眼；恃美德而自傲，无异于解毒药吃过了头。 </li><li>在宫廷里升官晋职，要先从卑躬屈膝开始。 </li><li>没什么比眼泪干得更快。</li><li>让傻瓜沉默不礼貌，让他说下去也很残酷。 </li><li>皇冠治不好头疼。</li><li>谦逊的背后是美德。</li><li>节省之后拥有，好过挥霍之后乞求。 </li><li>自负的现代学者轻视古人：如同老师被小学生取笑。 </li><li>比较历史、观察现在、梦想未来</li></ul><h1 id="富兰克林的13条成功要素"><a href="#富兰克林的13条成功要素" class="headerlink" title="富兰克林的13条成功要素"></a>富兰克林的13条成功要素</h1><ol><li>节制：食不过饱；饮酒不醉。 </li><li>缄默：言必于人于己有益；避免无益的聊天。 </li><li>秩序：物归其所，事定期限。 </li><li>决心：做应该做的事情；决心要做的事应坚持不懈。 </li><li>节俭：花钱必须于人于己有益；换言之，切忌浪费。 </li><li>勤勉：不浪费时间，只做那些有用的事情，戒掉一切不必要的行动。 </li><li>诚恳：不以恶意欺骗人；思想要纯洁公正；如果说话，要心口一致。 </li><li>正义：不做伤害人的事情以陷人于不义，不要忘记履行对人有益而又是你应尽的义务。 </li><li>中庸：避免极端；容忍他人怨恨的伤害，只要是你应得的。 </li><li>清洁：身体、衣服和住所力求清洁。 </li><li>平静：不要被小事或普通的不可避免的事故所打扰。 </li><li>贞节：除了为健康或生育后代，少行房事，切忌房事过度，伤害身体，或损害自己或他人的安宁与名誉。 </li><li>谦逊：仿效耶稣和苏格拉底。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本杰明·富兰克林最迷人的创造品之一。了解他从一个社会地位低下的商人到建国之父的发展之路，《穷理查智慧书》可谓占据了中心位置，它也为了解殖民时期的美国打开了一扇迷人的窗户。从那个虚构的文学人格中，展现出富兰克林独有的智慧，这份才智依然能让现在的读者眼前一亮，有所启迪。&lt;br&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="富兰克林" scheme="http://wittyfans.com/tags/%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97/"/>
    
      <category term="为人处事" scheme="http://wittyfans.com/tags/%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%BA%8B/"/>
    
      <category term="名人名言" scheme="http://wittyfans.com/tags/%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>OmniGraffle使用记录</title>
    <link href="http://wittyfans.com/writing/OmniGraffle%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html"/>
    <id>http://wittyfans.com/writing/OmniGraffle使用记录.html</id>
    <published>2018-03-18T13:54:47.000Z</published>
    <updated>2018-03-18T13:58:35.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OmniGraffle是一款运行在Mac OS X 和iPad平台之上的设计软件。它曾获得2002年的苹果设计奖。 可以用来绘制图表， 流程图，组织结构图以及插图，也可以用来来组织头脑中思考的信息，组织头脑风暴的结果，绘制心智图，作为样式管理器，或设计网页或PDF文档的原型。</p></blockquote><a id="more"></a><h1 id="工具栏和检查器"><a href="#工具栏和检查器" class="headerlink" title="工具栏和检查器"></a>工具栏和检查器</h1><p><img src="https://cdn.sspai.com/2017/11/22/6e57ab13fbc4f6d43ce1366a981354b8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><ul><li>不同的工具，单机、双击、长按快捷键对应不同的操作模式，分别是单次使用、保持状态、临时调用。</li><li>所有工具，使用一次后会自动回到选择工具。</li><li>按一次和按两次数字键与用鼠标点击一次或双击效果一样，决定是使用一次后返回「选择」，还是一直处于激活状态；</li></ul><p><img src="https://cdn.sspai.com/2017/11/22/e528997c9c6278bfa4729cdfa47e9da0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><ul><li>⌘1-⌘6 快捷键快速切换对应的检查器面板。</li><li>按住 Option 键可以把一个对象的属性吸取保存下来，再点击就可以直接复制或应用属性到其他对象</li><li>格式刷可以「吸取」的格式非常多，而且可以自定义。</li><li>对象的外观（⌘1）、字体标签设置（⌘2）、连接磁化点（⌘3）、页面属性和图表布局（⌘4）、页边距和文档属性（⌘5）以及模具面板（⌘6）。</li></ul><h1 id="版面、目录、检查器"><a href="#版面、目录、检查器" class="headerlink" title="版面、目录、检查器"></a>版面、目录、检查器</h1><p><img src="https://cdn.sspai.com/2017/11/22/b1784c84b490e467caffdf9c03adeb0e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><ul><li>锁定图层，可以避免误操作</li><li>「眼睛」图标隐藏或显示图层</li><li>「打印机」图标决定打印输出时是否包含这个图层。</li><li>激活「共享图层」图标（呈黄色显示），可以将共享图层的内容显示在其他页面，从而实现特定内容的共用</li><li>图层和页一样，通过拖移可以调整顺序，按住Option可以复制，按住Command可以选择多个页面或图层</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>「目录」面板中提供了三种显示对象的方式：对象列表、大纲层级、近似对象：</p><ul><li>「对象列表」视图按扁平方式列出所有的对象、群组及其层叠顺序，便于快速找到某个具体的对象，通过拖动或点击底部的箭头可以调整对象的层叠顺序，针对复杂的组合形状从列表视图中选择会更方便；</li><li>「大纲层级」按对象之间隶属关系来显示，大纲视窗中不包含线条，只包含形状或图片等元素。大纲视图中输入对象包含的文字内容会很方便，例如，创建组织结构图或者思维导图时直接在大纲视图中输入内容，最后选择自动排版，马上就能获得一个漂亮的结果；</li><li>「近似对象」中更可以一次选中所有相似的对象，对于批量的修改和调整非常有帮助。</li></ul><h1 id="对象控制和样式托盘"><a href="#对象控制和样式托盘" class="headerlink" title="对象控制和样式托盘"></a>对象控制和样式托盘</h1><p><img src="https://cdn.sspai.com/2017/11/22/90656b48f4a6a7f6962c256c5e92955f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><h2 id="控制对象"><a href="#控制对象" class="headerlink" title="控制对象"></a>控制对象</h2><p>这里有一些建议记下来的快捷键：</p><ul><li>前移对象「⌥⌘F」</li><li>后移对象「⌥⌘B」</li><li>移到最前「⇧⌘F」</li><li>置于最后「⇧⌘B」</li></ul><blockquote><p>F 和 B 取的是英文单词的 Front和 Back 的首字母</p></blockquote><h2 id="样式托盘"><a href="#样式托盘" class="headerlink" title="样式托盘"></a>样式托盘</h2><p>检查器底栏的「样式托盘」是 OmniGraffle 中一个非常值得称道的设计，当你选中对象时，「样式托盘」中会分解出当前对象采用的各种格式，和工具栏中的「格式刷」作用一样，不过操作交互上，「样式托盘」更直观和方便，你可以按住托盘中的某一个格式拖拽到其他对象，也可以按住第一个图标拖拽将当前对象的所有格式应用到其他对象。</p><p>按住 command 键，你可以在「样式托盘」中选择多个格式然后拖拽到其他对象，被选中的格式项背景会显示为浅灰色。</p><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><h2 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h2><p>单击选择对象，按住 Shift 键或 Command 键可以将对象添加到选择或者从选择集合去掉。</p><h2 id="圈选对象"><a href="#圈选对象" class="headerlink" title="圈选对象"></a>圈选对象</h2><p>直接拖一个范围，按住Option键则只有完全选中的才会选择进来。</p><h2 id="对象旋转"><a href="#对象旋转" class="headerlink" title="对象旋转"></a>对象旋转</h2><p>按住Command键，再拖动旋转指针，再按住shift会吸附在特定的角度。</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>按住Command，双指滑动。<br>按住 option 控制句柄    基于中心缩放</p><h2 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h2><ul><li>选择线条工具，单击开始绘制，再次单机添加中间点，双击完成绘制。</li><li>线条分四种类型：直线（Straight）、曲线（Curved）、折线（Orthogonal）和贝塞曲线（Bezier），通过工具栏的「收藏夹」图标可以固定默认的绘制类型。</li><li>针对绘制中遇到的线条交叉情况，面板中提供了多种「穿越模式」的样式供选择，默认情况下是「Do nothing」。</li><li>选中线条并在线条上双击可以添加「中间点」，按住 Option 键双击则是添加文本标签。</li></ul><hr><p><em>To be continued</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;OmniGraffle是一款运行在Mac OS X 和iPad平台之上的设计软件。它曾获得2002年的苹果设计奖。 可以用来绘制图表， 流程图，组织结构图以及插图，也可以用来来组织头脑中思考的信息，组织头脑风暴的结果，绘制心智图，作为样式管理器，或设计网页或PDF文档的原型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="writing" scheme="http://wittyfans.com/categories/writing/"/>
    
    
      <category term="设计" scheme="http://wittyfans.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="画图" scheme="http://wittyfans.com/tags/%E7%94%BB%E5%9B%BE/"/>
    
      <category term="原型图" scheme="http://wittyfans.com/tags/%E5%8E%9F%E5%9E%8B%E5%9B%BE/"/>
    
      <category term="App" scheme="http://wittyfans.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>Linux阅读笔记</title>
    <link href="http://wittyfans.com/coding/Linux%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/coding/Linux阅读笔记.html</id>
    <published>2018-03-18T13:17:51.000Z</published>
    <updated>2018-03-18T13:19:29.239Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鸟哥的Linux私房菜阅读笔记，截取了重要的概念与常用的命令。</p></blockquote><a id="more"></a><h1 id="按下开机键后发生了什么？"><a href="#按下开机键后发生了什么？" class="headerlink" title="按下开机键后发生了什么？"></a>按下开机键后发生了什么？</h1><ol><li>按下开机键<br>BIOS 步骤：<br>计算机从主板的 BIOS(Basic Input/Output System) 中读取存储的程序</li><li>MBR 步骤：<br>该程序从存储设备中读取起始的 512 字节数据（称为主引导记录 Master Boot Record, MBR）</li><li>Boot Loader 步骤：MBR 告诉计算机从哪个分区(Partition)来载入引导加载程序(Boot Loader)，Boot Loader 保存了操作系统的相关信息</li><li>Kernel 步骤：Boot Loader 根据所存储的信息加载内核(Kernel)，内核主要的任务是管理计算机的硬件资源</li><li>Init 步骤：内核会为自己预留内存空间，然后进行硬件检测，之后启动 init 进程（1 号进程），之后的操作会由 init 进程来接管<br>初始化脚本步骤：如果没有进入单用户模式，就会为操作系统启动做各种初始化工作，包括计算机基本信息、文件系统、硬盘、清理临时文件、设置网络等等</li><li>登录步骤：操作系统准备好之后，我们就可以用用户名和密码登录到计算机中，我们成为了一个用户，属于某个用户组</li></ol><h1 id="终端与仿真器"><a href="#终端与仿真器" class="headerlink" title="终端与仿真器"></a>终端与仿真器</h1><p>在大型机时代，终端是一个硬件设备，用来进行输入输出，而随着计算机硬件的发展，终端已经慢慢从实体变成了一个概念。现在的终端已经变成了一种软件层面的模拟，所以可以这样理解，现代计算中的终端是一个用软件仿真的终端，我们在这上面输入输出的命令会传给具体执行这些命令的 shell 程序，再由 shell 程序执行对应的系统调用。重要的事情说三遍：终端不是 shell，终端不是 shell，终端不是 shell。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ul><li>文件系统是一个树结构，树的根就是我们常常能看到的根目录 /。</li><li>对于目录来说，里面至少会包含两个条目：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. 当前目录</span><br><span class="line">.. 指向上级目录</span><br></pre></td></tr></table></figure><ul><li>当一个文件被放入到目录中，实际上就是建立了一个到该文件的硬链接(hard link)，当对这个文件的硬链接数目为零的时候，文件实际上就被删除了。不过现在基本都使用软链接(soft link)，类似于 windows 中的快捷方式，不会影响链接数目。</li></ul><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><p>存储设备的前 512 字节是 MBR，用于开机启动，剩余的空间可能会被分为多个分区(partition)，每个分区有对应的分区表(partition table)来记录分区的相关信息（比如起始位置和分区大小）。需要注意的是，分区表并不保存在该分区中，不然万一分区挂了，连最关键的分区表都找不到了。<br>看一张图：</p><p><img src="http://wittyfans.com/images/14590056997684.jpg" alt="文件系统的实现"></p><p>Boot block 是为计算机启动而准备的，在 MBR 指定启动分区之后，就会把 Boot block 部分的程序读入内存执行。为了方便管理，即使该分区没有操作系统，仍然会预留 Boot block<br>Super block 存储文件系统的信息，比如类型、inode 数目和数据块的数目<br>inodes 是文件存储的关键，每个文件对应一个 inode，inode 中包含指向具体数据的指针，读取的时候根据这些指针进行数据读取即可<br>Data blocks 就是具体的数据了，我们通过 inode 中的指针来进行访问</p><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><ul><li>读取 Read: 获取数据</li><li>写入 Write: 创建新文件或在旧文件中写入数据</li><li>运行 Execute: 文件是可执行的二进制代码，那么会被载入内存进行执行</li><li>每一个文件都有三种权限，对应三种用户的读、写、可执行权限，例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  1 wittyfans  staff  0 Feb  3 20:24 HelloWord.txt</span><br></pre></td></tr></table></figure><ul><li>解释如下：<ul><li>第一个字符，如果是 - 表示常规文件，如果是 d 表示目录</li><li>当为[ d ]则是目录，例如上表文件名为“.config”的那一行；</li><li>当为[ - ]则是文件，例如上表文件名为“initial-setup-ks.cfg”那一行；</li><li>若是[ l ]则表示为链接文件（link file）；</li><li>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；</li><li>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设</li><li>备）。</li><li>后面的九个字符表示 所有者, 群组 和 其他人 的权限</li><li>rwx 分别代表读取、写入和执行，如果是 - 则表示没有对应的权限</li><li>第二列的数字是 hard link 的数目</li><li>第三、四列是所属的用户和用户所在的用户组</li><li>第五列是文件大小，单位是字节 byte</li><li>最后的是上一次写入的时间</li></ul></li></ul><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>用于群组、拥有者、各种身份的权限之修改的指令：</p><ul><li>chgrp ：改变文件所属群组</li><li>chown ：改变文件拥有者</li><li>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</li><li>改变所属群组, chgrp</li></ul><p>改变群组的命令，这个群组必须要存在才可以，否则会失败，改变用户的命令同理<br>对于chmod命令，如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上 -R 的选项<br>如果用root用户复制一个文件给其他的用户，默认会复制所有的权限属性，所以复制完了之后需要更改权限</p><h3 id="用数字类型改变文件权限"><a href="#用数字类型改变文件权限" class="headerlink" title="用数字类型改变文件权限"></a>用数字类型改变文件权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= --- = 0+0+0 = 0</span><br><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure><h3 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,go=rx .bashrc</span><br><span class="line">chmod u=rwx,g=rx,o=r filename</span><br><span class="line"></span><br><span class="line">u = user</span><br><span class="line">g/o = group与others</span><br></pre></td></tr></table></figure><p>也可以直接再原来的权限上增加或者删除权限，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+w filename</span><br></pre></td></tr></table></figure><p>给a(所有人)增加写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x filename</span><br></pre></td></tr></table></figure><h2 id="文件和目录权限的不同"><a href="#文件和目录权限的不同" class="headerlink" title="文件和目录权限的不同"></a>文件和目录权限的不同</h2><p>对于文件：<br>r （read）：可读取此一文件的实际内容，如读取文本文件的文字内容等；<br>w （write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）；可执行在windows中由扩展名决定，而linux中由x这个权限来控制。<br>x （eXecute）：该文件具有可以被系统执行的权限。</p><p>对于目录：<br>目录主要的内容在记录文件名清单，所以：</p><p><strong>r （read contents in directory）：</strong></p><p>表示具有读取目录结构清单的权限，所以当你具有读取（r）一个目录的权限时，表示你<br>可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</p><p><strong>w （modify contents of directory）：</strong></p><p>这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构清单<br>的权限，也就是下面这些权限：<br>创建新的文件与目录；<br>删除已经存在的文件与目录（不论该文件的权限为何！）<br>将已存在的文件或目录进行更名；<br>搬移该目录内的文件、目录位置。 总之，目录的w权限就与该目录下面的文件名异<br>动有关就对了啦！</p><p><strong>x （access directory）：</strong></p><p>咦！目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没<br>错！目录不可以被执行，目录的x代表的是使用者能否进入该目录成为工作目录的用途！<br>所谓的工作目录（work directory）就是你目前所在的目录啦！举例来说，当你登陆Linux<br>时， 你所在的主文件夹就是你当下的工作目录。而变换目录的指令是“cd”（change<br>directory）啰！</p><p>若A对X的目录是rwx，x下面有一个y目录，A对y的权限是—，因为y是x的子目录，A可以删除这个目录，但不可以读写或者执行。</p><h2 id="文件系统常用操作"><a href="#文件系统常用操作" class="headerlink" title="文件系统常用操作"></a>文件系统常用操作</h2><p>###　复制 cp<br>选项与参数：</p><ul><li>-a ：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li><li>-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</li><li>-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</li><li>-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li><li>-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</li><li>-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li><li>-r ：递回持续复制，用于目录的复制行为；（常用）</li><li>-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</li><li>-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</li><li>–preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</li><li>最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li></ul><h3 id="移动-mv"><a href="#移动-mv" class="headerlink" title="移动 mv"></a>移动 mv</h3><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会更新 （update）</li></ul><h3 id="删除-rm"><a href="#删除-rm" class="headerlink" title="删除 rm"></a>删除 rm</h3><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul><li>cat 由第一行开始显示文件内容（Concatenate）<ul><li>-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字符 $ 显示出来；</li><li>-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul></li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl 显示的时候，顺道输出行号！<ul><li>-b ：指定行号指定的方式，主要有两种：</li><li>-b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）；</li><li>-b t ：如果有空行，空的那一行不要列出行号（默认值）；</li><li>-n ：列出行号表示的方法，主要有三种：</li><li>-n ln ：行号在屏幕的最左方显示；</li><li>-n rn ：行号在自己字段的最右方显示，且不加 0 ；</li><li>-n rz ：行号在自己字段的最右方显示，且加 0 ；</li><li>-w ：行号字段的占用的字符数。</li></ul></li><li>more 一页一页的显示文件内容（快捷键如下）<ul><li>空白键 （space）：代表向下翻一页；</li><li>Enter ：代表向下翻“一行”；</li><li>/字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字，搜了之后按n往下面匹配；</li><li>:f ：立刻显示出文件名以及目前显示的行数；</li><li>q ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul></li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！（使用pageup和pagedn）<ul><li>空白键 ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串 ：向下搜寻“字串”的功能；</li><li>?字串 ：向上搜寻“字串”的功能；</li><li>n ：重复前一个搜寻 （与 / 或 ? 有关！）</li><li>N ：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li><li>g ：前进到这个数据的第一行去；</li><li>G ：前进到这个数据的最后一行去 （注意大小写）；</li></ul></li></ul><h3 id="取文件的数据"><a href="#取文件的数据" class="headerlink" title="取文件的数据"></a>取文件的数据</h3><ul><li>head 只看头几行<ul><li>若没有加上 -n 这个选项时，默认只显示十行，若只要一行呢？那就加入“head -n 1 filename ”即可！</li><li>-n -100时，代表列前的所有行数， 但不包括后面100行。</li></ul></li><li>tail 只看尾巴几行<ul><li>“tail -n +100/etc/man_db.conf” 代表该文件从100行以后都会被列出</li></ul></li><li>od 以二进制的方式读取文件内容！<ul><li>-t ：后面可以接各种“类型 （TYPE）”的输出，例如：<ul><li>a ：利用默认的字符来输出；</li><li>c ：使用 ASCII 字符来输出</li><li>d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；</li><li>f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；</li><li>o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；</li><li>x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</li></ul></li></ul></li></ul><p>例如：我不想找 google，想要立刻找到 password 这几个字的 ASCII 对照，该如何通过 od<br>来判断？答：其实可以通过刚刚上一个小节谈到的管线命令来处理！如下所示： echo<br>password | od -t oCc echo 可以在屏幕上面显示任何信息，而这个信息不由屏幕输出，而是传<br>给 od 去继续处理！就可以得到 ASCII code 对照啰！</p><h3 id="修改文件时间、创建新文件"><a href="#修改文件时间、创建新文件" class="headerlink" title="修改文件时间、创建新文件"></a>修改文件时间、创建新文件</h3><p>查看时间按的时候主要有三个时间，mtime、ctime、atime，即修改时间，状态改变的时间，内容上次取用时间。<br>touch命令：<br>-a ：仅修订 access time；<br>-c ：仅修改文件的时间，若该文件不存在则不创建新文件；<br>-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 –date=”日期或时间”<br>-m ：仅修改 mtime ；<br>-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</p><h3 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h3><p>使用umask 指定 “目前使用者在创建文件或目录时候的权限默认值“<br>查阅的方式有两种，</p><ul><li>一种可以直接输入 umask ，就可以看到数字体态的权限设置分数， </li><li>一种则是加入 -S （Symbolic） 这个选项，就会以符号类型的方式来显示出权限了！</li></ul><h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><p>File 命令可以用来查看某个文件的类型</p><ul><li>每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目 录树才能被我们使用。 将文件系统与目录树结合的动作我们称为“挂载”。</li><li>文件名只与目录有关，但是文件内容则与 inode</li><li>多个文件名对应到同一个 inode,即Hard-link</li></ul><h2 id="关于PATH"><a href="#关于PATH" class="headerlink" title="关于PATH"></a>关于PATH</h2><p>将一些常用的路径添加到PATH后，就可以直接再任何目录下执行该命令，而不必使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/xxx</span><br></pre></td></tr></table></figure><p>的格式了。将命令添加到PATH的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=&quot;$&#123;PATH&#125;:/root&quot;</span><br></pre></td></tr></table></figure><p>某些情况下，即使你已经将 ls 搬回 /bin 了，不过系统还是会告知你无法处理 /root/ls。很<br>可能是因为指令参数被高速缓存的关系。 不要紧张，只要登出 （exit） 再登陆 （su -） 就可<br>以继续快乐的使用 ls 了！</p><h1 id="管道与流"><a href="#管道与流" class="headerlink" title="管道与流"></a>管道与流</h1><p>Linux 在执行程序的时候，会自动打开三个流：</p><ul><li>标准输入(Standard Input)</li><li>标准输出(Standard Output)</li><li>标准错误(Standard Error)</li></ul><p>比如我们想要把一个命令的输出变成另外一个程序的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | wc -w</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul><li>最基础的操作是指令，一堆指令在一起就是程序，而进程就是程序的具体实现，也就是把程序载入到内存中并执行的过程。</li><li>操作系统的重要功能之一便是对进程进行从摇篮（分配内存空间）到坟墓（回收）的管理。</li></ul><p><img src="http://wittyfans.com/images/14807437718754.jpg" alt="ps -eo pid,comm,cmd（列出全部进程并展示 pid, command 和 cmd 信息）"></p><ul><li>第一列是 pid，相当于身份证号；</li><li>第二列是进程的简称；</li><li>第三列是进程启动时候的命令。</li><li>如果我们往上滚动，就会找到这样的一行 1 init /sbin/init，这个就是内核建立的唯一一个进程了，剩下的进程都是 init 通过 fork 方式创建的，也就是说，所有的其他进程都是 init 的子进程。</li><li>父子进程：子进程终结的时候会通知父进程进行内存空间的回收，而如果父进程比子进程还早终结，那么这个子进程就会被过继给 init 进程，并由 init 进程通过调用 wait 函数进行回收。如果无法正确回收，那么这个子进程就成为了僵尸进程，所占据的内存空间就无法被访问了。</li><li>进程组(process group)：每个进程组中有多个进程，进程组的 pid 由进程组 leader 的 pid 决定。而多个进程组还可以组成一个会话(session)，会话使得前台和后台程序得以展示出来。当我们创建了多个终端窗口，实际上就创建了多个会话，每个会话都有其前台和后台进程。<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2></li><li>进程间用信号交流，所谓信号就是一个整数，一个由进程 A 发送给进程 B 的整数。因为一个整数所能携带的信息量有限，所以一般用于系统管理。</li><li>信号的传递机制也很简单，由内核，或者由其他进程经由内核往目标进程发送信号，实际上是在该进程对应的表中写入信号。当进程执行完系统调用退出内核的时候，就会查看这个信号，然后根据信号的不同执行不同的操作。</li></ul><p>具体什么整数表示什么意思可以通过 man 7 signal 来查看，常见的有：</p><ul><li>SIGINT: 当键盘按下 CTRL+C 从 shell 中发出信号，信号被传递给 shell 中前台运行的进程，对应该信号的默认操作是中断(INTERRUPT)该进程</li><li>SIGQUIT: 当键盘按下 CTRL+\ 从 shell 中发出信号，信号被传递给 shell 中前台运行的进程，对应该信号的默认操作是退出(QUIT)该进程</li><li>SIGTSTP: 当键盘按下 CTRL+Z 从 shell 中发出信号，信号被传递给 shell 中前台运行的进程，对应该信号的默认操作是暂停(STOP)该进程</li><li>SIGCONT: 用于通知暂停的进程继续</li><li>SIGALRM: 起到定时器的作用，通常是程序在一定的时间之后才生成该信号</li></ul><p>上面的介绍说『默认』操作，那么也就意味着我们是可以采取其他操作的，比方说直接无视掉，或者执行我们自定义的操作。</p><p>除了信号，消息队列(message queue)和共享内存(shared memory)也可以在进程间进行信息共享。不过因为这种机制比较复杂，尤其是涉及到同步的问题，所以在使用的时候需要多加注意。</p><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><h2 id="HelloWord"><a href="#HelloWord" class="headerlink" title="HelloWord"></a>HelloWord</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello World! This is wittyfans.&quot;</span><br><span class="line"># 显示时间</span><br><span class="line">echo &quot;Today is: &quot; $(date)</span><br></pre></td></tr></table></figure><ul><li>第一行叫 shebang，用来告知系统如何执行该脚本，这句话的意思就是说要用 /bin/bash 这个程序来跑这段代码。有意思的是，这一句也可以带参数，如果我们想开启调试功能，可以把第一句改为 #!/bin/bash -xv 即可</li><li>用 # 表示这个符号之后同一行是注释</li><li>每一句指令用换行或分号隔开</li><li>可以用 echo 命令来输出字符串，默认添加一个换行符</li><li>可以用 date 命令来获取当前的时间</li><li>如果想在一条指令里插入另一条指令，可以把另一条指令用 $() 包住（就像 date 那样）</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>Tab 能够自动补全，从命令名称到文件夹到路径，多按两下还能出个列表方便我们输入，是居家旅行必备操作，如果只能记住一个快捷键，那么记住 Tab 即可</li><li>Ctrl+R 用来搜索，按下之后就可以输入搜索的关键词，再按一次 Ctrl+R 可以切换到下一个匹配的结果，如果找到合适的，按下 Enter 就可以执行，按下 → 会把查询结果放到当前行，我们可以进行编辑</li><li>Ctrl+W 删除该行最后一个单词，至于怎么定义一个单词呢？常见的分隔符有 空格, _, ,, :, - 等等（基本上不是字母和数字就可以认为是分隔符）</li><li>Ctrl+U 删除整行</li><li>Ctrl+A 将光标移到行首</li><li>Ctrl+E 将光标移到行尾</li><li>Ctrl+K 删除从光标处到行尾的所有内容</li><li>Ctrl+L 清屏</li><li>输入 history 可以查看命令行的历史</li><li>输入 !$ 查看最后输入的参数</li><li>输入 !! 查看上一条命令</li><li>输入 cd - 可以回到上一个工作路径</li><li>如果想要设定 bash 的提示文本，需要修改 ~/.bashrc 中的 PS1 环境变量</li><li>好！了解了这些我们就可以继续旅程了，我们就从前面出现的 echo 命令说起吧！</li></ul><h2 id="打印文本"><a href="#打印文本" class="headerlink" title="打印文本"></a>打印文本</h2><h3 id="Echo"><a href="#Echo" class="headerlink" title="Echo"></a>Echo</h3><p>前面我们输出字符串时，用的命令是 echo “Hello World! This is wittyfans.”，其中字符串是用双引号包住的，但其实不带双引号，或者用单引号也可以完成这样的效果，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo Hello World</span><br><span class="line">Hello World</span><br><span class="line">$ echo &apos;Hello World&apos;</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>那么问题来了，这三种用什么区别呢？</p><ul><li>不带引号的 echo 没办法显示 ;，因为分号是用来分隔命令的<br>使用单引号 echo 不会对命令中的变量求值，只按照原样显示（变量会在下一节说明，这里简单有个概念即可）</li><li>使用双引号 echo 有些值需要进行转义（使用 \），比方说感叹号<br>printf</li></ul><p>除了 echo 命令，我们其实还可以用 printf 命令来进行格式化输出，不过需要注意的是这里我们需要自己添加换行符，我们在前面的脚本文件中添加如下三行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%-5s %-10s %4s\n&quot; No. Name Score</span><br><span class="line">printf &quot;%-5s %-10s %4.2f\n&quot; 1 wittyfans 99.9999</span><br><span class="line">printf &quot;%-5s %-10s %4.2f\n&quot; 43 dawang 66.6566</span><br></pre></td></tr></table></figure><p>然后我们再执行一下，结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./hw.sh</span><br><span class="line">Hello World! This is wittyfans.</span><br><span class="line">Today is:  Tue Aug 2 16:58:16 CST 2016</span><br><span class="line">No.   Name       Score</span><br><span class="line">1     wittyfans     100.00</span><br><span class="line">43    dawang     66.66</span><br></pre></td></tr></table></figure><p>这里能学到的套路是什么呢？</p><ul><li>%s, %c, %d, %f 是格式替代符，就是和 C 语言一样的方式</li><li>%-5s 指明了一个左对齐且宽度为 5 的字符串，如果内容不足 5 个字符，则会以空格填充</li><li>%4.2f 表示保留两位小数可以看到是默认四舍五入的</li><li>最后要加上 \n 才能正确换行</li></ul><h3 id="cat-head-tail-uniq-cut"><a href="#cat-head-tail-uniq-cut" class="headerlink" title="cat, head, tail, uniq, cut"></a>cat, head, tail, uniq, cut</h3><p>打印文本常用的命令还有 cat, head, tail, uniq, cut，这里主要针对文件的输出，我们先创建一个文本文件 sample.txt，其内容为</p><ul><li>1 hohoho .yo</li><li>1 hohoho .max</li><li>2 ohohoh .I</li><li>2 ohohoh .I</li><li>3 hahaha .want</li><li>4 ahahah .to</li><li>5 wowwow .see</li><li>6 mummum .you</li></ul><p>接下来给出几个简单的实例，具体命令的用法，可以使用 man command 来进行查询，或者用 TLDR 命令来查询（我更推荐后者）</p><ul><li>打印文件内容 cat sample.txt</li><li>打印后 4 行 tail -n 4 sample.txt</li><li>打印头 4 行 head -n 4 sample.txt</li><li>忽略重复的行 uniq sample.txt</li><li>显示重复的行 uniq -d sample.txt</li><li>打印每行 . 之前的内容 cut -d ‘.’ -f 1 sample.txt</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>首先要了解的是环境变量，我们可以通过 env 命令查看系统当前的环境变量，也就是那些不需要在脚本中显式声明就可以直接使用的变量。和之前一样，我们先来看一个例子，在之前的脚本中加入下面几行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#export 设置环境变量，在该 shell 脚本执行阶段有效</span><br><span class="line">export MY_WEB=http://www.wittyfans.com</span><br><span class="line">echo &quot;My home is $HOME&quot;</span><br><span class="line">web=&quot;wittyfans.com&quot;</span><br><span class="line">echo &quot;My website is $&#123;web&#125;&quot;</span><br><span class="line">echo &apos;This is not $MY_WEB&apos;</span><br><span class="line">echo $&#123;web/com/cn&#125;</span><br><span class="line">echo &quot;上一个程序的返回值: $?&quot;</span><br><span class="line">echo &quot;脚本的 PID: $$&quot;</span><br><span class="line">echo &quot;参数个数: $#&quot;</span><br><span class="line">echo &quot;脚本参数: $@&quot;</span><br><span class="line">echo &quot;分隔好的脚本参数 第一个:$1 第二个:$2&quot;</span><br></pre></td></tr></table></figure><p>我们执行的时候带两个参数试试看 ./hw.sh hello world，结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./hw.sh hello world</span><br><span class="line">#前面部分省略</span><br><span class="line">#..........</span><br><span class="line">My home is /Users/dawang</span><br><span class="line">My website is wittyfans.com</span><br><span class="line">This is not $MY_WEB</span><br><span class="line">Wittfyans.com</span><br><span class="line">上一个程序的返回值: 0</span><br><span class="line">脚本的 PID: 9782</span><br><span class="line">参数个数: 2</span><br><span class="line">脚本参数: hello world</span><br><span class="line">分隔好的脚本参数 第一个:hello 第二个:world</span><br></pre></td></tr></table></figure><ul><li>变量声明 web=”wittyfans.com” 即可</li><li>使用变量的时候需要加上 $ 或者 ${}，我更推荐后者，看起来更清晰</li><li>单引号不会展开变量，参考 echo ‘This is not $MY_WEB’</li><li>在变量内部进行字符串替换 echo ${web/com/cn} 就可以把原来的 wittyfans.com 中的 com 换成 cn</li><li>内置的参数很好用，具体可以参考脚本中的内容（已经很详细）</li><li>环境变量中比较常用的有 HOME, PWD, USER, UID, SHELL</li></ul><p>下面再给出一些常见的用法</p><ul><li>获得字符串长度可以在变量前加 #</li><li>识别当前 shell 可以用 echo $SHELL 或 echo $0</li><li>检测是否是超级用户可以通过 $UID 的值判断，如果是超级用户，UID 应为 0</li><li>数组</li></ul><p>Bash 支持普通数组（下标是整数）和关联数组（下标是字符串，类似 Map），我们直接上脚本代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 定义数组</span><br><span class="line">iarray=(1 2 3 4 5 6 7)</span><br><span class="line">iiarray=(&quot;one&quot; &quot;two&quot; &quot;three&quot;)</span><br><span class="line">echo $&#123;iarray[0]&#125;</span><br><span class="line">echo $&#123;iiarray[2]&#125;</span><br><span class="line"># 打印所有值</span><br><span class="line">echo $&#123;iiarray[*]&#125;</span><br><span class="line"># 还是打印所有值</span><br><span class="line">echo $&#123;iiarray[@]&#125;</span><br></pre></td></tr></table></figure><p>打印数组长度只需要在数组变量前加 # 符号。关联数组因为需要 Bash 4.0 以上，这里暂时略过。</p><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>通常我们使用 let, (( )) 和 [ ] 来执行基本的算术操作，使用 expr 和 br 来进行高级操作。老规矩，先看脚本代码，在 hw.sh 中添加下面几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class1=33</span><br><span class="line">class2=44</span><br><span class="line">let total=class1+class2</span><br><span class="line">echo $total</span><br><span class="line">let class1++</span><br><span class="line">let class2--</span><br><span class="line">total=$[ $class1 + class2 ]</span><br><span class="line">echo $total</span><br><span class="line">echo &quot;4 * 3.45&quot; | bc</span><br></pre></td></tr></table></figure><p>执行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./hw.sh hello world</span><br><span class="line"># 前面部分省略</span><br><span class="line"># ..........</span><br><span class="line">77</span><br><span class="line">77</span><br><span class="line">13.80</span><br></pre></td></tr></table></figure><p>这里我们可以简单了解</p><ul><li>let 之后变量名不需要加 $</li><li>[] 中的变量可以加 $，也可以不加</li><li>let 及 expr 仅支持整数</li><li>bc 支持浮点数，可以通过 stdin 来传给 bc（就是 | 符号）</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>这部分我们需要记住三个数字</p><ul><li>0 - stdin 标准输入</li><li>1 - stdout 标准输出</li><li>2 - stderr 标准错误<br>重定向输出所用符号是 &gt; 和 &gt;&gt;，其中 &gt; 会清空文件，而 &gt;&gt; 则是追加。那前面的三个数字在哪里呢？其实 &gt; 相当于 1&gt;，&gt;&gt; 相当于 1&gt;&gt;</li></ul><p>然后我们来看看标准错误输出，一般来说有两种处理方式，一种是和标准输出重定向到一起，那么通过 command &gt; output.txt 2&gt;&amp;1 或 cmd &amp;&gt; output.txt 即可；另一种则是分开两个文件，那么使用 command 2&gt;stderr.txt 1&gt;stdout.txt 即可；如果不想保存任何标准错误输出（甚至都不想在终端中见到），可以 command 2&gt;/dev/null，这里的 /dev/null 是一个特殊的设备文件，接收到的任何数据都会被丢弃。</p><p>标准输入的用法和输出类似，这里不再赘述。另外如果需要把标准输出通过管道运到两个不同的地方时（| 只能重定向到一个地方），可以使用 tee 命令，不过这里暂时略过，留到之后的中级教程中介绍。</p><h3 id="条件流程"><a href="#条件流程" class="headerlink" title="条件流程"></a>条件流程</h3><p>比较常用的就是 if 的套路，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition;</span><br><span class="line">then</span><br><span class="line">    commands;</span><br><span class="line">elif condition;</span><br><span class="line">then</span><br><span class="line">    commands;</span><br><span class="line">else</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果觉得这样写太长，可以利用逻辑操作与短路原理来进行编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 如果 condition 为真，则执行 action</span><br><span class="line">[ condition ] &amp;&amp; action;  </span><br><span class="line"># 如果 condition 为假，则执行 action</span><br><span class="line">[ condition ] || action;</span><br></pre></td></tr></table></figure><h3 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h3><p>条件通常被放置在封闭的中括号内，一定要注意 [ 和 ] 脸变有空格！如果我们需要进行算术比较，就需要使用如下的比较符号</p><ul><li>-gt 大于</li><li>-lt 小于</li><li>-ge 大于等于</li><li>-le 小于等于</li><li>-eq 等于</li><li>-ne 不等于</li><li>-a 逻辑与，例如 [ $var -ne 0 -a $var2 -gt 2 ]</li><li>-o 逻辑或，例如 [ $var -ne 0 -o $var2 -gt 2 ]</li></ul><p>一个实际的例子：检测是否是超级用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ $UID -ne 0 ]; then</span><br><span class="line">    echo &quot;你不是超级用户(root)，请以 root 身份运行&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;当前是超级用户&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="文件系统测试"><a href="#文件系统测试" class="headerlink" title="文件系统测试"></a>文件系统测试</h3><p>有的时候我们可能需要对不同的文件进行一定的判断，下面是可以使用的比较方法：</p><ul><li>[ -f $file_var ] 如果给定的变量包含正常的文件路径或文件名，则返回真</li><li>[ -x $var ] 如果给定的变量包含的文件可执行，则返回真</li><li>[ -d $var ] 如果给定的变量包含的是目录，则返回真</li><li>[ -e $var ] 如果给定的变量包含的文件存在，则返回真</li><li>[ -c $var ] 如果给定的变量包含的是一个字符设备文件，则返回真</li><li>[ -b $var ] 如果给定的变量包含的是一个块设备文件的路径，则返回真</li><li>[ -w $var ] 如果给定的变量包含的文件可写，则返回真</li><li>[ -r $var ] 如果给定的变量包含的文件可读，则返回真</li><li>[ -L $var ] 如果给定的变量包含的是一个符号链接，则返回真</li></ul><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>比较字符串的时候最好使用双中括号，比较的语法为：</p><ul><li>[[ $str1 = $str2 ]] 文本一样时返回真，注意 = 前后都必须有一个空格</li><li>[[ $str1 == $str2 ]] 文本一样时返回真，和上一个一样，只是写法不同</li><li>[[ $str1 != $str2 ]] 文本不一样时返回真</li><li>[[ $str1 &gt; $str2 ]] 如果 str1 的字母序比 str2 大，则返回真</li><li>[[ $str1 &lt; $str2 ]] 如果 str1 的字母序比 str2 小，则返回真</li><li>[[ -z $str1 ]] 如果 str1 是空字符串，则返回真</li><li>[[ -n $str1 ]] 如果 str1 是非空字符串，则返回真</li><li>可以通过 &amp;&amp; 和 || 来组合多个条件。如果不想写太多的方括号，那么可以用 test 命令，比如 [ $var -eq 0] 等价于 test $var -eq 0</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>设定 IFS 变量即告诉 shell 脚本要以什么为分隔符，这里的 IFS 表示 Internal Field Separator。我们来看看下面一段脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data=&quot;class1,class2,class3,class4&quot;</span><br><span class="line">IFS=,</span><br><span class="line">for item in $data;</span><br><span class="line">do</span><br><span class="line">    echo Item: $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Item: class1</span><br><span class="line">Item: class2</span><br><span class="line">Item: class3</span><br><span class="line">Item: class4</span><br></pre></td></tr></table></figure><p>这里因为指定了分隔符，所以会把字符串用 ,，分隔，然后就可以利用循环来输出了。前面的例子中我们看到了 for 循环，这里我们再来看一段 for 循环的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;a..z&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这样就可以输出 a-z 了，当然也可以换成其他的，比如 {1..43}, {a..h}, {A..K} 等等</p><p>还可以使用类似 C 语言的 for 循环，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for ((i=0; i&lt;10; i++))</span><br><span class="line">&#123;</span><br><span class="line">    echo $i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的循环有 while 和 until，其实是类似的，这里只给出格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># while 循环</span><br><span class="line">while condition # 如果 condition 为 true 则是无限循环</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br><span class="line"># until 循环</span><br><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    action</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的定义和非常简单，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo()</span><br><span class="line">&#123;</span><br><span class="line">   echo &quot;Arguments work just like script arguments: $@&quot;</span><br><span class="line">   echo &quot;And: $1 $2...&quot;</span><br><span class="line">   echo &quot;This is a function&quot;</span><br><span class="line">   return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以省略 function 关键词，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar ()</span><br><span class="line">&#123;</span><br><span class="line">   echo &quot;Another way to declare functions!&quot;</span><br><span class="line">   return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的话，直接输入函数名即可，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">foo hello world</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>简单来说，别名类似于网上很流行的短链接，只不过我们可以具体设定，比方说我每次写博客都需要进入到某个文件夹，那么我可以这么写 alias blog=”cd ~/Documents/Blog”，我想要快速发布博客时，可以这么写 alias post=”hexo g -d”。这之后我就可以直接用 blog 和 post 命令了，非常方便。</p><p>如果想要在每次打开新的 shell 进程时都能够使用这两个『新』命令，那么可以把前面两句写在 ~/.bashrc 或 ~/.bash_profile 中。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Shell 脚本最强大的地方就是能够通过管道把不同的应用程序串起来，这样每个都完成一小部分工作，最终完成一个看起来很复杂的任务。大概的样子是这样的 $ command1 | command2 | command3</p><p>大家可以尝试一下这条命令 ls | cat -n</p><p>小结<br>本文我们从打印文本开始，见到了解了最基本的 Shell 脚本语法和 Bash 的基本操作。之后的系列文章会继续深入下去，用更多例子来进行讲解。</p><h1 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><ul><li>–help：查看指令信息</li><li>man：查看帮助信息，其中第一个指令后面的数字有特殊意义<ul><li>1:使用者在shell环境中可以操作的指令或可可执行文件</li><li>5：配置文件或者是某些文件的格式</li><li>8: 系统管理员可用的管理指令<br>cal 显示日历</li></ul></li></ul><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>基本上，man page大致分成下面这几个部分：<br>代号 内容 说明<br>NAME 简短的指令、数据名称说明<br>SYNOPSIS 简短的指令下达语法（syntax）简介<br>DESCRIPTION 较为完整的说明，这部分最好仔细看看！<br>OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明<br>COMMANDS 当这个程序（软件）在执行的时候，可以在此程序（软件）中下达的<br>指令<br>FILES 这个程序或数据所使用或参考或链接到的某些文件<br>SEE ALSO 可以参考的，跟这个指令或数据有相关的其他说明！<br>EXAMPLE 一些可以参考的范例</p><p>man page中<br>利用 / 或 ? 来搜寻字串时，可以用 n 来继续下一个搜寻 （不论是 / 或 ?） ，<br>可以利用 N 来进行“反向”搜寻。举例来说，我以 /vbird 搜寻 vbird 字串， 那么<br>可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字串， 那<br>我可以用 n 继续“向上”查询，用 N 反向查询。</p><p>man -f [指令]，寻找相关的指令帮助<br>man -k [指令]，寻找描述和名字中包含指令的帮助</p><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>和man差不多，但info是文字模式的网页显示数据<br>按h显示info page页面下的快捷键<br>按n和p，u来去别的节点<br>按空格翻页<br>按q退出</p><h1 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h1><h2 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h2><p>nano 文件名 会直接创建一个文件<br>使用ctrl+x保存文件</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>待完成</p><h1 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h1><ul><li>syne 命令可以让内存中的信息直接保存到硬盘中，防止数据丢失</li><li>shutdown/poweroff 关机</li><li>halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关</li><li>poweroff 进入系统关机模式，直接关机没有提供电力喔！</li><li>reboot 直接重新开机</li><li>suspend 进入休眠模式</li></ul><h1 id="附录——常用命令"><a href="#附录——常用命令" class="headerlink" title="附录——常用命令"></a>附录——常用命令</h1><h2 id="压缩解压-tar"><a href="#压缩解压-tar" class="headerlink" title="压缩解压 tar"></a>压缩解压 tar</h2><p>如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 tar 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。</p><p>使用 tar 命令只要记得参数是『必选+自选+f』即可，我们先来看看『必选！五选一』:</p><ul><li>-c 意为 create，表示创建压缩包</li><li>-x 意为 extract，表示解压</li><li>-t 表示查看内容</li><li>-r 给压缩包追加文件</li><li>-u 意为 update，更新压缩包中的文件</li></ul><p>注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如：</p><ul><li>-z 使用 gzip 属性</li><li>-j 使用 bz2 属性</li><li>-Z 使用 compress 属性</li><li>-v 意为 verbose，显示详细的操作过程</li><li>-O 将文件输出到标准输出</li></ul><p>然后最后一个一定要是 f 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 假设我们有很多 .md 文件需要打包，那么可以使用</span><br><span class="line">tar -cf posts.tar *.md # c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件</span><br><span class="line"># 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用</span><br><span class="line">tar -rf posts.tar *.txt # r 是追加文件</span><br><span class="line"># 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用</span><br><span class="line">tar -uf post.tar hello.md # u 是更新</span><br><span class="line"># 压缩好了，我们来看看压缩包的内容，可以使用</span><br><span class="line">tar -tf posts.tar # t 是列出文件内容</span><br><span class="line"># 把压缩包发送到其他位置之后，需要解压，可以使用</span><br><span class="line">tar -xf posts.tar # x 是解压</span><br></pre></td></tr></table></figure><p>加入自选参数后的用法（要不要加 v 可以看个人喜好）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># tar.gz 相关</span><br><span class="line">tar -czf posts.tar.gz *.md # 压缩</span><br><span class="line">tar -xzf posts.tar.gz # 解压</span><br><span class="line"># tar.bz2 相关</span><br><span class="line">tar -cjf posts.tar.bz2 *.md # 压缩</span><br><span class="line">tar -xjf posts.tar.bz2 # 解压</span><br><span class="line"># tar.Z 相关</span><br><span class="line">tar -cZf posts.tar.Z *.md # 压缩</span><br><span class="line">tar -xZf posts.tar.Z # 解压</span><br></pre></td></tr></table></figure><p>总结一波，遇到不同类型的文件，请用不同的套路来应对：</p><ul><li>*.tar -&gt; tar -xf</li><li>*.tar.gz -&gt; tar -xzf</li><li>*.tar.bz2 -&gt; tar -xjf</li><li>*.tar.Z -&gt; tar -xZf</li><li>*.gz -&gt; gzip -d</li><li>*.rar -&gt; unrar e</li><li>*.zip -&gt; unzip</li></ul><h2 id="空间占用-du"><a href="#空间占用-du" class="headerlink" title="空间占用 du"></a>空间占用 du</h2><p>很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前文件下 Top 10 空间占用的文件/目录，</span><br><span class="line"># s 表示不显示每个子目录或文件的大小</span><br><span class="line"># h 表示用更加自然的方式显示（比如 K/M/G 这样）</span><br><span class="line">du -sh * | sort -nr | head</span><br></pre></td></tr></table></figure><h2 id="系统状态-top"><a href="#系统状态-top" class="headerlink" title="系统状态 top"></a>系统状态 top</h2><p>了解系统状态一般少不了 top 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看某用户的进程</span><br><span class="line">top -u wdxtub</span><br><span class="line"># 进入系统状态显示后，具体值代表的意思是</span><br><span class="line"># PR    进程优先级，越小优先级越高</span><br><span class="line"># VIRT  占用的虚拟内存</span><br><span class="line"># RES   占用的物理内存</span><br><span class="line"># SHR   占用的共享内存</span><br><span class="line"># S     进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）</span><br><span class="line"># TIME+ 进程启动后占用的总 CPU 时间</span><br><span class="line"># 可以按照不同的指标排序显示，按对应键即可</span><br><span class="line"># P 按照 CPU 使用率排序</span><br><span class="line"># T 按照 MITE+ 排序</span><br><span class="line"># M 按内存使用占比排序</span><br></pre></td></tr></table></figure><p>其他查看进程相关信息的命令有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看进程内存分布</span><br><span class="line">pmap -d 12345 # 12345 是进程号</span><br><span class="line"># 按照内存排序，这里的 grep 可以过滤特定的用户</span><br><span class="line">ps -e -o &apos;pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid&apos; | grep wdxtub | sort nrk5</span><br></pre></td></tr></table></figure></p><h2 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 find"></a>查找 find</h2><p>在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 找出七天前的文件</span><br><span class="line">find / -type f -mtime +7 -print</span><br><span class="line"># / 表示从根目录中查找</span><br><span class="line"># -type f 表示找出系统普通文件，不包含目录</span><br><span class="line"># -mtime +n 表示寻找 n 天前的数据</span><br><span class="line"># -print 打印文件名称</span><br><span class="line"># 找出并删除七天前的文件</span><br><span class="line">find /temp/ -type f -mtime +7 -print -exec rm -f &#123;&#125; \;</span><br><span class="line"># -exec 表示后面执行系统命令</span><br><span class="line"># &#123;&#125; 只有该符号能跟在命令你后面</span><br><span class="line"># \; 结束符号</span><br><span class="line">find /temp/ -type f -mtime +7 -print | xargs rm -f</span><br><span class="line"># 使用管道和 xargs = -exec</span><br><span class="line"># 查找 /var 下最大的十个文件</span><br><span class="line">find /var -type f -ls | sort -k 7 -r -n | head</span><br><span class="line"># 查找 /var/log 下大于 5GB 的文件</span><br><span class="line">find /var/log/ -type f -size +5120M -exec ls -lh &#123;&#125; \;</span><br><span class="line"># 找出今天所有文件并将它们拷贝到另一个目录</span><br><span class="line">find /home/wdxtub/ -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="远程登录-ssh"><a href="#远程登录-ssh" class="headerlink" title="远程登录 ssh"></a>远程登录 ssh</h2><ul><li>ssh -vvv username@ip ssh 的 debug 模式</li><li>ssh -i key.pem username@ip 用 pem key 登录 ssh</li></ul><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>这里是一些比较零碎的命令行技巧</p><ul><li>openssl rand -hex n 产生随机的十六进制数，n 是字符数</li><li>source /path/to/filename 在当前 shell 里执行一个文件里的命令</li><li>${variable:0:5} 截取变量的前五个字符</li><li>wget -r –no-parent –reject “index.html*” <a href="http://hostname/" target="_blank" rel="noopener">http://hostname/</a> -P /home/user/dirs 用 wget 抓取完整的网站目录结构，存放到本地目录中</li><li>mkdir -p /home/wdxtub/{test0,test1,test2} 一次创建多个目录</li><li>dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img 测试硬盘写入速度</li><li>hdparm -Tt /dev/sda 测试硬盘读取速度</li><li>echo -n “test” | md5sum 获取文本的 md5</li><li>curl -I <a href="http://wdxtub.com" target="_blank" rel="noopener">http://wdxtub.com</a> 获取 HTTP 头信息</li><li>netstat -tln4 | awk ‘{print $4}’ | cut -f2 -d: | grep -o ‘[0-9]*’ 显示所有 tcp4 监听端口</li><li>time command 查看命令的运行时间</li><li>export 查看所有的环境变量</li><li>cmp file1 file2 文件内容对比</li><li>cat -n file 内容前面会显示行号</li><li>lsof -i:22 查看 22 端口现在运行的程序</li><li>lsof -c abc 显示 abc 进程现在打开的文件</li><li>lsof -p 12 看进程号为 12 的进程打开了哪些文件</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://wittyfans.com/2016/12/03/bzs-linux-concept-guide/">Linux概念指南——小土刀</a></li><li><a href="https://www.gitbook.com/book/wizardforcel/vbird-linux-basic-4e/details" target="_blank" rel="noopener">鸟哥的Linux私房菜</a></li><li><a href="http://yhhx.tech/2017/06/11/笔记/Arch-Linux安装记录/" target="_blank" rel="noopener">Arch-Linux安装记录/</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1507_caojh/index.html" target="_blank" rel="noopener">Linux防火墙firewalld</a></li><li><a href="https://www.jianshu.com/p/37735e3511c2" target="_blank" rel="noopener">Linux常用软件安装</a></li><li><a href="https://wizardforcel.gitbooks.io/network-basic/content/0.html" target="_blank" rel="noopener">网络基础功</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;鸟哥的Linux私房菜阅读笔记，截取了重要的概念与常用的命令。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="Linux" scheme="http://wittyfans.com/tags/Linux/"/>
    
      <category term="coding" scheme="http://wittyfans.com/tags/coding/"/>
    
      <category term="shell" scheme="http://wittyfans.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《别独自用餐》读书笔记</title>
    <link href="http://wittyfans.com/reading/%E3%80%8A%E5%88%AB%E7%8B%AC%E8%87%AA%E7%94%A8%E9%A4%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/reading/《别独自用餐》读书笔记.html</id>
    <published>2018-03-16T11:59:16.000Z</published>
    <updated>2018-03-16T12:05:06.837Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经济潮涨涨落，友谊天长地久。</p></blockquote><a id="more"></a><h1 id="第一部分-思想"><a href="#第一部分-思想" class="headerlink" title="第一部分 思想"></a>第一部分 思想</h1><h2 id="要有自己的圈子"><a href="#要有自己的圈子" class="headerlink" title="要有自己的圈子"></a>要有自己的圈子</h2><ul><li>一个人根本走不了多远！！！</li><li>互相关心，不要隔绝、猜忌</li><li>与人交流是重要的生存技能，人们只喜欢和他们了解与喜欢的人做生意</li><li>使别人成功，你失败的时候别人才会帮你</li><li>建立圈子不无聊，也不浪费时间，虽然有时候很耗费精力，但永远不会枯燥</li><li>每个人都能从你的成长中获益，每个人也会帮助你成长</li><li>正因为你创造价值，人们才渴望与你接触</li><li>关系，随后而来的机遇与支持，都有利于个人发展</li></ul><h2 id="慷慨待人"><a href="#慷慨待人" class="headerlink" title="慷慨待人"></a>慷慨待人</h2><ul><li>大家都很乐意接受别人的慷慨，但前提是你要主动走出去寻求别人的慷慨</li><li>某些微不足道的事情可能改变别人的命运</li><li>别人通常会拒绝你的好意，他们会说：“不好意思，我不能接受你的好意”，或则说，我不想欠别人人情。</li><li>如果你不能以同样的热情将自己的圈子推荐给别人，你就不可能扩大自己的圈子，你帮助的人越多，你得到的帮助也越多，然后你才能帮助更多的人。</li><li>工业时代，竞争力是靠改进生产关系，如今则是靠提高关系质量</li><li><strong>关系或者说信息，是有寿命的</strong>，他们可能随时出现也可能随时灭亡，要求人与人的完美合作，要求共同创新，相互沟通，这样才能管理好关系，顺利完成工作。</li><li>我们需要别人的帮助，这不是情感的倾诉，而是一门科学</li><li>健康快乐的秘诀是什么？自然是与健康、快乐的人做朋友啊</li><li>性格独立，却不会以相互依赖、互惠互利的角度思考问题，这种人可能是一个优秀的独立生产者，却不是一个好领导，好组员，过不了多久，他们便会在职业道路上栽跟头。</li><li>正是对社交关系的利用，才会增加社交资产的价值。</li><li>需要深知把朋友介绍给朋友，把校友介绍给校友的巨大价值。</li><li>真诚的交流不在于贪婪，而在于慷慨</li><li>经济潮涨涨落，友谊天长地久</li><li>不用考虑究竟是他们的还是自己的午餐，也不用记录人情往来，没有谁会在乎</li><li>当你下面的人愿意助你前进，而不是一心盼你落马时，你的路会很走好多</li><li>每个人都是自己的品牌，现在公司都利用品牌与顾客建立强大而持久的联系</li></ul><h2 id="找到自己的使命"><a href="#找到自己的使命" class="headerlink" title="找到自己的使命"></a>找到自己的使命</h2><p><em>要让制定目标成为一种习惯，成为生命的一部分</em></p><h3 id="第一步，找到自己的激情"><a href="#第一步，找到自己的激情" class="headerlink" title="第一步，找到自己的激情"></a>第一步，找到自己的激情</h3><p>想想你擅长的领域是什么？你想得到的又是什么？阻碍你前进的困难又是什么？一般人只知道自己应该做什么，而不先花时间想清楚自己想做什么。</p><p><strong>列出以下的事情</strong></p><ul><li>成就</li><li>令人感动过的人和事</li><li>自己喜欢的杂志，电影，书籍</li><li>那些让你兴奋，让你忘记时间流逝的东西</li></ul><p><strong>放弃眼界</strong><br>问你熟悉的人</p><ul><li>你最大的优点是什么？</li><li>缺点是什么？</li><li>他们在哪些方面特别佩服你？</li><li>你在哪些方面还需要别人的帮助以提高</li></ul><p><strong>制定目标，更新目标，以及观察自身这些都不是最重要的。重要的是，你需要在情感上发现和认可自己想要的东西</strong></p><h3 id="将目标写下来"><a href="#将目标写下来" class="headerlink" title="将目标写下来"></a>将目标写下来</h3><p>首先你需要写下你的目标，其次需要具备相关的技能、工具、物质资源；再次需要时间、思考、决心、毅力以及信念。<br>一个简单的计划：</p><ol><li>制定计划</li><li>列出人、事、物</li><li>最佳方案</li></ol><p>这意味着，你需要接近那些有助于达成目标的人，这意味着你需要慷慨待人。</p><p><strong>步骤</strong></p><ul><li>第一部分：列出三年后的目标</li><li>第二部分：列出三个月，以及一年的中短期目标<br><em>每个阶段制定两个计划</em></li></ul><p><strong>要求</strong></p><ul><li>目标必须是具体的</li><li>实际可信的</li><li>要有挑战性，有难度</li></ul><p>有些人需要你主动接近，有些人则需要朋友穿针引线来介绍，发展人际网需要有一定的流程和体系，有了计划，把它贴在你看得到的地方，这大有裨益。</p><h3 id="创立个人“智囊团”"><a href="#创立个人“智囊团”" class="headerlink" title="创立个人“智囊团”"></a>创立个人“智囊团”</h3><p>找到那些可以给你提供帮助与鼓励的人，真诚、慷慨的接近他们。</p><h2 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h2><ul><li>一些人一旦失业才开始拿别人的名片，人脉广的人则在不需要有求别人的时候就开始走访别人。</li><li>不是需要非得明天就去换一个新工作，如果你向往什么环境，那就努力进去那个环境</li><li>圈子不可能一天建起来，关系也只能一点一滴，一天天的赢得别人的信任。</li></ul><p>具体的建议：</p><ol><li>找一个大家认同的事情去做，不仅可以学到新技能，还能和公司同事有所接触</li><li>参与某项你感兴趣的业余活动或其他组织，成为领头羊</li><li>加入当地的校友会，未来想投身那个行业，就和那个行业的校友交流</li><li>参加社区大学，学习和目前工作相关的学科 </li></ol><h2 id="初生牛犊不怕虎"><a href="#初生牛犊不怕虎" class="headerlink" title="初生牛犊不怕虎"></a>初生牛犊不怕虎</h2><ul><li>要办好一件事情，不仅要有自信，还要有毅力和勇气。</li></ul><p><strong>如何在社交场合不恐惧？</strong></p><ol><li>寻找一个榜样</li><li>学会说话</li><li>接受心理治疗</li><li>付诸行动</li></ol><p><strong>设立一个目标，每周见一个陌生人</strong></p><ul><li>在公车上向别人介绍自己</li><li>在酒吧坐到陌生人旁边跟他打招呼</li><li>邀请从未见面的人跟他打招呼</li><li>跟公司没说得上话的人聊天</li></ul><p><strong>与陌生人交流的箴言：</strong></p><ul><li>冷静的，直接的告诉别人你自己的想法，无需满面怒气，无需夸大其词</li><li>表达感情</li><li>表达目的，必须明确的告诉别人你的真实目的是什么</li></ul><h2 id="社交傻瓜"><a href="#社交傻瓜" class="headerlink" title="社交傻瓜"></a>社交傻瓜</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>拿着名片，那种蜻蜓点水似的社交，是无用的，忽略了社交的本质是真诚。</li><li>毫不掩饰自己的野心，只和上级结交，忽视同级，面对上级是一张脸，面对又是另一张脸。</li><li>面对下级，要把他们当作必须争取的合作伙伴，鼓励他们同心协力实现目标，而不是随意差遣，帮你完成目标的下属。</li></ul><h3 id="避免成为社交傻瓜"><a href="#避免成为社交傻瓜" class="headerlink" title="避免成为社交傻瓜"></a>避免成为社交傻瓜</h3><ol><li>不要闲谈，有话就充满激情的把它说出来，言之有物，感情真挚。如果你蜻蜓点水，老是寻找下一个交流对象，你很快就会失去人们读你的尊重。</li><li>不要过度依赖八卦。跟人聊八卦很简单，因为八卦是大家都喜闻乐见的东西，但一直这样会让人感到厌烦并失去对你的信任。</li><li>别空着手去聚会。与人交往，种瓜得瓜，种豆得豆。</li><li>不要捧高踩低。在商界，富贵荣华转瞬即逝，所有人，无论是谁，你都需要尊重他们。</li><li>坦率做人。</li><li>不要太追求数量。</li></ol><p><em>与人为友的真理，正因为他们对任何人都那么友善和和蔼，大家才会尊重他们，信赖他们</em></p><h1 id="第二部分-技巧"><a href="#第二部分-技巧" class="headerlink" title="第二部分 技巧"></a>第二部分 技巧</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>即使你不是个天才，提前准备也会让你看起来像个天才</li><li>见你认识的人之前，搞清楚他们的职业、关心、目标，搞一张纸记录下来他们的本质，原则，有什么让他值得自豪的成就</li><li>建立深层次的联系，可以聊一聊公司的新鲜事，上季度的成绩，公司的新产品，人们通常都喜欢聊他们的工作，如果你聊一些内行的话题，他们肯定对你产生好感。</li><li>人最深层的本性就是受人欣赏</li><li>有伟大的准备，才有伟大的成就</li><li>了解一个人，不可避免的就要了解他遇到的问题，和他的需求。</li><li>不要和人们泛泛相处，你需要深入和他们接触，先融入他们喜欢的事情，然后就能慢慢走近他们的生活</li><li>你应该把一次容易忘记的邂逅发展成一段长盛不衰的友谊。<h2 id="记下名字"><a href="#记下名字" class="headerlink" title="记下名字"></a>记下名字</h2></li><li>树立一个目标，同时记录下哪些人是可以联系的，随身带着它会给予你一股与外界联系的力量</li><li>树立一个联系人清单，清单里的人可以不必是你已经认识的。</li></ul><h2 id="学会打冷电话"><a href="#学会打冷电话" class="headerlink" title="学会打冷电话"></a>学会打冷电话</h2><ul><li>冷电话就是给陌生人打电话，冷电话的诀窍在于单刀直入</li><li>把认识新朋友看作一种挑战和机遇，这种想法能激发你的竞争潜力。</li></ul><h3 id="法则"><a href="#法则" class="headerlink" title="法则"></a>法则</h3><ol><li>寻找他人推荐</li><li>表明你的价值</li><li>说话少一些，对话多一些；表达简洁、清晰、干脆，不要照本宣科，即便15秒的介绍也请让对方有说“嗯”的机会</li><li>主动提出妥协的方案</li></ol><h2 id="巧妙与接待员相处"><a href="#巧妙与接待员相处" class="headerlink" title="巧妙与接待员相处"></a>巧妙与接待员相处</h2><ul><li>与大人物联系，他们通常都会有许多无效邮箱和电话，这时候可以选择和他们的助理做朋友，而不是敌人</li><li>不要把秘书他们看作普通的秘书或者是助理，事实上他们是联系人，是生命线，应该给他们尊重。</li></ul><h2 id="别独自用餐"><a href="#别独自用餐" class="headerlink" title="别独自用餐"></a>别独自用餐</h2><ul><li>没有存在感比失败更糟糕，也就是说你要时刻与别人接触，早餐时间晚餐时间，随便什么时候</li><li>建立人际关系网的时候，最重要一点，绝对不要玩消失。</li><li>将你的社交活动，会议、甚至是日程都安排满。</li><li>要想前途坦荡，你必须努力工作，时常在你刚刚建立的人际网中确立存在感，积极活跃。</li><li>一位成功的CEO每天至少会跟50人聊天，跟来来往往的员工交流。</li><li>建立同事或者是朋友圈应该是一种乐趣，而不是消磨时间。</li><li>你的目标也设立好了，你就会发现每天都有足够的时间来做需要完成的事情。</li><li>社交圈是肌肉，你越努力，他越强壮。</li></ul><h2 id="分享你的激情"><a href="#分享你的激情" class="headerlink" title="分享你的激情"></a>分享你的激情</h2><ul><li>与人会面不仅仅是你要了解谁的问题，还有你怎样了解，以及在哪里了解的问题</li><li>有更管用的方法，更适合的地方来消磨你的时间。</li><li>分享利益信息是建立在任何一座关系大楼的基石，种族、宗教、性取向、或商业、专业以及个人爱好都与关系这座大楼密切相关。</li><li>友谊的产生在于两人相处的时间的质量，而不在于时间的长短。</li><li>帮助他人并与他人建立关系真的是一件非常特别的事情。</li><li>当你真正去热爱一件事的时候，这种热爱是会传染的，我们的激情让别人好奇我们是谁，我们关心什么，在你的热情的感染下，其他人会放下防备，这也就是为什么在生意场上，分享你的激情多么重要。</li><li>用你的爱好去联系新朋友，维系老朋友，你做什么没关系，只要是你真正热爱的就行。</li></ul><p>例举一些例子：</p><ol><li>15分钟加一杯咖啡</li><li>邀请对方分享爱好或者锻炼方法</li><li>简单快速的和对方吃一次早餐</li><li>邀请对方参加一项特别的节目，美好夜晚、签书会、演唱会</li><li>在家招待客人</li><li>当志愿者</li></ol><h2 id="要么跟进、要么失败"><a href="#要么跟进、要么失败" class="headerlink" title="要么跟进、要么失败"></a>要么跟进、要么失败</h2><ul><li>要及时的跟进刚建立的社交关系</li></ul><h2 id="成为会议的突击先锋"><a href="#成为会议的突击先锋" class="headerlink" title="成为会议的突击先锋"></a>成为会议的突击先锋</h2><ul><li>会议的一个意义在于提供了一个结识志趣相投的人的机会</li><li>再无懈可击的幻灯片演示也敌不上与顾客发展出的真情与信任。</li><li>会议中有两种人：一种像保龄球中的圆球，另一种人则像其中的木瓶。</li><li>如果你是圆球，你就会游走在会场中，与其他人打成一片。刚入场，你的自信和诚恳就会给大家留下一个积极的印象，进而可以完成日程表的每条名目。若你是木瓶，那只能安稳地待在那里，等着别人去找你</li></ul><h2 id="游击战术"><a href="#游击战术" class="headerlink" title="游击战术"></a>游击战术</h2><ul><li>没有理由你不能主宰自己的私人活动</li><li>私人会议上，不要只顾着介绍自己，还要把遇到的人介绍给别人</li><li><strong>以重要人物为核心：如果你认识会议中最受欢迎的人，而这个人正好也认识每个人，那么他在跟会议中的别的人交谈的时候，你一定要跟着他</strong></li><li>会议参加指南：<ul><li>查看参加会议的人的清单；</li><li>提前到达现场；</li><li>站在靠近主会场入口的地方；</li><li>随时准备好自我介绍，等待见面的时机；</li></ul></li></ul><h2 id="成为消息通"><a href="#成为消息通" class="headerlink" title="成为消息通"></a>成为消息通</h2><ul><li>如果你有机会和新朋友见面，请把自己打造成“消息通”，这是任何一个社交高手都会具备的重要素质。</li><li>记住你周围的朋友都乐于知晓什么消息，并做好准备。</li></ul><h2 id="成为通讯员"><a href="#成为通讯员" class="headerlink" title="成为通讯员"></a>成为通讯员</h2><ul><li>可以记录下活动的照片，合照，回去以后马上发给所有人</li><li>不要等过了一两周才去做这件事情，趁对方记忆犹新的时候发给他们</li></ul><h2 id="掌握深度攀谈"><a href="#掌握深度攀谈" class="headerlink" title="掌握深度攀谈"></a>掌握深度攀谈</h2><ul><li>完美的偶遇，即让对方觉得很高效的同时又很有意义，即深度攀谈。</li><li>讲究迅速取得联系，确保可以进行下一次会议。</li><li>在有限的时间里，认识很多的人，这并不是要跟他们成为亲密好友，而是要跟他们保持一定的联系，确保可以进行后续跟进</li><li>一旦建立了联系，就需要进行一定程度的亲密感，讲话看着对方的眼睛，倾听他们讲话看着他们的鼻子，可以展示一些自己的弱点。</li></ul><p><strong>技巧：</strong></p><ul><li>双手迎接客人，握住别人的臂膀或者肩膀</li><li>直视对方，短暂的相遇，问一两个私人问题</li><li>克灵顿先生从来没跟别人随意交谈请求别人投一票给他，他的问题都是围绕着对方的想法以及困难。</li><li>当进入一个房间，走向右边，环视一下房间，然后看看屋里有谁，要让其他人看到你，注意依着干练。</li><li>做好后续跟进，跟进后再跟进，然后，做完之后，再跟进一遍</li><li>不要让事情拖拖拉拉，也不要让事情善始却不善终</li></ul><p><strong>避免</strong></p><ul><li>握手无力，参加活动站在墙角</li><li>整个活动紧随好朋友的步伐</li><li>即便只有三十秒，也要让这段时间充满温暖和真诚，没有什么比这个更重要</li></ul><h2 id="与引荐人保持联系"><a href="#与引荐人保持联系" class="headerlink" title="与引荐人保持联系"></a>与引荐人保持联系</h2><ul><li>理解弱连接的力量，大部分你得到的帮助，其实都只是萍水相逢的人而已</li><li>混脸熟代表着一种社交力量的来源，而且你认识的熟人越多，你的力量越强大</li><li>重要的是建立紧密的信任关系，而不是肤浅的表面关系，友谊才是建立真正强大的社交网络的基础</li></ul><p><strong>典型的集中引荐人：</strong></p><ul><li>餐厅老板，聪明的老板会主动跟食客讲话，让你有个愉快的经历，你需要做的就是走出门，常去餐厅坐坐，你可以到一个地方让人推荐一些餐馆，找一些环境还不错的，请求跟老板聊聊天，告诉他们你会常去餐厅，当你有什么活动的时候，记得把其他人带到这里，一旦你认识了餐厅老板，便会觉得这就是你自己的餐厅，在这个地方你可以体验贵宾专享，加入自己的“私人俱乐部”，感受家才能带给你的温暖和舒适。可以像老板提出一些建设性的意见，表现一点忠诚，他不但会给你优惠，还会专门将你介绍给其他客人</li><li>猎头，认识一些猎头，他们的电话都积极回复，你有需要的时候，他们也会帮你认识一些客户</li><li>说客，他们消息灵通、说服力强、充满自信</li><li>募捐者，跟着钱走是他们的生存之道。他们知道哪里有钱，怎么得到以及最重要的一点——谁最愿意捐钱。如果你认识募捐者，你就打开了一扇通往新世界的大门，在里面你可以遇到新朋友和新机遇。</li><li>公关人员，公关人员可以帮你进入媒体，有时甚至是名人的世界。</li><li>记者，常跟他们联系，请他们吃饭，交流有益的点子</li><li>作家，每个人都可以有写作空间，成为你的引荐人</li></ul><p><strong>认识所有人的秘诀</strong></p><ul><li>如果你搬到一个地方，你想认识所有人，是挨家挨户的敲门，还是去认识那个人缘最好的呢？</li></ul><h2 id="拓宽你的社交圈"><a href="#拓宽你的社交圈" class="headerlink" title="拓宽你的社交圈"></a>拓宽你的社交圈</h2><ul><li>邀请刚认识的人参加聚会，不要忘记邀请让你们认识的那个人</li><li>共享的朋友数量必须均衡</li><li>不要将你的全部联系人都给别人，要注意他们哪些人有兴趣跟别人接触，以及如何介绍他们，仔细的想想如何利用对方的社交圈。</li></ul><h2 id="聊天的艺术"><a href="#聊天的艺术" class="headerlink" title="聊天的艺术"></a>聊天的艺术</h2><ul><li>魅力与闲聊的天赋并非与身俱来，但那又怎样？没几个人时天生的</li><li>对于不善闲聊的人来说，明明是结识新朋友的机会，他们却觉得尴尬和沉重</li><li>记住，微信、QQ、电子邮件这不是逃离与他人交往的安全舱口</li><li>网络即时聊天讲究速度，或许能让你高效的交流，但在交朋友方面就不凑效了</li><li>语言是我们交换想法，最直接最有效的方法</li><li><strong>成功的人的一大特征之一就是言语流畅，能自信的交流，面对投资商、顾客、还有老板就像面对同事、秘书、和朋友一样，他们没有任何恐惧感，面对听众，在餐桌旁或者是出租车中，这些人都知道如何闲聊。</strong></li></ul><p>那么闲聊的目标是什么？</p><ul><li>开始对话</li><li>保持对话</li><li>建立关系</li><li>给对方留下思考的空间</li></ul><p>闲聊就是要给对方一种印象，要有自己的特点，也就是做真实的自己。</p><h2 id="华丽的退出"><a href="#华丽的退出" class="headerlink" title="华丽的退出"></a>华丽的退出</h2><ul><li>你是如何结束对话的呢？干脆的结束对话是一个不错的选择</li><li>比如可以说去拿一杯饮料，你有想喝的吗？如果他说没有，你就没有义务再回来了，如果他说有，你可以在回来的路上去开始另一段聊天，再当你回来的时候，你可以说，我刚巧碰到几个人，你也应该认识认识，快去！</li></ul><h2 id="期待下次见面"><a href="#期待下次见面" class="headerlink" title="期待下次见面"></a>期待下次见面</h2><ul><li>为了保持继续联系，聊天结束时，需要像对方发出下次联系的邀请，毫不吝啬的对对方的赞美之词，即便不是为了生意，比如：“看来您对红酒蛮有研究，我们可以带上一瓶自己的红酒，找个时间好好聊聊”</li></ul><h2 id="学会倾听"><a href="#学会倾听" class="headerlink" title="学会倾听"></a>学会倾听</h2><ul><li>人性最深处的准则就是希望得到别人的赏识。</li><li>我们应该这样思考：“首先去理解对方，然后再请对方理解你”</li><li><strong>我们总是担心接下来要说什么话，于是忽略了对方跟我们的谈话</strong></li><li>没什么比对方听到自己的名字更开心的事了</li></ul><h2 id="好好聊天"><a href="#好好聊天" class="headerlink" title="好好聊天"></a>好好聊天</h2><ul><li>想让你的聊天更有亲和力且具有可读性，你可以大声的读出来，发送之前尽量避免排除掉输入的错误</li><li>邮件的末尾用心的附上暖心的结束语</li></ul><h1 id="把交情由浅变深"><a href="#把交情由浅变深" class="headerlink" title="把交情由浅变深"></a>把交情由浅变深</h1><h2 id="健康、财富和孩子"><a href="#健康、财富和孩子" class="headerlink" title="健康、财富和孩子"></a>健康、财富和孩子</h2><ul><li>第一次遇到朋友，可以尝试归结他们，一般有三种：赚钱、寻找真爱、改变世界</li><li>让别人把事情做好的唯一途径在于承认他们的重要性，并让他们感受到自己很重要。</li><li>帮别人实现最大的愿望可以的带来很多好处，不仅能形成彼此特定的关系，还能让这种关系稳定发展，越来越牢固。</li><li>世界上有三种东西能让人们友情变得深厚，它们是健康、财富、和孩子。</li><li>我们能给别人做很多事情，但是健康、财富和孩子对我们的众多影响是其他的友善行动达不到的。</li><li>你帮助别人解决了健康问题，让他们的身体更加健康，或者真切的关心他们的孩子，你就在培养持续一生的忠信。</li><li>在焦急时刻，消除疑虑的专家比得过世界上所有的财富。</li><li>人们的孩子就是他们的一切。</li><li>如果你将要解决对别人至关重要的问题，请一定认真对待</li><li>你的朋友会把你的情况跟别人说，所以请务必说到做到</li></ul><h2 id="社会关系套利"><a href="#社会关系套利" class="headerlink" title="社会关系套利"></a>社会关系套利</h2><ul><li>别在逼自己思考如何才能让自己成功了，想想如何让自己身边的人成功</li><li>不要等着别人请你帮忙，直接帮吧</li><li>真正的权力来自对别人不可缺少的那份必需。成为电话接线员就具有必需性，把信息、联系和善意尽可能多地传递给不同领域的人。</li><li>如果你想交朋友、解决问题，你就得为别人的事行动起来，而这些事情是需要时间、精力和考量的。</li><li>在不同领域，甚至同一职业的不同人之间牵线搭桥，是管理人员的关键素质，这样的人薪水更多、升迁更快</li><li>没人想要认识你、而知识是自由的，书籍、文章、网络上面都有，随处都可以发现很多，而且对谁都很珍贵，应该以此为突破口</li><li><strong>在两个月时间里对他人的成功表现出极大兴趣，与用两年时间让别人对你自己的成功感兴趣相比，前者会让你更成功。</strong></li></ul><h2 id="丁零零——不断联系"><a href="#丁零零——不断联系" class="headerlink" title="丁零零——不断联系"></a>丁零零——不断联系</h2><ul><li>80%的成功都是自然而然出现的；那也可以说，80%的社交活动就是保持交流联系。</li><li>为了关系保持发展，至少一个月用电话或者邮件交流一次。</li><li>认识的人变成朋友，至少要与对方单独见面两次。保持二等关系需要每年问候两三次</li><li>在保持人际关系这件事情上，你要一年365天，一周7天，一天24小时，时时刻刻留心</li><li>没有计划就等同于计划失败。而计划就包含在列有活动和姓名的清单里。</li></ul><h2 id="自动回复社交媒体"><a href="#自动回复社交媒体" class="headerlink" title="自动回复社交媒体"></a>自动回复社交媒体</h2><ul><li>如果你总是与同样的人聚餐，你的社会关系永远得不到发展</li><li>邀请一个压轴主宾，他认识不同的人，经历过不一样的事情，有很多值得交流借鉴的东西。</li><li>考虑一下记者，他们薪资不算高（所以喜欢免费的餐点），这个职业涉及很多不为人知的事情；他们总是在仔细搜寻好的新闻素材，把这样的聚会当作激发灵感的好时机；他们很多都擅长说话，喜欢把自己的想法说给别人听，抓住机会让别人传播出去。</li><li>艺术家和演员，无论是否出名，也属于这一类人。如果请不到你喜欢的“贵客”，可以试试邀请权力人士身边的人</li></ul><h1 id="数字时代的联系"><a href="#数字时代的联系" class="headerlink" title="数字时代的联系"></a>数字时代的联系</h1><ul><li>如何在数字时代中让自己不被淹没在信息的洪流之中？</li><li>互联网中，交易信息比储藏信息更有意义，有价值的信息源源不断地涌现，而且免费。学会了挖掘信息流的价值，你就对打开了那扇合适的门拥有了特权。</li><li>怎样建设、经营社会关系地图上面偏远的疆域呢？就是由比较微弱的朋友关系构成的社交边缘，但这些关系之中蕴含着大量创新和价值。</li><li>有意识地塑造起来的关系网，决定了你得到的信息将具有哪方面的价值</li></ul><h2 id="如何管理虚拟空间？"><a href="#如何管理虚拟空间？" class="headerlink" title="如何管理虚拟空间？"></a>如何管理虚拟空间？</h2><ul><li>网络上的人际关系很容易批量管理，而亲密的关系却总需要一对一单独地培养</li><li>我们需要一套管理、过滤人际关系的结构，以及分辨信息和噪音的习惯</li><li>高智商的群体可能更聪明，但是在衡量集体智慧的时候，多样性比单个人的脑力更加重要——《未来的美好》（Future perfect）</li><li>你之所见决定了你怎样改变，目光聚焦之处决定了你的见识，（眼界容易受制于欲望）</li></ul><h2 id="如何分别有价值的信息"><a href="#如何分别有价值的信息" class="headerlink" title="如何分别有价值的信息"></a>如何分别有价值的信息</h2><ul><li>迅速审查信息，你的朋友在背景、职业、地理位置、年龄、种族方面有没有多样性？如果没有就从边缘社交中选一些作为重要朋友</li><li>对社交网络上的朋友仔细分类，每周安排固定的时间查看名单，看看这些人和哪些事情有联系，分享了什么信息，然后扩充你的名单</li></ul><h2 id="线下活动过滤网络"><a href="#线下活动过滤网络" class="headerlink" title="线下活动过滤网络"></a>线下活动过滤网络</h2><ul><li>扩大网络社交圈时，最重要的筛选工作是通过现实世界，比如参加会议、聚会</li><li>可以通过一次和许多人交流一个小时来验证人们的信息</li><li>要擅长发现，人们会向你提供什么样的信息，为什么样的公司工作，对什么事情有激情，对生活中扮演了什么样的角色</li><li>线下活动用来建立最初的联系，线上互动则用于维持联络</li><li>即便是边缘社交大师，他和最好的朋友也会每三周聚一次，喝啤酒聊天</li><li>白手起家的时候，忘掉那些大人物，建立联盟，很有可能五年之后，你们都能很好的帮助对方</li><li>打开数据网络后，你应该确保这段时间能让你离实现目标更进一步</li><li>无论是顾客，同时，或者朋友，你最好利用这段时间与他们交流</li></ul><h2 id="成为内容之王"><a href="#成为内容之王" class="headerlink" title="成为内容之王"></a>成为内容之王</h2><ul><li>在网络上，找到一种方式，让你在网络世界里把自己的性情展现出来，做好了这一点，你就能与他们拉进距离，建立联系。</li><li>信任的计算：包容度+脆弱性+责任心+公正度=信任</li><li>恐惧会让你避免暴露自己，从而不会慷慨的付出，直率的表达，展现责任心，直接面对一个人，或者是为对方全力奉献自己</li></ul><h2 id="什么样的内容？"><a href="#什么样的内容？" class="headerlink" title="什么样的内容？"></a>什么样的内容？</h2><ul><li>愿意包容，即愿意付出、接受，大度总能让一个人从冷漠转向兴趣盎然</li><li>开始谈话前已加入其中，把对事物的热情分享给别人</li><li>用有分量的语言说话，不要弄的没一点吸引力</li></ul><h2 id="分享什么？"><a href="#分享什么？" class="headerlink" title="分享什么？"></a>分享什么？</h2><ul><li>应该是那些又价值的信息，别人可以参与的信息</li><li>不要无用信息，例如你朋友圈分享你在做什么，你的老板怎么样，不如你分享你现在在看电影，同时给出电影的链接</li></ul><h2 id="脆弱性"><a href="#脆弱性" class="headerlink" title="脆弱性"></a>脆弱性</h2><ul><li>敢于表现自己的脆弱是很难的事情，这样想，在市场竞争中，你最不希望的就是被别人替代，而什么是不可替代，成为独特的你，唯一的办法就是冒险展现真实的你。</li><li>可以不必把家人和工作分开的太多，你的家人也愿意听你工作中发生的事情</li><li>坦诚你犯错，别人就会相信你没有隐瞒什么</li><li>巨大的成功需要经历一次又一次失败，直到成功，直到取到最终的成功。</li><li>责任心不只要求我们信守诚信，也要求我们督促他人也这样做，要求我们大胆无畏，面对批评或者恐惧仍然坚持初衷</li><li>制定一份计划表，列出你要发表哪方面的内容，以及发表的时间，很快你就会发现规划自己的精力更容易让自己具有责任心，促使自己按计划在社交媒体上与朋友保持联系</li><li>每周、每月或者每季度写几段文字记录新情况；把周五定为聚会时间，把自己喜欢的朋友约出来</li><li>虚拟世界很适合我们去探索，实验甚至是实现抱负</li><li>新业务、新渠道或者新顾问不代表新价值</li><li>世界上有两种人，找借口的人喝解决问题的人</li><li>犯错之后，应该勇敢承担，寻求帮助，然后一步一步纠正</li><li>我们只有实话实说，并养成这样的习惯，才能做到真正的坦率，在情况紧急的时候，你的坦率可能会起到至关重要的作用</li></ul><h2 id="创造机遇"><a href="#创造机遇" class="headerlink" title="创造机遇"></a>创造机遇</h2><ul><li>有人说机会是留给有准备的人，不过现在机会却偏爱有人脉的人</li><li>意外往往是意味着新的发现即将诞生</li></ul><p>如何促使机遇发生在自己身上呢？</p><ol><li>为迎接各种机会而随时准备着</li><li>社交范围广，为机会创造机会</li><li>扎根于硅谷中心地带</li><li>做好协会领导人，积极参与慈善活动</li></ol><p>但是又有一个问题，在当今信息过载的社会，你知道什么已经不重要了，重要的是你能否在短时间内获取到真正有用的信息。<br>你得思考：</p><ul><li>怎样才能与那些没有交集的聪明人创造交集，这样会不会给我带来好处？</li><li>如果你能充分利用社交网络，不遗余力的建立自己的社交圈，你的圈子就会越来越大，你会时不时的收到好友申请，尽管你不认识他们</li><li>不能只关注虚拟世界，你所处的地理位置同样重要，看一看硅谷吧，那里的房租高的吓人，但人们仍然愿意住过去，就是为了靠近自己的伙伴</li></ul><p>偶遇还有另一种方式：</p><ul><li>让你的圈子更加多元化，比如旅行，但是人们并没有那么多的机会，大家都每天去的地方也就那么几个，所以你必须尽心建立并维护自己的圈子</li><li>搬到大城市后，你能接触到更多不同的人，他们不一定是你的朋友，但他们可以给你带来不同的想法，提供各种机会，或者通过他们你可以认识到更多可以帮助你的人</li><li>在另一个城市或是另一个国家生活的时间都可以看作是对事业的投资</li><li>参加会议是创造机遇再好不过的途径，因为形形色色的人聚集在一起，他们都是带着同样的目的，创造机遇、结识朋友、学习新东西</li></ul><h2 id="热情是创造可能的强大引擎"><a href="#热情是创造可能的强大引擎" class="headerlink" title="热情是创造可能的强大引擎"></a>热情是创造可能的强大引擎</h2><ul><li>热情代表着精力与活力，有了热情就更容易与人交流</li><li>热情是行动的催化剂，你可以想到就去做，不管是开始写博客，还是创建自己的公司，总会有人感兴趣</li><li>注意不一定要很完美，重点是让别人参与进来</li><li>你永远不知道别人有什么样的问题或者回答，而他们的想法往往能让你走的更远</li><li>如果你是一个缺乏激情的人，那么就得有新意</li></ul><h2 id="积极形态"><a href="#积极形态" class="headerlink" title="积极形态"></a>积极形态</h2><ul><li>想做大事的人都有有个计划，但也要给计划留点空白</li><li>86%的幸运儿在于他们乐于接受新事物，新朋友</li><li>有些人收集艺术作品，而我收集人脉与关系</li></ul><h1 id="付出就有回报"><a href="#付出就有回报" class="headerlink" title="付出就有回报"></a>付出就有回报</h1><h2 id="做个有趣的人"><a href="#做个有趣的人" class="headerlink" title="做个有趣的人"></a>做个有趣的人</h2><ul><li>你得让人觉得跟你交谈是一件值得的事儿，甚至愿意花时间谈论你</li><li>怎么衡量，比如如果你们困在同一个地方，你是否愿意和他待在一起几个小时</li><li>大家都知道你”——这只不过证明你是个名人，但是“大家因为你的某些独特之处而记住你”则大大不同。后者代表着尊重。首先你自己要有信仰——像乔尔一样，这样别人才会信任你。</li><li>对于商业来讲，有时候创新只不过是把每个人都知道的信息点整合起来，串点成线而已。你不需要再发明一遍轮子，你只需要换个车厢。</li><li>如果你想的只是减小风险，按照别人的需求做事，只做你的分内事，那么你就无法建立起自己的品牌。</li><li>个人信息是你目标以及内涵的衍生物。坐下来好好想想，你想成为什么样的人，写下你九十天、一年、三年的目标，然后以此为标准建构自己的个人品牌</li><li>如果你要隐藏自己的成就，那么没人能发现它们。如果你自己都不推广自己，没人能帮你推广</li><li>不管你喜不喜欢，你的成功不仅建立在你的工作成果上，也建立在别人是否知道你的工作成果上</li></ul><h2 id="接近权威"><a href="#接近权威" class="headerlink" title="接近权威"></a>接近权威</h2><ul><li>狮子可以在任何时刻用他的捕猎技能轻松地抓到一只田鼠，但当一天结束时，无论他逮到了多少田鼠，他都会挨饿。有时，无论有多大风险，要付出多少努力，都值得花时间去抓羚羊。那么，你只是与“田鼠”有联系吗？如果是，那么开始注意接触那些能改变你和其他人生活的重要的人。这些人能给你和你的关系网增光添彩</li><li>想受到我们生活中强大的人的影响并没有错，这反而是个很大的帮助。再说一次，无论你的目标或任务是什么，你一个人都很难独自完成。我们需要他人的帮助。</li><li>成功的人往往知道如何在地位高的人身边使他们感觉良好。另外，这些人能施加一些小魔法。无论是真实的还是想象的，这些人有某种特性，暂且称为人格魅力，他们能放大一个时刻，使平淡无奇的晚宴变得十分华丽。</li><li>意识到名人对关系网的影响，我也肯定不会因为要见到他们而害羞，过多的紧张和崇拜能扼杀掉你为接触他们所做的一切努力，别忘了，他们也是人。</li><li>有名望和权势的人首先也是人：他们骄傲、悲观，没有安全感，同时充满希望。无论能力如何，如果你能帮助他们实现目标，他们会感激你</li></ul><h2 id="建立组织，朋友自会来"><a href="#建立组织，朋友自会来" class="headerlink" title="建立组织，朋友自会来"></a>建立组织，朋友自会来</h2><ul><li>初到芝加哥，我一个人也不认识，所以我做的第一件事就是让我的朋友为我介绍他们在芝加哥的好友。待我见到朋友介绍的人之后，便向他们询问我可以加入当地的哪些会所，让我能够更加融入当地生活。我知道，这样做无疑会对我新公司日后的业务有所助益。</li><li>著名社交案例 本杰明·富兰克林：不能加入俱乐部？那就自己建一个</li></ul><h2 id="切勿自持"><a href="#切勿自持" class="headerlink" title="切勿自持"></a>切勿自持</h2><ul><li>有所为与有所不为，千万不要让这点虚荣心影响到你的行动，也不能因此自恃或滋生优越感。你需要时刻警醒，不要一成为社交好手，就忘了自己起初的定位和价值观。</li><li>并不是说把事情完成就行了，而是要让身边的人都能有一种参与感，让他们觉得他们不仅参与了过程，而且也是领导阶层的一部分</li><li>傲慢是一种病，它会让你忘记真正的朋友，忘记这些朋友有多么重要。即使用意有多么好，太过傲慢也会招致他人的愤怒，会让他们有一种冲动，想要将你打回原形</li></ul><h2 id="寻师求徒"><a href="#寻师求徒" class="headerlink" title="寻师求徒"></a>寻师求徒</h2><ul><li>指导就是再学习</li><li>如果没有一个优秀的指导老师，你不可能做到最好</li><li>我们向那些比我们懂得更多的人学习，通过对他们生活的研究，我们能够开阔自己的眼界。</li><li>一生要想取得成功，就必须有坚定的信念、勇于探索的勇气和坚强独立的个性。同时学会依靠那些身边可以利用的人脉，比如父亲，以及他身边那些专业能力较强的好友。</li><li>我可以通过观察别人的生活，来找到自己的生活方式。</li><li>如果你和人脉广的人来往，你也会广结人脉；如果你和成功人士打交道，你自己也更有可能取得成功。</li><li>二十几岁学知识，三十几岁赚大钱。</li><li>要想得到别人的指导，最好的方法就是先不求回报地帮助别人</li></ul><h2 id="如何平衡工作与生活"><a href="#如何平衡工作与生活" class="headerlink" title="如何平衡工作与生活"></a>如何平衡工作与生活</h2><ul><li>以人际关系驱动的工作并不能算是一种工作，那不过是一种生活方式</li><li>如果你觉得快乐，那你就找到了平衡</li><li>如果你讨厌你的工作，你就不可能热爱你的生活；并且，多数时候人们讨厌工作，是因为讨厌与他们共事的人。</li><li>社交则会让你有更多机会结识他人，那些人则可以为你带来新鲜刺激的工作体验。</li><li>做你所爱的事，就会觉得生活无一天不是假期。如果你的生活里满是你在意和在意你的人，那何必要自寻烦恼，考虑所谓的“平衡”问题呢？</li><li>我们灵魂所渴求的并不是名望、慰藉、财富或权力。这些馈赠虽可以解决不少麻烦，但同样带来了新的麻烦。我们灵魂渴求的其实是意义，是我们知道怎样活才能让生活有意义的一种意识，这样我们至少可以让这个世界因我们的存在而有些许不同。”</li><li>年轻的恋人追求完美，年老的恋人则将碎布缝制在一起，在繁杂的碎布中发现美的存在。</li><li>真正重要的是人。和我们喜欢的人一起工作，营造一个我们愿意生活其中的世界</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;经济潮涨涨落，友谊天长地久。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="人际交往" scheme="http://wittyfans.com/tags/%E4%BA%BA%E9%99%85%E4%BA%A4%E5%BE%80/"/>
    
      <category term="阅读笔记" scheme="http://wittyfans.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爱默生文集摘录</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E6%96%87%E9%9B%86%E6%91%98%E5%BD%95%E4%B8%80.html"/>
    <id>http://wittyfans.com/reading/爱默生文集摘录一.html</id>
    <published>2017-11-18T14:16:10.000Z</published>
    <updated>2018-03-15T17:46:16.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。</p></blockquote><a id="more"></a><h1 id="人的行为方式"><a href="#人的行为方式" class="headerlink" title="人的行为方式"></a>人的行为方式</h1><ul><li>无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。</li><li>当一个诗人不写诗时，他们就把诗融进自己的形体和行为方式。</li><li>当一个人已经充分表达了他的思想时，他所拥有的精神财富却没有丝毫损失。</li><li>当有人在生活中产生某种体验和感受禁不住要说出来的时候，我们的原则是：帮助他，让他说出来。当一个人向别人阐述他的思想时，他也就是在阐述他这个人本身；但是，当人企图把完整的思想拆开来逐一向人们解说时，他就使其讹用而变得不够准确了。</li></ul><h1 id="别人的价值观"><a href="#别人的价值观" class="headerlink" title="别人的价值观"></a>别人的价值观</h1><ul><li>现在的小说千篇一律，千人一面，类同相似，并且语言往往也是极为粗俗的。他通过描绘少男少女的浪漫生活将我们引入到一种对自私的利益和价值的追求。</li><li>小说也可以像《圣经》一样发挥巨大的积极的社会作用，只要他们展示给人们的是最好的社会生活侧面,解读的是善良、正直、真诚的人际关系。这是对友谊概念的一种法国式的阐释， 一种积极的理解。只有真诚才能在我们之间建立起最紧密的关系。这也正是所有好的小说的魅力所在，这实际上是历史事件的魅力。 </li></ul><h1 id="交际与交往"><a href="#交际与交往" class="headerlink" title="交际与交往"></a>交际与交往</h1><ul><li>我无需经常与他见面、交谈或写信，一切均在默契之中；我们也无需刻意去加深他对我们的印 象，或是寄去引起他回忆的纪念品；我信任他就如同信任自己；如果他也如此这般地做,我知道那是完全正常的。 </li><li>我不愿祈求美人的爱情，也不愿祈求朋友的友谊。</li><li>有些人不知不觉中伤害我们，剥夺我们的思想，关押和囚禁我们的精神。如果能心心相印，只需要一个聪敏的朋友便已足矣。</li><li>一个恶毒又好强的傻瓜常常会伤及很多人的理智，精神反常的人顽固的坚持错误，甚至连最优秀的人都有可能被激怒，十足的傻瓜相信唯有自己正确，连万有引力都是错的，如果谁要抨击，傻瓜会勃然大怒，与他交往密切的人，很快也会变得反常。</li><li>怎样和并不相宜的伙伴一同生活呢？生活中最美好的经历，就是同富有智慧的人们开诚布公的交往，这种交往会使我们相信，有一种精神力量正在召唤着我们，比称之为哲学或文学的东西更为灵验，更值得我们欢欣鼓舞。</li></ul><h1 id="需要反省的都市生活"><a href="#需要反省的都市生活" class="headerlink" title="需要反省的都市生活"></a>需要反省的都市生活</h1><ul><li>繁华都市里，市民们唯利是图、既无道德约束，又缺乏友情和热心。他们很难称之为人，而是些行尸走肉受欲望驱动着的物体。毫无生活目标，得过且过。</li><li>他们不相信知识分子，也不相信道德说教。仅仅相信化学工业、制酒食品业、机器制造业、蒸汽机、直流电、渦轮、缝细机和舆论，而不相信神圣的事业。</li></ul><h1 id="意志的力量"><a href="#意志的力量" class="headerlink" title="意志的力量"></a>意志的力量</h1><ul><li>人只有在自己先站起来之后，这个世界才有可能属于他。</li><li>意识薄弱者总是相信运气，相信他人的施舍。意识坚定则相信事物的因果关系，细加分析，毫无运气可言，完全是自然运行的事件和现象。</li><li>我绝不会失败，除非自己打败自己。</li><li>一个人在知己知彼客观分析之后，如果仍看不出差距，那么他将很容易被敌人打败。</li><li>我不能低估自己，去受环境的支配。</li><li>为了让你的知识更有价值，你就必须学会如何快乐，由衷的享乐人生就得到了滋养，因为精神喜悦就意味着力量。所有健康的个体，其心境都是舒畅的。天才在娱乐中工作，也就拥有了精神的力量，他就不会意志沮丧，相反会变得生龙活虎，雄心勃勃，但凡心灰意懒，就必然精神不振。</li><li>举止随和言语亲切能使人顺应任何环境。</li></ul><h1 id="美"><a href="#美" class="headerlink" title="美"></a>美</h1><ul><li>鲜花美丽、源于根基。</li><li>他越能够真正的适应自己，他就越美。</li><li>外在的修饰只是一种伪装，如果一切的行为的目的只是让人观看，那么这行为难免就显得下贱。</li><li>道德决定着健康的程度，假如你有一种永恒的追求，你的才智、行动必回体现，那将是一种崇高的美，任何人都望尘莫及。</li><li>任何呆滞刻板的或束缚于有限之中的东西都不会令人产生美，惟有那种与生命一道流滴，努力超越极限的东西才能令我们兴趣蔬然。</li><li>宫殿或圣殿之所以美，是因为一种秩序输入石头之中，它们就好像能够说话，能够用几何图形来表达；因而它们能够随着这种表达而变得温柔或崇高。</li><li>任何凝滞、堆砌或者过分注重的某一特征，一一例如长长的鼻子，尖尖的下巴，驼起的背，都是对美的反叛，因而是崎形的。</li><li>虽说匀称的形态都是美，然而如果那形态可以流动，我们就可以求得一种更为卓越的动态美。平衡的打破促使人们渴求着恢复，并且观察着它重获平衡的每一个步骤。这就是流水的魅力， 海浪的魅力，鸟儿的魅力和动物的魅力。</li><li>舞蹈的理论，就是在不断的变化中凭借着灵活的动作——而不是凭借着碎的和生硬的动作——去恢复失去的平衡。</li><li>用最简单的语言说明最伟大的道理，这正是美的最高境界。</li><li>美是恒古不变的，越是美，它也就越是保留的长久。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="摘录" scheme="http://wittyfans.com/tags/%E6%91%98%E5%BD%95/"/>
    
      <category term="读书笔记" scheme="http://wittyfans.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell常用命令</title>
    <link href="http://wittyfans.com/coding/Powershell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://wittyfans.com/coding/Powershell常用命令.html</id>
    <published>2017-11-14T15:14:08.000Z</published>
    <updated>2018-03-18T13:53:16.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Power shell 作为一门windows平台下的脚本语言，对于系统管理员来说，可以极大的减少我们的工作，作为一流的系统管理员（逃～），不可不学！</p></blockquote><a id="more"></a> <h1 id="Why-Power-Shell"><a href="#Why-Power-Shell" class="headerlink" title="Why Power Shell"></a>Why Power Shell</h1><ul><li>Working in windows</li><li>Support Object </li><li>.NET Support</li><li>Power ! ! ! </li></ul><h1 id="Over-View"><a href="#Over-View" class="headerlink" title="Over View"></a>Over View</h1><p>Power shell 作为一门windows平台下的脚本语言，可以极大的减少我们的工作，它的好处自然不用多说，用过的都知道，下面简单的看一下语法概览。</p><ul><li>查命令的使用：Get-Help</li><li>查对象的方法和属性:Get-Member</li><li><p>查命令历史记录:Get-History</p><ul><li>命令导出为ps1 : xxx | Foreach-Object {$_.CommandLine} &gt; C:\temp\script.ps1</li></ul></li><li><p>查找命令:Get-Command</p></li><li>上一条命令是否成功:$lastExitCode</li><li>一个命令要多久: Measure-Command{ scripts}</li></ul><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="where-object"><a href="#where-object" class="headerlink" title="where-object"></a>where-object</h2><p>使用这个命令可以从列表或者输出中过滤信息，格式为where-object{  } ,where-object回遍历它之前的属性，在{}中，可以使用$_来代表当前遍历的元素，所以，在where-object中，可以进行大量的操作。</p><h2 id="Foreach-Object"><a href="#Foreach-Object" class="headerlink" title="Foreach-Object"></a>Foreach-Object</h2><p>这个命令和where-object差不多，可以用来处理列表中的项，同样可以在其中使用$_命令</p><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>Get-Content 可以读取csv或者txt文件，读取完成之后可以通过数组的形式访问.</p><h1 id="数据导出到CSV文件"><a href="#数据导出到CSV文件" class="headerlink" title="数据导出到CSV文件"></a>数据导出到CSV文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Powershell Output info to CSV file</span><br><span class="line">$data = @()</span><br><span class="line">$row = New-Object PSObject</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;Username&quot; -Value $username</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;ComputerName&quot; -Value $ComputerName</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;Domain&quot; -Value $domainName</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;monitorSN&quot; -Value $monitorSN</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;ComputerSN&quot; -Value $info.SerialNumber</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;LastTimeLoginUser&quot; -Value $loginInfo.Name</span><br><span class="line">$row | Add-Member -MemberType NoteProperty -Name &quot;LoginCounts&quot; -Value $loginInfo.count</span><br><span class="line"></span><br><span class="line">$data += $row</span><br><span class="line">$data | Export-CSV \\10.65.64.219\soft\Information\infoList.csv -noTypeInformation -Append</span><br></pre></td></tr></table></figure><h2 id="PowerShell与excel文件交互"><a href="#PowerShell与excel文件交互" class="headerlink" title="PowerShell与excel文件交互"></a>PowerShell与excel文件交互</h2><ul><li><a href="http://www.lazywinadmin.com/2014/03/powershell-read-excel-file-using-com.html?m=1" target="_blank" rel="noopener">Read an Excel file using COM Interface</a></li></ul><h1 id="获取登录名"><a href="#获取登录名" class="headerlink" title="获取登录名"></a>获取登录名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name=Get-WmiObject -Class Win32_UserAccount -Filter &quot;Name=&apos;$env:username&apos; and Domain=&apos;$env:userdomain&apos;&quot;</span><br></pre></td></tr></table></figure><h1 id="控制csv的语法"><a href="#控制csv的语法" class="headerlink" title="控制csv的语法"></a>控制csv的语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># CSV:</span><br><span class="line"># a,b,c</span><br><span class="line"># 1,2,3</span><br><span class="line"># 4,5,6</span><br><span class="line"># 7,8,</span><br><span class="line"></span><br><span class="line">$csv = Import-Csv C:\test.txt</span><br><span class="line">$user = &quot;4&quot;</span><br><span class="line">foreach ($row in $csv) &#123;</span><br><span class="line">    if ($row.a -eq $user) &#123; $row.c = &quot;updated&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">$csv | Export-Csv C:\test.txt</span><br><span class="line"></span><br><span class="line">#Output:</span><br><span class="line">#TYPE System.Management.Automation.PSCustomObject</span><br><span class="line">#&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</span><br><span class="line">#&quot;1&quot;,&quot;2&quot;,&quot;3&quot;</span><br><span class="line">#&quot;4&quot;,&quot;5&quot;,&quot;updated&quot;</span><br><span class="line">#&quot;7&quot;,&quot;8&quot;,&quot;9&quot;</span><br></pre></td></tr></table></figure><h1 id="查看登陆到物理机的用户"><a href="#查看登陆到物理机的用户" class="headerlink" title="查看登陆到物理机的用户"></a>查看登陆到物理机的用户</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get-WmiObject -Class Win32_ComputerSystem |Select-object -ExpandProperty UserName</span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line"># 从bat运行powershell</span><br></pre></td></tr></table></figure><p>@echo off</p><p>powershell set-executionpolicy unrestricted<br>powershell -file D:\soft\Scripts\GetUsersPhoneNumber\getUserPhone.ps1</p><p>exit</p><p>CSV-EXCEL <a href="http://www.pstips.net/converting-csv-to-excel-file.html" target="_blank" rel="noopener">http://www.pstips.net/converting-csv-to-excel-file.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 判断操作系统位数</span><br></pre></td></tr></table></figure></p><p>(Get-WmiObject Win32_OperatingSystem).osarchitecture<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 隐藏明文密码</span><br></pre></td></tr></table></figure></p><p>Write-host “text for pwd”<br>$plainText = Read-Host | ConvertTo-SecureString -AsPlainText -Force<br>$encryptedText = $plainText | convertFrom-Securesting<br>Write-host $encryptedText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 查看域OU信息</span><br></pre></td></tr></table></figure></p><p>Get-ADOrganizationalUnit -Filter ‘Name -like “*”‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 参数的定义</span><br></pre></td></tr></table></figure></p><p>function Test-Function<br>{<br>    param($ 参数名 1=’默认参数值 1’, $ 参数名 2=’默认参数值 2’)<br>    Write-Host “参数 1=$ 参数名 1，参数 2=$ 参数名 2”;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 多线程</span><br><span class="line">- [Part1](https://blogs.technet.microsoft.com/heyscriptingguy/2015/11/26/beginning-use-of-powershell-runspaces-part-1/)</span><br><span class="line">- [Part2](https://blogs.technet.microsoft.com/heyscriptingguy/2015/11/27/beginning-use-of-powershell-runspaces-part-2/)</span><br><span class="line">- [Part3](https://blogs.technet.microsoft.com/heyscriptingguy/2015/11/28/beginning-use-of-powershell-runspaces-part-3/)</span><br><span class="line">- [多线程并发](http://blog.51cto.com/beanxyz/1760880)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通用参数</span><br></pre></td></tr></table></figure></p><p>-Verbose[:{$true | $false}]</p><p>显示有关由该命令执行的操作的详细信息。此信息类似于跟踪或事务日志中的信息。此参数仅在命令生成详细消息时才起作用。例如，此参数在命令中包含 Write-Verbose cmdlet 时起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 运行网上下载的ps1文件</span><br></pre></td></tr></table></figure></p><p>Unblock-File -Path “C:\Users\Fan.ZhangFZ\soft\Scripts\Invoke-Parallel-master\Invoke-Parallel\Invoke-Parallel.ps1”<br>. “C:\Users\Fan.ZhangFZ\soft\Scripts\Invoke-Parallel-master\Invoke-Parallel\Invoke-Parallel.ps1”<br><code>`</code></p><h1 id="远程建立ssion，处理powershell命令"><a href="#远程建立ssion，处理powershell命令" class="headerlink" title="远程建立ssion，处理powershell命令"></a>远程建立ssion，处理powershell命令</h1><ul><li><a href="http://www.cnblogs.com/sparkdev/p/7200004.html" target="_blank" rel="noopener">参考地址</a></li></ul><h1 id="关于-cmdletbinding"><a href="#关于-cmdletbinding" class="headerlink" title="关于[cmdletbinding()]"></a>关于[cmdletbinding()]</h1><ul><li><a href="http://blog.51cto.com/shadingyu/1965313" target="_blank" rel="noopener">参考1</a></li></ul><h1 id="Powershell渗透参考"><a href="#Powershell渗透参考" class="headerlink" title="Powershell渗透参考"></a>Powershell渗透参考</h1><ul><li><a href="http://b404.xyz/2017/12/30/exploit-domain/" target="_blank" rel="noopener">exploitDomain</a></li></ul><h1 id="PowerSheel-学习资源"><a href="#PowerSheel-学习资源" class="headerlink" title="PowerSheel 学习资源"></a>PowerSheel 学习资源</h1><ul><li><a href="http://www.pstips.net" target="_blank" rel="noopener">PSTips</a></li><li><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/powershell-scripting?view=powershell-5.1" target="_blank" rel="noopener">微软PowerSheel官方文档</a></li></ul><h1 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h1><ul><li>《Windows PowerShell 应用手册》——Lee Holmes著</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Power shell 作为一门windows平台下的脚本语言，对于系统管理员来说，可以极大的减少我们的工作，作为一流的系统管理员（逃～），不可不学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="Windows" scheme="http://wittyfans.com/tags/Windows/"/>
    
      <category term="HelpDesk" scheme="http://wittyfans.com/tags/HelpDesk/"/>
    
      <category term="技术支持" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    
      <category term="PowerShell" scheme="http://wittyfans.com/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>爱默生谈读书</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E8%B0%88%E8%AF%BB%E4%B9%A6.html"/>
    <id>http://wittyfans.com/reading/爱默生谈读书.html</id>
    <published>2017-11-10T14:15:51.000Z</published>
    <updated>2018-03-15T14:40:32.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。</p></blockquote><a id="more"></a><h1 id="读书的必要"><a href="#读书的必要" class="headerlink" title="读书的必要"></a>读书的必要</h1><ul><li>一本好书足以如良药般医治人们思想上的疾病，令人信服、思想进步</li><li>和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。</li><li>没有读过相关方面的著作，就没有资格在这方面发表什么言论。<!--more--></li></ul><h1 id="读书的原则"><a href="#读书的原则" class="headerlink" title="读书的原则"></a>读书的原则</h1><h2 id="顺其自然"><a href="#顺其自然" class="headerlink" title="顺其自然"></a>顺其自然</h2><p>顺其自然的重要性就在于，学生可以根据自己的兴趣来读，满足自己的求知欲，而不是机械地翻来翻去，强迫自己浪费时间</p><h2 id="兴趣优先"><a href="#兴趣优先" class="headerlink" title="兴趣优先"></a>兴趣优先</h2><p>要读适合自己的书，不要在质量不佳的庸书上浪费精力，例如哈菲兹是波斯人中的天才、孔子是中国的圣人、塞万提斯是法国人心中的智者</p><h2 id="精心挑选"><a href="#精心挑选" class="headerlink" title="精心挑选"></a>精心挑选</h2><p>远离浅薄无益的书，回避新闻界面中那些琐碎的闲谈和小道消息，优秀的名著中从头到尾都是深刻精辟的思想和生动翔实的例证，最好的环境中肯定有最好的信息。</p><h1 id="读书法则"><a href="#读书法则" class="headerlink" title="读书法则"></a>读书法则</h1><ul><li>不读当年出版的书</li><li>不读名不见经传的书</li><li>不读自己并不喜欢的书</li></ul><h1 id="作者推荐"><a href="#作者推荐" class="headerlink" title="作者推荐"></a>作者推荐</h1><ul><li>荷马</li><li>罗多德</li><li>埃斯切拉斯</li><li>柏拉图</li></ul><h1 id="书籍推荐（爱默生）"><a href="#书籍推荐（爱默生）" class="headerlink" title="书籍推荐（爱默生）"></a>书籍推荐（爱默生）</h1><ul><li>范都</li><li>普罗塔高勒斯</li><li>范德拉斯</li><li>理想国</li><li>苏格拉底对话录</li><li>普卢塔克</li><li>吉本《自传》《日记摘录》《读书摘要》</li></ul><hr><p>关于书籍推荐，个人推荐之前的博文《如何阅读一本书》结尾附送的青年必读书手册。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="学习" scheme="http://wittyfans.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="读书" scheme="http://wittyfans.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>爱默生谈财富</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E8%B0%88%E8%B4%A2%E5%AF%8C.html"/>
    <id>http://wittyfans.com/reading/爱默生谈财富.html</id>
    <published>2017-11-09T05:25:10.000Z</published>
    <updated>2018-03-15T14:43:05.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>财富的秘诀在于对自己拥有的事物的使用</p></blockquote><a id="more"></a><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>财富的秘诀在于对自己拥有的事物的使用</li><li>辛勤劳作是必须的，也是安身立命的基础</li><li>更重要的是精心计划、果断行动</li><li>看准某种趋势，可能一夜暴富</li><li>经济问题与人的道德紧密相关，直接决定一个人是否能独立自处</li><li>如果暴富会损坏一个人的道德，那么贫穷也会使人堕落。</li><li>对一个百万富翁来说，他会恪守诺言，讲究信誉，但对一个一贫如洗的人，你很难指望他的道德良知。<!--more--> </li><li>如果这样的人希望拥有健康的生活和完整的人格，他必须自己压制自己的欲望，自行决定自己的命运，按照社会的准则行事，一切只能控制在自己力所能及的范围之内。</li><li>真正的男子汉，是那些勇于拼搏的人，一切都尽力而为，也能够做到量力而行</li><li>坚贞不屈，勇往直前的人是自傲的，他也完全有资格自傲，他知道他的拼搏会得到回报，每个人在这个时候都会重拾生活的信心，别人只能敬佩有加</li><li>现在有一种通病，似乎个人的财富是社交界的通行证，似乎财富是一个人的面具，对于理性的人来说，财富是一种手段，而不是目的，它应该为我们服务，让我们更有实力。</li><li>一个理想主义者，只想着自己的设想，要求别人也这么做的时候，他就变得十分霸道，必然引起别人的反感。</li><li>对于有修养的人来说，财富具有感染力，可以让人更优雅，就像音乐一样，对于有鉴赏力的人来说，音乐的魅力是无穷的。</li><li>商业的艺术或者说经营的艺术很微妙，不是人人都可以投身其中的，一个注重实际的人只相信自己的亲身经历和亲眼所见。</li><li>实际的人只相信利润、游戏规则，不是把赚钱建立在运气上。</li><li>生意人的品格是诚实和务实，应该实事求是的看待收益和风险。</li><li>金钱可以看出一个人的风格与本性，随着人们才能和道德的进步，金钱的价值也将不断增加，在教育上增加一块钱，总比在罪犯上花一块钱管用</li></ul><h1 id="个人理财的建议"><a href="#个人理财的建议" class="headerlink" title="个人理财的建议"></a>个人理财的建议</h1><ol><li>我们应该量入而出，根据自己的赚钱能力来决定消费的多少，如果有足够的能力挣钱，投资也能稳赚不赔，那么即使有一些大手大脚也无所谓，做事情要保证质量也要保证速度，不能马虎了事，花钱要注重创造价值，该花花，该省省，我们不应该只关注表面现象，而应该用理性思维看待一切。节俭应当得到社会的尊重，谦虚是一种美得，但过分的谦卑只会让人难受，这样的情况下适度骄傲反而是一种好的品质，凭借自己的劳动生活的人与周围的人谈心也不卑不亢，而爱慕虚荣的人则艰难的多。</li><li>我们应该有一个系统的财经计划，根据自己的才能花钱。生活中单靠节俭和节制是解决不了任何问题的，但即使收入巨大也不能没有节制，成功理财的关键不是财富的多少，多节俭，而是摆正收入和支出的关系，协调好两者的比例。生活的实践是不断变化的，每一个行当都需要一个大师的任务去把握这种规律</li><li>必须在实践中小心为之，而不可随意执行自己拟定的计划。万物有他的规律，你不懂种地植树，时令懂；你不懂建筑造房，自有人懂，听从他们即可，我们只需要观察和倾听就好了，自行其是只会收到大自然的惩罚。自然，每个家庭都有适合自己的生活方式，如果丈夫在某本书中了解到一种新的生活方式想实行一下，好吧，让他试试看，准会以失败而告终。</li><li>我们不要异想天开，以为会有什么奇迹发生，而应该尽力获取自己熟悉的东西。对商人来说，诸如“最好的花钱方式是及时还债”、“生意是做出来的”，“时间就是金钱”、“机不可失”、“正确的投资是最好的赚钱方式”，等等口号，并不能反映深刻的道理，这都需要宽泛的解释，才能作为生活的准则。</li></ol><hr><p>真正的理财不单单是节俭，而是满足生活需要后，进行不断的投资，进一步创造财富，并不只是花在物质享受，而是花在精神满足和思想创造上，通过自身力量的增强，感受到成长和成熟的快乐，体验到那样的生命的活力和愉悦，这样我们才不只是一个守财奴。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;财富的秘诀在于对自己拥有的事物的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="生活" scheme="http://wittyfans.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="理财" scheme="http://wittyfans.com/tags/%E7%90%86%E8%B4%A2/"/>
    
      <category term="财富" scheme="http://wittyfans.com/tags/%E8%B4%A2%E5%AF%8C/"/>
    
  </entry>
  
  <entry>
    <title>Angualar使用笔记</title>
    <link href="http://wittyfans.com/coding/Angualar%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/coding/Angualar使用笔记.html</id>
    <published>2017-08-25T15:11:50.000Z</published>
    <updated>2018-03-15T14:45:54.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一套框架，多种平台</p></blockquote><a id="more"></a> <p>Angular学习笔记</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="我们需要什么样的开发环境？"><a href="#我们需要什么样的开发环境？" class="headerlink" title="我们需要什么样的开发环境？"></a>我们需要什么样的开发环境？</h2><ul><li>代码编辑</li><li>断点调试</li><li>版本管理</li><li>代码合并和混淆</li><li>依赖管理</li><li>单元测试</li><li>集成测试</li></ul><h2 id="常用工具介绍"><a href="#常用工具介绍" class="headerlink" title="常用工具介绍"></a>常用工具介绍</h2><ul><li>代码编辑<ul><li>Sublime</li><li>Webstom</li></ul></li><li>断点调试<ul><li>Chrom+Batarang浏览器插件</li></ul></li><li>版本管理<ul><li>Git</li><li>Tortoisegit</li></ul></li><li>代码合并和混淆<ul><li>Node.js+npm</li><li>Grunt</li></ul></li><li>依赖管理<ul><li>Bower(少用)</li><li>Http-server<ul><li>模拟测试数据</li></ul></li></ul></li><li>单元测试<ul><li>Karma（仅仅是容器）</li><li>Jasmine（编写测试用例工具）</li><li>Protractor（专为angularJS定制）</li></ul></li></ul><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC只是手段，终极目标是模块化和复用<br>Angular 的MVS全部借助于$scope实现，即利用作用域实现</p><h2 id="前端MVC的困难"><a href="#前端MVC的困难" class="headerlink" title="前端MVC的困难"></a>前端MVC的困难</h2><ul><li>操作DOM必须等待整个页面加载完成</li><li>多个js文件如果互相依赖，必须程序员自己解决</li><li>jd的原型继承也给前端编程带来很多困难</li></ul><h2 id="AngularJS中的Controller"><a href="#AngularJS中的Controller" class="headerlink" title="AngularJS中的Controller"></a>AngularJS中的Controller</h2><h3 id="Controller的实现方式"><a href="#Controller的实现方式" class="headerlink" title="Controller的实现方式"></a>Controller的实现方式</h3><ul><li>同一个数据模型，一个控制器控制多个视图<ul><li>如果多个视图之间没有关系，控制器的角色就很尴尬</li><li>控制器变成大杂烩</li><li>适合小项目</li></ul></li><li>同一个数据模型，每个视图对应一个视图<ul><li>两个控制器里的方法一样怎么办？利用继承通用控制器的方法可以解决但是这样不推荐（</li><li>利用Servers</li></ul></li></ul><h3 id="HTML中的代码"><a href="#HTML中的代码" class="headerlink" title="HTML中的代码"></a>HTML中的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div ng-controller = &quot;HelloAngular&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&#123;% raw %&#125;&#123;&#123; greeting.text &#125;&#125; &#123;% endraw %&#125;,Angular&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">//通过指令ng-controller= 实现控制器</span><br></pre></td></tr></table></figure><h3 id="Controller使用注意点"><a href="#Controller使用注意点" class="headerlink" title="Controller使用注意点"></a>Controller使用注意点</h3><ul><li>不要试图去复用Controller，一个控制器只负责一个小视图</li><li>不要再Controlller操作Dom，这不是控制器的职责</li><li>不要在Controller中做数据格式化，ng有很好的表单控件</li><li>不要再controller中做数据过滤操作，ng有$filter服务</li><li>controller是不需要互相调用的，一般会通过事件</li></ul><h2 id="AngularJS中的Model"><a href="#AngularJS中的Model" class="headerlink" title="AngularJS中的Model"></a>AngularJS中的Model</h2><p>Model大致运行过程</p><ul><li>AngularJS代码加载，完成后去寻找ng-app</li><li>ng-app所在标签内部的所有内容就归它所管</li><li>寻找所有属于ng的指令，进行编译操作</li><li>找到ng-model后生成数据模型，并给它取名为””中的值,挂载在Root Scope上，给所有子标签使用</li></ul><h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ul><li>不需要手动创建model</li><li>使用的时候利用$scope取值就好</li></ul><h2 id="AngularJS中的View"><a href="#AngularJS中的View" class="headerlink" title="AngularJS中的View"></a>AngularJS中的View</h2><h3 id="AngularJS和MVC都基于-Scope"><a href="#AngularJS和MVC都基于-Scope" class="headerlink" title="AngularJS和MVC都基于$Scope"></a>AngularJS和MVC都基于$Scope</h3><ul><li>$Scope是一个Polo</li><li>$Scope提供了一些工具方法</li><li>$Scope是表达式的执行环境</li><li>$Scope是一个树形结构，与DOM标签平行</li><li>$Scope对象会继承父$Scope上的属性和方法</li><li>每一个Angular应用只有一个根$Scope对象，一般位于ng-app</li><li>$Scope可以传播事件，类似DOM事件，可以向上也可以向下</li><li>$Scope不仅是MVC的基础，也是后面实现双向数据绑定的基础</li><li>可以用Angular.element($0).scope()进行调试</li></ul><h3 id="Scope的生命周期"><a href="#Scope的生命周期" class="headerlink" title="$Scope的生命周期"></a>$Scope的生命周期</h3><p>Creation（创建）-&gt;Watcher registration（观察监测）-&gt;Model mutation(模型变化)-&gt;Mutation observation（模型脏了？）-&gt;Scope destruction(销毁)</p><h3 id="模块化与依赖注入"><a href="#模块化与依赖注入" class="headerlink" title="模块化与依赖注入"></a>模块化与依赖注入</h3><p>AngularJS的模块化实现<br>把一个函数定义到全局空间，会污染全局空间,最好的方式是利用angular.module定义modle,再在model中定义控制器。模块是什么？模块是集合，集合了控制器，视图，过滤器，等等</p><h3 id="一个完整的项目结构是什么样的"><a href="#一个完整的项目结构是什么样的" class="headerlink" title="一个完整的项目结构是什么样的"></a>一个完整的项目结构是什么样的</h3><ul><li>app</li><li>css</li><li>JS</li><li>app.js <ul><li>controllers.js</li><li>drictives.js</li><li>filters.js</li><li>services.js</li></ul></li><li>Imgs</li><li>tpls（模版）<ul><li>index.html</li></ul></li><li>node-modules</li><li>framework（bootstrap等UI控件）</li><li>package.json</li></ul><h3 id="使用ngRoute进行视图之间的路由"><a href="#使用ngRoute进行视图之间的路由" class="headerlink" title="使用ngRoute进行视图之间的路由"></a>使用ngRoute进行视图之间的路由</h3><pre><code>应用规模很大，不可能只有一个View，这些View需要切换，AngularJS是根据URL来切换的，它有一个工具叫routeProvider。一切都是从模块开始的。如果控制器太多，需要把控制器分类成不同功能的模块，分给不同的开发者开发，利用grunt进行代码合并</code></pre><p>模块之间的依应该怎么做？–依赖注入，app.js作为入口，肯定需要依赖其他的模块,例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var book = angular.module(&apos;module1&apos;,&apos;module2&apos;)</span><br></pre></td></tr></table></figure></p><h1 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;% raw %&#125;&#123;&#123; greeting.text &#125;&#125; &#123;% endraw %&#125; ,Angular&lt;/p&gt;</span><br></pre></td></tr></table></figure>{{  }} ,数据绑定，分单双向 ,问题：会因为刷新、网络的问题，在网页中显示代码<br><br>## 取值表达式与ng-bind指令<br>解决方案：使用ng-bind，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span ng-bind=&quot;greeting.text&quot;&gt;&lt;/span&gt;,Angular&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="双向数据绑定典型场景——表单"><a href="#双向数据绑定典型场景——表单" class="headerlink" title="双向数据绑定典型场景——表单"></a>双向数据绑定典型场景——表单</h3><p>建立、html中、应用场景之更改css文件</p><h3 id="动态切换标签样式"><a href="#动态切换标签样式" class="headerlink" title="动态切换标签样式"></a>动态切换标签样式</h3><p>ng-show和ng-hide、ng-class，ng-clas可以接受表达式，例如在修改CSS样式的例子中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-class = &apos;&#123;error:isError, warning:isWarning&#125;&apos;&gt;&#123;% raw %&#125;&#123;&#123; messageText &#125;&#125; &#123;% endraw %&#125; &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>意思是，如果isError的值为True，则会用eror的样式ngAnimate</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令的运行机制。</p><ol><li>加载、加载angular.js，找到ng-app，确定应用边界</li><li>编译、遍历DOM，找到所有指令、根据指令代码中的template、replace、transclue转换dom结构、如果存在compile函数则调用</li><li>链接、对每一条指令运行link函数、link函数一般用来操作dom、绑定事件监听器</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>指令的形式，指令的外部为<name></name>,即它的使用形式</li><li>声明与定义，指令声明于控制器当中，控制器存在于模块当中，控制器需要在<div>中声明，在js文件中定义，指令也一样</div></li><li>指令的定义方式为，在定义控制器之后，使用控制器的directive方法定义,形式如下：</li></ol><p>1). 定义模块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var module = angular.module(&quot;module&quot;,[]);</span><br></pre></td></tr></table></figure></p><p>2). 定义控制器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.controller(&apos;myctrl&apos;,[&apos;$scope&apos;,function($scope)&#123;</span><br><span class="line">$scope.loadData = function()&#123;</span><br><span class="line">//code</span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p><p>3). 定义指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;</span><br><span class="line">link:function(scope,element,attr,*)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="使用与绑定事件"><a href="#使用与绑定事件" class="headerlink" title="使用与绑定事件"></a>使用与绑定事件</h2><p>link可用来绑定该指令的鼠标事件，该函数共有4个参数</p><ul><li>scope</li><li>element</li><li>attr</li><li>*(后面再介绍)</li></ul><h3 id="如何绑定鼠标事件？在link中"><a href="#如何绑定鼠标事件？在link中" class="headerlink" title="如何绑定鼠标事件？在link中"></a>如何绑定鼠标事件？在link中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.bind(&apos;event&apos;,function()&#123;</span><br><span class="line">scope.loadData();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope.$apply(&quot;loadData()&quot;);</span><br></pre></td></tr></table></figure><h3 id="指令要在另一个控制器中使用呢"><a href="#指令要在另一个控制器中使用呢" class="headerlink" title="指令要在另一个控制器中使用呢"></a>指令要在另一个控制器中使用呢</h3><p>定义另一个控制器,给指令定义属性，比如加载指令loader定义howtoload属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;</span><br><span class="line">link:function(scope,element,attr,*)&#123;</span><br><span class="line"></span><br><span class="line">scope.$apply(attr.howtoload());//必须小写</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="指令内部的分工"><a href="#指令内部的分工" class="headerlink" title="指令内部的分工"></a>指令内部的分工</h3><p>link中处理指令内部事件，绑定数据.etc,如果想要指令暴露出一些方法给外部用，那就写在控制器中require,表示依赖关系，.</p><h3 id="独立scope"><a href="#独立scope" class="headerlink" title="独立scope"></a>独立scope</h3><p> 效果：让数据与视图的数据独立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;,</span><br><span class="line">scope:&#123;&#125;,</span><br><span class="line">link:function(scope,element,attr,*)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="scope绑定策略"><a href="#scope绑定策略" class="headerlink" title="scope绑定策略"></a>scope绑定策略</h3><ul><li>@，以字符串的形式绑定</li><li>=，与父scope中的属性进行双向绑定</li><li>&amp;，传递一个来自父scope的函数，稍后调用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一套框架，多种平台&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="web" scheme="http://wittyfans.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离商城开发记录</title>
    <link href="http://wittyfans.com/coding/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95.html"/>
    <id>http://wittyfans.com/coding/前后端分离商城开发记录.html</id>
    <published>2017-08-16T12:09:31.000Z</published>
    <updated>2018-03-15T14:44:23.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个前后端完全分离的商城，把系统分为逻辑层、数据层、工具层三大层级，具有不错的可扩展性和可维护性，同时进行模块化拆分，通过组件的拼装达到业务的实现，提高开发效率。</p></blockquote><a id="more"></a> <h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>NodeJS（4.4.7）</li><li>Git</li><li>npm</li><li>Sublime</li><li>Chrome</li><li>Charles</li></ul><h1 id="Sublime技巧"><a href="#Sublime技巧" class="headerlink" title="Sublime技巧"></a>Sublime技巧</h1><h2 id="Sublime快捷键"><a href="#Sublime快捷键" class="headerlink" title="Sublime快捷键"></a>Sublime快捷键</h2><ul><li>cmd+shift+d 复制行</li><li>cmd+shift+k 删除行</li><li>cmd+； 注释</li><li>cmd+d 查找并选择</li><li>Ctrl + J：把当前选中区域合并为一行</li><li>Ctrl + M：在起始括号和结尾括号间切换</li><li>Ctrl + Shift + M：快速选择括号间的内容</li><li>Ctrl + Shift + J：快速选择同缩进的内容</li><li>Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容</li></ul><h2 id="Sublime插件"><a href="#Sublime插件" class="headerlink" title="Sublime插件"></a>Sublime插件</h2><p>command+shift+p sublime安装插件</p><ul><li>fileheader 文件头部添加时间，作者说明，快捷键comand+option+a</li></ul><h1 id="常用终端命令"><a href="#常用终端命令" class="headerlink" title="常用终端命令"></a>常用终端命令</h1><ul><li>ls -al 查看所有文件</li><li>rm -rf name 删除文件夹</li></ul><h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><pre><code>- git config —global user.name “name” - git config -global user.email “email”</code></pre><ul><li>查看ssh:cd~/.ssh</li><li>生成ssh key： ssh-keygen -t rsa -C “emakl”,回车</li><li>名称：id_rsa 私钥、id_rsa.pub公钥</li><li>复制id_rsa.pub,去git配置</li></ul><h2 id="本地目录关联远程目录"><a href="#本地目录关联远程目录" class="headerlink" title="本地目录关联远程目录"></a>本地目录关联远程目录</h2><ul><li>初始化：git init </li><li>对应当前文件夹与远程仓库:git remote add origin url</li><li>pull代码：git pull origin master</li><li>检查状态：git status</li><li>添加到缓存区：git add.</li><li>提交全部并添加注释:git commit -am “”</li></ul><h2 id="ignore配置"><a href="#ignore配置" class="headerlink" title="ignore配置"></a>ignore配置</h2><ul><li>新建ignore文件： vim .ignore</li><li>直接加入文件名，例如:.DS_Store、/node_modules/、/dist/</li></ul><h2 id="分之开发"><a href="#分之开发" class="headerlink" title="分之开发"></a>分之开发</h2><ul><li>git checkout -b branch-name，新建并切换到branch-name分之</li><li>git branch：查看现在的分支</li></ul><h2 id="克隆历史版本的git代码"><a href="#克隆历史版本的git代码" class="headerlink" title="克隆历史版本的git代码"></a>克隆历史版本的git代码</h2><p>在分之中，切换成历史分之即可</p><h1 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h1><h2 id="src原始文件"><a href="#src原始文件" class="headerlink" title="src原始文件"></a>src原始文件</h2><ul><li>逻辑层：page+view（页面，脚本与样式）</li><li>数据层：service</li><li>工具层：util</li><li>图片：image</li></ul><h2 id="Dist打包文件"><a href="#Dist打包文件" class="headerlink" title="Dist打包文件"></a>Dist打包文件</h2><ul><li>View</li><li>JS</li><li>Css</li><li>resource</li></ul><h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><ul><li>npm init：初始化</li><li>npm install <a href="mailto:xxx@v.v.v" target="_blank" rel="noopener">xxx@v.v.v</a> 安装依赖包</li><li>npm uninstall <a href="mailto:xxx@v.v.v" target="_blank" rel="noopener">xxx@v.v.v</a> 卸载依赖包</li><li>-g ：全局安装</li><li><ul><li>-registry = <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> ：使用国内淘宝源</li></ul></li></ul><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="安装与参考"><a href="#安装与参考" class="headerlink" title="安装与参考"></a>安装与参考</h2><ul><li>npm install webpack -g ：全局安装</li><li>npm install <a href="mailto:webpack@v.v.v" target="_blank" rel="noopener">webpack@v.v.v</a> –save-dev ： 项目中安装<ul><li>–save-dev，会把信息记录到packge.json中，不会打包到业务</li><li>–save，会打包到业务代码中</li></ul></li><li>webpack -v ：查看版本号</li></ul><h2 id="webpack-config-js-配置文件"><a href="#webpack-config-js-配置文件" class="headerlink" title="webpack.config.js 配置文件"></a>webpack.config.js 配置文件</h2><ul><li>etry：入口文件，源文件中js的路径</li><li>externals：外部依赖的声明，一些外部的内容可以用它来转化成commonJs和可引用的模块,比如jquery</li><li>output：目标文件</li><li>resolve：配置别名</li><li>module：各种文件、各种loader</li><li>plugins：加载webpack的插件</li></ul><h2 id="webpack-Loaders"><a href="#webpack-Loaders" class="headerlink" title="webpack Loaders"></a>webpack Loaders</h2><ul><li>html：html-webpack-plugin/html-loader</li><li>js:babel-loader+babel-preset-es2015</li><li>css:stle-loader+css-loader</li><li>image+font:url-loader</li></ul><h2 id="webpack对html模版的处理"><a href="#webpack对html模版的处理" class="headerlink" title="webpack对html模版的处理"></a>webpack对html模版的处理</h2><ol><li>对引入的CSS文件，需要加上版本号</li><li>html文件src文件中，并不在dist文件夹中如何处理？如果直接把html文件放到dist文件夹中，会面临dist删除的情况导致html文件丢失</li><li>方案：src中的html打包到dist（html-webpack-plugin）</li><li>每个页面的html都需要new一个plugin，这样很占用资源，可以定义一个函数来处理</li></ol><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>前端服务器，文件改变的时候，自动刷新浏览器</p><ul><li>安装：npm install webpack-dev-server –save-dev</li><li>配置：wepack-dev-server/client?http//localhost:8088</li><li>使用: wepack-dev-server —port 8088 –inline,inline 的意思是把server的client直接用脚本的方式插入页面</li></ul><h2 id="webpack常用命令"><a href="#webpack常用命令" class="headerlink" title="webpack常用命令"></a>webpack常用命令</h2><ul><li>webpack A B 把A打包到B（单文件打包）</li><li>webpack -p 最小化压缩的打包，发布的时候用</li><li>webpack –watch 监听文件的改变自动编译</li></ul><h2 id="安装Loader"><a href="#安装Loader" class="headerlink" title="安装Loader"></a>安装Loader</h2><h2 id="使用Plugin"><a href="#使用Plugin" class="headerlink" title="使用Plugin"></a>使用Plugin</h2><h2 id="对脚本和样式的处理"><a href="#对脚本和样式的处理" class="headerlink" title="对脚本和样式的处理"></a>对脚本和样式的处理</h2><h3 id="处理JS"><a href="#处理JS" class="headerlink" title="处理JS"></a>处理JS</h3><ul><li>JS用什么加载？ ：选用自带的js加载器</li><li><p>entry只有一个js，多个js文件怎么办？：entry变成对象，键值对（’’：[‘’]）来指定不同的js文件，注意多个entry需要指定多个output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry : &#123;</span><br><span class="line">&apos;index&apos;:[&apos;./src/page/index/index.js&apos;],</span><br><span class="line">&apos;login&apos;:[&apos;./src/page/login/login&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>output要分文件夹存放目标文件，怎么设置输出文件？：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output : &#123;</span><br><span class="line">path:&apos;./dist&apos;,</span><br><span class="line">filename: [name].js</span><br><span class="line">&#125;</span><br><span class="line">//[name]会使用源文件的名字</span><br><span class="line">//filename支持路径，如果改成js/[name].js,会建立js文件夹</span><br></pre></td></tr></table></figure></li><li><p>jquery引入方法？1.在页面中直接用脚本引入，<a href="http://www.bootcdn.cn" target="_blank" rel="noopener">特定版本</a>获取网址,2.模块化引入,在webpack config文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals : &#123;</span><br><span class="line">&apos;jquery&apos; : &apos;window.jQuery&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我想提取公共模块，怎么处理？使用<a href="">CommonsChunkPlugin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在plugins里new一个对象，在参数(对象)中配置如何提取公共模块</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">plugins : [</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">name : &apos;common&apos;,</span><br><span class="line">filename : &apos;js/base.js &apos;//</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>输出name的名字,路径前缀为output中的path</li><li>只有commons中的通用文件才会抽离到base.js中</li><li>在entry中也定义一个common入口，当webpack.optimize.CommonsChunkPlugin中的name也为commom的时候，common.js中引用的js文件中的通用部分就会打包进base.js</li></ul></li></ul><h3 id="处理CSS"><a href="#处理CSS" class="headerlink" title="处理CSS"></a>处理CSS</h3><ul><li>用什么loader加载？<br>style-loader!css-loader,执行顺序是由右往左，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module : &#123;</span><br><span class="line">loaders : [</span><br><span class="line">&#123;test:/\.css$/,loader:&quot;style-loader!css-loader&quot;&#125;</span><br><span class="line">//探测到以css结尾的文件，就使用style-loader!css-loader</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>使用之前，需要先安装：</p><pre><code>- npm install style-loader css-loader --save-dev </code></pre><ul><li>webpack把样式打包成了js模块，但我需要单独的css文件，不想在js运行完了才开始加载？<br>需要用到webpack css单独打包的插件，即<a href="">extrct-text-webpack-plugin</a>，<br>然后在webpack的配置文件中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ExtractTextPlugin = require (&quot;extract-text-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">//配置插件</span><br><span class="line">plugins: &#123;</span><br><span class="line">new ExtractTextPlugin(&quot;css/[name].css&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//注意Loader也需要配置</span><br><span class="line">module: &#123;</span><br><span class="line">loaders: [</span><br><span class="line">&#123; test:/\.css$/,loader:ExtractTextPlugin(&quot;css/[name].css&quot;) &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="对HTML的处理"><a href="#对HTML的处理" class="headerlink" title="对HTML的处理"></a>对HTML的处理</h2><h3 id="html-wepack-plugin"><a href="#html-wepack-plugin" class="headerlink" title="html-wepack-plugin"></a>html-wepack-plugin</h3><p>使用的方式和CSS插件一致，例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require (&quot;html-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">//配置HTML模版</span><br><span class="line">plugins: &#123;</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">template: &apos;./src/view/&apos; + name + &apos;.html&apos;,</span><br><span class="line">        filename: &apos;view/&apos; + name + &apos;.html&apos;,</span><br><span class="line">        title: title,</span><br><span class="line">        inject: true,</span><br><span class="line">        hash: true,</span><br><span class="line">        chunks: [&apos;common&apos;, name]</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>template:html原始的页面模版</li><li>filename：目标文件的位置，以output的path作为父目录</li><li>inject：注入方式，自动注入js和css</li><li>hash：会在引入的css、js文件加hash版本号</li><li>chunks：需要打包的模块</li></ul><hr><p>To be continued </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个前后端完全分离的商城，把系统分为逻辑层、数据层、工具层三大层级，具有不错的可扩展性和可维护性，同时进行模块化拆分，通过组件的拼装达到业务的实现，提高开发效率。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="编程" scheme="http://wittyfans.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="实战" scheme="http://wittyfans.com/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SASS学习记录</title>
    <link href="http://wittyfans.com/coding/SASS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
    <id>http://wittyfans.com/coding/SASS学习记录.html</id>
    <published>2017-07-20T07:24:05.000Z</published>
    <updated>2018-03-15T14:44:39.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SASS算是对CSS的优化，想想我们写CSS的经历，每次访问嵌套结构比较深的元素，都要写很多重复的代码，SASS对CSS增加了类似编程语言中的变量、<strike>函数</strike>混合宏、流程控制、继承等功能，让CSS的使用效率大大提升，让你的代码更容易复用，编写效率更高。</p></blockquote><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>我的系统是Mac OS，系统已经安装了Ruby（SASS依赖Ruby环境），如果你使用的是 Windows， 就需要先安装 Ruby。可以参考<a href="http://sass.bootcss.com/docs/sass-reference/#han-shu" target="_blank" rel="noopener">SASS中文网</a>。你可以检查一下自己的系统是否预装了Ruby，打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p><p>即可。之后，我们需要利用Ruby的包管理工具gem来下载SASS，使用之前，同样可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem -v</span><br></pre></td></tr></table></figure></p><p>来检查是否拥有gem。如果检测都成功，会显示相应的version版本号。随后就很简单了，一段代码搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install sass</span><br></pre></td></tr></table></figure></p><h1 id="SASS代码转化成CSS"><a href="#SASS代码转化成CSS" class="headerlink" title="SASS代码转化成CSS"></a>SASS代码转化成CSS</h1><p>安装完成后，我们就可以编写SASS代码了，但编写SASS代码，最终还是要转化成CSS的，我们可以让系统自动监视（watch）我们的文件。一旦有改动，就马上转换成CSS文件，这样我们只要在html中正确引用了CSS文件，就可以实时看到效果。（实时的效果可能需要用到<a href="https://www.npmjs.com/package/live-server" target="_blank" rel="noopener">LiveServer</a>）<br>如何监视呢，一条代码就可以了，在终端进入你的项目css文件所在文件夹,创建后缀名为scss的文件，以你的scss文件名为style为例,终端中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass — —watch style.scss:style.css</span><br></pre></td></tr></table></figure></p><p>style.scss为监视的对象，style.css为输出对象，html代码中需要引用css文件。监视成功后，SASS在当前文件夹中会创建一些必要的文件，以后每次改动，终端都会有记录。</p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p>SASS可以给CSS中的任何数值定义为变量，比如颜色、宽度、百分值等等。SASS使用$作为变量的前缀,以下定义了一个名为blue的颜色值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$blue:#708c87;</span><br></pre></td></tr></table></figure></p><p>也可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$cream:#F2EFEB;</span><br><span class="line">$pmargin:5%;</span><br><span class="line">$ppadding:20px;</span><br><span class="line">$hpadding:20px;</span><br></pre></td></tr></table></figure></p><h1 id="嵌套处理"><a href="#嵌套处理" class="headerlink" title="嵌套处理"></a>嵌套处理</h1><p>CSS中，为了要取得一个元素，你需要这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body a b c</span><br></pre></td></tr></table></figure></p><p>如果你的子元素非常多，会让你的代码看起来毫无层级结构，如果是SASS代码，那么看起来会是这样子的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: #262626; font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">    </span><br><span class="line">h1 &#123;</span><br><span class="line">        </span><br><span class="line">        color:$cream;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding-top: $hpadding;</span><br><span class="line">    &#125;</span><br><span class="line">p &#123;</span><br><span class="line">        margin: 20px $pmargin ;</span><br><span class="line">        padding: $ppadding $ppadding $ppadding $ppadding;</span><br><span class="line">        background-color: $cream;</span><br><span class="line">        color:$blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>html中是什么样的层级结构，你就可以在SASS中用什么样的层级结构去写，是不是一部了然？</p><h1 id="函数混合宏"><a href="#函数混合宏" class="headerlink" title="函数混合宏"></a><strike>函数</strike>混合宏</h1><p>如果你有一个固定的样式需要经常用到怎么办？在SASS中，你可以定义一个<strike>函数</strike>混合宏，然后在需要更改样式的地方，在相应的层级关系中插入这个<strike>函数</strike>混合宏就可以了，这样就可以做到一次定义，多次复用了，看如下的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin border-radius($radius: 20px)&#123;</span><br><span class="line">    border:2px solid;</span><br><span class="line">    border-radius:$radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个border-radius<strike>函数</strike>混合宏，@mixin是定义<strike>函数</strike>混合宏的关键字，相当于JS中的function,$radius:20px的意思是这个<strike>函数</strike>混合宏期待传入一个radius值，如果没有传入，它就会使用默认值20px.这个<strike>函数</strike>混合宏的意思是，让调用的环境拥有一个圆角效果。<br>好了，<strike>函数</strike>混合宏定义好了，如何使用呢？我们还是以上面的代码为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: #262626; font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">    h1 &#123;    </span><br><span class="line">        color:$cream;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding-top: $hpadding;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">        margin: 20px $pmargin ;</span><br><span class="line">        padding: $ppadding $ppadding $ppadding $ppadding;</span><br><span class="line">        background-color: $cream;</span><br><span class="line">        @include border-radius(10px);</span><br><span class="line">        color:$blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strike>函数</strike>混合宏使用的时候，只需要在<strike>函数</strike>混合宏名之前使用关键字@include、把相应的值传入即可。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承同样很简单，在需要被应用的元素中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@extend element；</span><br></pre></td></tr></table></figure></p><p>即可，element是要被应用的元素，继承后，该元素的样式会跟被继承的元素一样。继承的同时也可以给元素应用新的样式,在后面加入新的样式即可。</p><h1 id="导入其他文件"><a href="#导入其他文件" class="headerlink" title="导入其他文件"></a>导入其他文件</h1><p>有时候为了让项目文件更有条理，我们会把一些CSS文件分离开，但有时候又需要用到，这时候可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import</span><br></pre></td></tr></table></figure></p><p>导入其他的文件。所有引入的 SCSS 和 Sass 文件都会被<em>合并并输出一个单一的 CSS 文件**。 另外，被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。</em>但是如果你有一个 SCSS 或 Sass 文件<strong>需要引入， 但是你又不希望它被编译</strong>为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><p>*例如，你有一个文件叫做 _colors.scss。 这样就不会生成 _colors.css 文件了， 而且你还可以这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;colors&quot;;</span><br></pre></td></tr></table></figure></p><p>,来引入 _colors.scss 文件。</p><h1 id="父级引用"><a href="#父级引用" class="headerlink" title="父级引用"></a>父级引用</h1><p>有时候在我们的语句中，需要引用当前的环境，比如当你在<a>标签当中，你想要设置它的hover效果，你可能没办法直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hover&#123;…&#125;</span><br></pre></td></tr></table></figure></a></p><p>这样设置，但你可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，&amp;即代表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;</span><br></pre></td></tr></table></figure></p><p>&amp; 在编译时将被替换为父选择符，输出到 CSS 中。 也就是说，如果你有一个深层嵌套的规则，父选择符也会在 &amp; 被替换之前被完整的解析。</p><h1 id="使用List和-each"><a href="#使用List和-each" class="headerlink" title="使用List和@each"></a>使用List和@each</h1><p>假设有这个一个情况，你需要在网页中显示一组社交网络的图片，比如微信、微博、QQ之类的，那么在SASS下，如何写会比较省事呢？其实就是一个for循环就搞定了，List相当于一个容器，each相当于for循环，看例子：</p><p><strong>html代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class = &quot;social-links&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;weibo&quot; href=&quot;#&quot;&gt;weibo&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;wechat&quot; href=&quot;#&quot;&gt;wechat&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;qq&quot; href=&quot;#&quot;&gt;qq&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><strong>SASS代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义List</span><br><span class="line">$icons:&#123;weibo,wechat,qq&#125;;</span><br><span class="line"></span><br><span class="line">//循环赋值</span><br><span class="line">@each $social in $icons &#123;</span><br><span class="line">.#&#123;$social&#125; &#123;background:url(&apos;../img/#&#123;soicial&#125;.png&apos;)no-repeat;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$social 为新创建的对象，每次循环，它的值都会为icons这个List中的一个新值</li><li>在CSS语句后面写变量，通常需要加{},例如.#{$social},这段后面的花括号则是设置CSS的背景图片</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SASS算是对CSS的优化，想想我们写CSS的经历，每次访问嵌套结构比较深的元素，都要写很多重复的代码，SASS对CSS增加了类似编程语言中的变量、&lt;strike&gt;函数&lt;/strike&gt;混合宏、流程控制、继承等功能，让CSS的使用效率大大提升，让你的代码更容易复用，编写效率更高。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://wittyfans.com/tags/CSS/"/>
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://wittyfans.com/coding/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://wittyfans.com/coding/Linux常用命令.html</id>
    <published>2017-07-13T12:24:21.000Z</published>
    <updated>2018-03-15T14:45:19.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux常用参考手册，定期更新～</p></blockquote><a id="more"></a><h1 id="服务器连接与配置"><a href="#服务器连接与配置" class="headerlink" title="服务器连接与配置"></a>服务器连接与配置</h1><h2 id="修改alias（别名），简化命令操作"><a href="#修改alias（别名），简化命令操作" class="headerlink" title="修改alias（别名），简化命令操作"></a>修改alias（别名），简化命令操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">alias testhost=&apos;ssh root@8.8.8.8 -p 22&apos;</span><br></pre></td></tr></table></figure><h2 id="修改ssh配置，简化ssh命令"><a href="#修改ssh配置，简化ssh命令" class="headerlink" title="修改ssh配置，简化ssh命令"></a>修改ssh配置，简化ssh命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br><span class="line">#输入：</span><br><span class="line"></span><br><span class="line">Host testhost</span><br><span class="line">  HostName 8.8.8.8</span><br><span class="line">  Port 2222</span><br><span class="line">  User foo</span><br><span class="line"></span><br><span class="line">#保存后，可使用 ssh testhost 登陆服务器</span><br></pre></td></tr></table></figure><h2 id="Mac使用秘钥无密码登陆"><a href="#Mac使用秘钥无密码登陆" class="headerlink" title="Mac使用秘钥无密码登陆"></a>Mac使用秘钥无密码登陆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#生成本地秘钥，一路回车即可</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">#上传生成的秘钥到服务器</span><br><span class="line">scp ~/.ssh/id_rsa.pub testhost:~/.ssh/</span><br><span class="line">#使用以下命令将 id_rsa.pub 更名为 authorized_keys</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br><span class="line">#修改权限</span><br><span class="line">chmod 700 ~/.ssh/</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><ul><li>df -hl ：查看硬盘使用情况，以M显示</li><li>free -m :查看内存使用情况</li><li>top 查看CPU的使用情况</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.laozuo.org/1345.html" target="_blank" rel="noopener">硬盘</a></li><li><a href="http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html" target="_blank" rel="noopener">内存</a></li><li><a href="http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html" target="_blank" rel="noopener">CPU</a></li></ul><hr><p>持续更新</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux常用参考手册，定期更新～&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux之scp命令使用</title>
    <link href="http://wittyfans.com/coding/Linux%E4%B9%8Bscp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>http://wittyfans.com/coding/Linux之scp命令的使用.html</id>
    <published>2017-07-13T12:19:50.000Z</published>
    <updated>2018-03-15T14:35:35.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。</p></blockquote><a id="more"></a><h1 id="使用SCP命令在远程VPS和本地之间进行文件传输"><a href="#使用SCP命令在远程VPS和本地之间进行文件传输" class="headerlink" title="使用SCP命令在远程VPS和本地之间进行文件传输"></a>使用SCP命令在远程VPS和本地之间进行文件传输</h1><p>假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。</p><h2 id="1-什么是scp"><a href="#1-什么是scp" class="headerlink" title="1 什么是scp"></a>1 什么是scp</h2><p>scp就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证。scp在需要进行验证时会要求你输入密码或口令。</p><h2 id="2-实际操作"><a href="#2-实际操作" class="headerlink" title="2 实际操作"></a>2 实际操作</h2><p>2.1 下载VPS的文件(目录)到本地</p><p>假设需要将VPS上的一个文件下载到本地，文件路径是/root/test.log，VPS的IP地址是12.34.56.78，VPS的账户名是root，SSH端口是6666，我们将这个文件下载到本地的/Users/admin/root/test.log，那么我们需要执行的scp命令是</p><p>scp －P 6666 <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root/test.log /Users/admin/root/test.log<br>scp支持对整个目录进行操作，例如将上述root目录下载到本地</p><p>scp －P 6666 <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root /Users/admin/root<br>执行scp命令后需要输入VPS上对应账户的密码</p><p>2.2 上传本地的文件(目录)到VPS</p><p>假设需要将本地的一个文件上传到VPS，本地文件的路径是/Users/admin/root/test.log，VPS的IP地址是12.34.56.78，VPS的账户名是root，SSH端口是6666，我们将这个文件上传到VPS的/root/test.log，那么我们需要执行的scp命令是</p><p>scp -r －P 6666 /Users/admin/root/test.log <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root/test.log<br>同理，也能上传整个目录</p><p>scp -r －P 6666 /Users/admin/root <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://celerysoft.github.io/2016-07-07.html" target="_blank" rel="noopener">月下之光 - 攸溟</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
  </entry>
  
  <entry>
    <title>Screen指南</title>
    <link href="http://wittyfans.com/coding/Screen%E6%8C%87%E5%8D%97.html"/>
    <id>http://wittyfans.com/coding/Screen指南.html</id>
    <published>2017-07-13T12:18:32.000Z</published>
    <updated>2018-03-15T14:45:44.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p></blockquote><a id="more"></a><h1 id="Screen指南"><a href="#Screen指南" class="headerlink" title="Screen指南"></a>Screen指南</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在screen中创建一个新的窗口有这样几种方式：<br>1．直接在命令行键入screen命令<br>[root@tivf06 ~]# screen<br>Screen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。<br>2．Screen命令后跟你要执行的程序。<br>[root@tivf06 ~]# screen vi test.c<br>Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。<br>3．以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入C-a c，即Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。<br>screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/abc文件：<br>[root@tivf06 ~]# screen vi /tmp/abc<br>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示：</p><p>半个小时之后回来了，找到该screen会话：<br>[root@tivf06 ~]# screen -ls<br>There is a screen on:<br>        16582.pts-1.tivf06      (Detached)<br>1 Socket in /tmp/screens/S-root.<br>重新连接会话：<br>[root@tivf06 ~]# screen -r 16582<br>看看出现什么了，太棒了，一切都在。继续干吧。</p><p>你可能注意到给screen发送命令使用了特殊的键组合C-a。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。<br>可以通过C-a ?来查看所有的键绑定，常用的键绑定有：</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>C-a ?    显示所有键绑定信息</li><li>C-a w    显示所有窗口列表</li><li>C-a C-a    切换到之前显示的窗口</li><li>C-a c    创建一个新的运行shell的窗口并切换到该窗口</li><li>C-a n    切换到下一个窗口</li><li>C-a p    切换到前一个窗口(与C-a n相对)</li><li>C-a 0..9    切换到窗口0..9</li><li>C-a a    发送 C-a到当前窗口</li><li>C-a d    暂时断开screen会话</li><li>C-a k    杀掉当前窗口</li><li>C-a [    进入拷贝/回滚模式</li><li>其他常用的命令选项有：<br>-c file    使用配置文件file，而不使用默认的$HOME/.screenrc<br>-d|-D [pid.tty.host]    不开启新的screen会话，而是断开其他正在运行的screen会话<br>-h num    指定历史回滚缓冲区大小为num行<br>-list|-ls    列出现有screen会话，格式为pid.tty.host<br>-d -m    启动一个开始就处于断开模式的会话<br>-r sessionowner/ [pid.tty.host]    重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限<br>-S sessionname    创建screen会话时为会话指定一个名字<br>-v    显示screen版本信息<br>-wipe [match]    同-list，但删掉那些无法连接的会话</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>在终端中</strong></p><ul><li>screen -S name :新建名字为name的screen窗口</li><li>screen -ls : 查看所有后台窗口</li><li>screen -r name -&gt; 回到name这个session<br><strong>Screen中</strong></li><li>C-a k :杀掉当前screen</li><li>C-a d :暂时断开screen的连接</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">IBM</a></li><li><a href="http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html" target="_blank" rel="noopener">David Camp - CNBlog</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>主机名由localhost变成bogon的解决办法</title>
    <link href="http://wittyfans.com/coding/%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%94%B1localhost%E5%8F%98%E6%88%90bogon%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"/>
    <id>http://wittyfans.com/coding/主机名由localhost变成bogon的解决办法.html</id>
    <published>2017-07-13T12:15:34.000Z</published>
    <updated>2018-03-15T14:46:09.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如题。</p></blockquote><a id="more"></a><h1 id="主机名由localhost变成bogon的解决办法"><a href="#主机名由localhost变成bogon的解决办法" class="headerlink" title="主机名由localhost变成bogon的解决办法"></a>主机名由localhost变成bogon的解决办法</h1><ul><li>修改你的 DNS 为公共 DNS，例如 114.114.114.114 或者谷歌的 8.8.8.8（我切换DNS便解决了问题）</li><li>编辑主机名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo hostname your-desired-host-name</span><br><span class="line"></span><br><span class="line">sudo scutil --set LocalHostName $(hostname)</span><br><span class="line"></span><br><span class="line">sudo scutil --set HostName $(hostname)</span><br></pre></td></tr></table></figure></li></ul><h1 id="为什么会出现这个问题"><a href="#为什么会出现这个问题" class="headerlink" title="为什么会出现这个问题"></a>为什么会出现这个问题</h1><p>终端在初始化时，需要确定主机的名字，此时终端会向 DNS 服务器反向查询本机 IP 地址，然后把得到的名字作为自己的主机名。如果没有反向解析的结果，就会显示本机设置的主机名。那么 bogon 是什么意思呢？一个 DNS 反向解析名为 bogon 的 IP 地址不会显示在 traceroute 中。我猜题主可能在一个路由器组织的局域网环境中，并且你的 DNS 地址是你路由器的地址，这样终端反向查询你本机 IP 地址得到的结果是 bogon，于是你在终端里显示的主机名就变成了 bogon。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.zhihu.com/question/25849047" target="_blank" rel="noopener">知乎</a></li><li><a href="https://air20.com/archives/486.html" target="_blank" rel="noopener">Air20</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="http://wittyfans.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://wittyfans.com/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://wittyfans.com/coding/正则表达式学习.html</id>
    <published>2017-07-13T12:11:09.000Z</published>
    <updated>2018-03-15T14:46:24.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式学习与快速参考</p></blockquote><a id="more"></a><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><ul><li>.    匹配除换行符以外的任意字符</li><li>\w    匹配字母或数字或下划线或汉字</li><li>\s    匹配任意的空白符</li><li>\d    匹配数字</li><li>\b    匹配单词的开始或结束</li><li>^    匹配字符串的开始</li><li>$    匹配字符串的结束</li></ul><h1 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h1><p>使用\来取消元字符特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。</p><h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><ul><li>重复零次或更多次</li><li>重复一次或更多次</li><li>?    重复零次或一次</li><li>{n}    重复n次</li><li>{n,}    重复n次或更多次</li><li>{n,m}    重复n到m次</li></ul><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>用括号括起来指定子表达式，然后还可以指定分组的重复次数、进行其他的操作。例如如下的ip地址的例子<br>(\d{1,3}.){3}\d{1,3}</p><p><strong>下面是一些使用重复的例子：</strong></p><ul><li>Windows\d+匹配Windows后面跟1个或更多数字</li><li>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</li></ul><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p>用来指定一个范围，比如像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><h1 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h1><p>其实就是“或”的意思，如果满足了语句|两边任意一个条件，都会进行匹配</p><h1 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h1><p>通常是把字母变成大写，也有用中括号括起来的时候</p><ul><li>\W    匹配任意不是字母，数字，下划线，汉字的字符</li><li>\S    匹配任意不是空白符的字符</li><li>\D    匹配任意非数字的字符</li><li>\B    匹配不是单词开头或结束的位置</li><li>[^x]    匹配除了x以外的任意字符</li><li>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</li></ul><h1 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h1><p>用小括号指定的子表达式，匹配了这个表达式的文本，可以在另一个语句中进一步处理。<br>系统会对表达式中的语句进行分组，通常是按照单个子表达式分割线\或者小括号来分组，分组用数字来表示，也可以给指定分组起名字。</p><ul><li>可以用\加数字的方式引用分组，\0表示整个表达式，\1表示第一个，以此类推；</li><li>指定表达式的组名的语法:(?&lt;名字&gt;表达式)或者(?’名字’表达式)</li></ul><h1 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h1><p>断言的意思其实就是位置，关于位置，我们前面学过一些比如\b，^,$，他们通常都代表着文本中的某个位置，零宽断言也类似。<br>共有四种零宽断言</p><h1 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h1><p>如果在一个文本中，符合条件的匹配有很多，即会有一定数量的重复，那么匹配任务的原则会分两种情况</p><ol><li>尽可能匹配多的文本，比如atbtttttttb中匹配atbtttttttb</li><li>尽可能匹配少的文本,比如atbtttttttb中匹配atb</li></ol><ul><li>*?    重复任意次，但尽可能少重复</li><li>+?    重复1次或更多次，但尽可能少重复</li><li>??    重复0次或1次，但尽可能少重复</li><li>{n,m}?    重复n到m次，但尽可能少重复</li><li>{n,}?    重复n次以上，但尽可能少重复</li></ul><h1 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h1><ul><li>\    将下一个字符标记为一个特殊字符(File Format Escape)、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</li><li>^    匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</li><li>$    匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</li><li>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</li><li>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</li><li>?    匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</li><li>{n}    n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</li><li>{n,}    n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</li><li>{n,m}    m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</li><li>?    非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</li><li>.    匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。</li><li>(pattern)    匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</li><li>(?:pattern)    匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</li><li>(?=pattern)    正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</li><li>(?!pattern)    正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</li><li>(?&lt;=pattern)    反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</li><li>(?&lt;!pattern)    反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</li><li>x|y    匹配x或y。例如，“z|food”能匹配“z”或“food”。“(?:z|f)ood”则匹配“zood”或“food”。</li><li>[xyz]    字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</li><li>[^xyz]    排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</li><li>[a-z]    字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</li><li>[^a-z]    排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</li><li>[:name:]    增加命名字符类（named character class）[注 1]中的字符到表达式。只能用于方括号表达式。</li><li>[=elt=]    增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用于方括号表达式。</li><li>[.elt.]    增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语， “CH”作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。</li><li>\b    匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</li><li>\B    匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</li><li>\cx    匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</li><li>\d    匹配一个数字字符。等价于[0-9]。</li><li>\D    匹配一个非数字字符。等价于[^0-9]。</li><li>\f    匹配一个换页符。等价于\x0c和\cL。</li><li>\n    匹配一个换行符。等价于\x0a和\cJ。</li><li>\r    匹配一个回车符。等价于\x0d和\cM。</li><li>\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</li><li>\S    匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</li><li>\t    匹配一个制表符。等价于\x09和\cI。</li><li>\v    匹配一个垂直制表符。等价于\x0b和\cK。</li><li>\w    匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</li><li>\W    匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</li><li>\ck    匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。</li><li>\xnn    十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.</li><li>\num    向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符。</li><li>\n    标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</li><li>\nm    3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</li><li>\nml    如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</li><li>\un    Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/正则表达式" target="_blank" rel="noopener">正则表达式WIKI</a></li><li><a href="https://deerchao.net/tutorials/regex/regex.htm#repeat" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正则表达式学习与快速参考&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="正则" scheme="http://wittyfans.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>2017前端学习路线与资料</title>
    <link href="http://wittyfans.com/coding/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%862017%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99.html"/>
    <id>http://wittyfans.com/coding/个人整理2017前端学习路线与资料.html</id>
    <published>2017-06-07T09:42:23.000Z</published>
    <updated>2018-03-15T14:32:00.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习路漫漫，得找对方向。</p></blockquote><a id="more"></a><h1 id="概览OverView"><a href="#概览OverView" class="headerlink" title="概览OverView"></a>概览OverView</h1><p>国外大神整理的Web开发路线图，共四张图覆盖了不同的方向。<br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/1.PNG" alt="2017 Web Learning map1"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/3.PNG" alt="2017 Web Learning map2"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/4.PNG" alt="2017 Web Learning map3"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/5.PNG" alt="2017 Web Learning map4"></p><h1 id="资源Resource"><a href="#资源Resource" class="headerlink" title="资源Resource"></a>资源Resource</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰Git教程</a></li></ul><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><a href="https://www.youtube.com/watch?v=DbPDraCYju8" target="_blank" rel="noopener">SSH Tutorial - Basic server administration with SSH</a></p><ul><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用</a></li></ul><h2 id="HTML-CSS-JS"><a href="#HTML-CSS-JS" class="headerlink" title="HTML/CSS/JS"></a>HTML/CSS/JS</h2><ul><li><a href="http://w3school.com.cn" target="_blank" rel="noopener">W3C</a></li><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">廖雪峰JavaScript</a></li></ul><h3 id="CSS-FrameWork"><a href="#CSS-FrameWork" class="headerlink" title="CSS FrameWork"></a>CSS FrameWork</h3><ul><li><a href="http://v3.bootcss.com" target="_blank" rel="noopener">BootStrap</a><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2></li><li><a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">ES6</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习路漫漫，得找对方向。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="个人提高" scheme="http://wittyfans.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="学习" scheme="http://wittyfans.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Web" scheme="http://wittyfans.com/tags/Web/"/>
    
      <category term="Learning" scheme="http://wittyfans.com/tags/Learning/"/>
    
      <category term="Improve yourself" scheme="http://wittyfans.com/tags/Improve-yourself/"/>
    
  </entry>
  
  <entry>
    <title>产品经理的数字工具们 👨🏻‍💻</title>
    <link href="http://wittyfans.com/coding/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E6%95%B0%E5%AD%97%E5%B7%A5%E5%85%B7%E4%BB%AC.html"/>
    <id>http://wittyfans.com/coding/产品经理的数字工具们.html</id>
    <published>2017-05-28T02:04:49.000Z</published>
    <updated>2018-03-15T14:46:32.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>干货大放送。</p></blockquote><a id="more"></a><h1 id="第一部分：日常创作-灵感收集-思维导图"><a href="#第一部分：日常创作-灵感收集-思维导图" class="headerlink" title="第一部分：日常创作+灵感收集+思维导图"></a>第一部分：日常创作+灵感收集+思维导图</h1><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">https://daringfireball.net/projects/markdown/</a></li><li>Markdown 语法说明（简体中文版）</li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></li><li>献给写作者的 Markdown 新手指南 - 简书</li><li><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">http://www.jianshu.com/p/q81RER</a></li></ul><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><ul><li>Bear (macOS / iOS)</li><li><a href="http://www.bear-writer.com/" target="_blank" rel="noopener">http://www.bear-writer.com/</a></li><li>Ulysses (macOS / iOS)</li><li><a href="https://www.ulyssesapp.com/" target="_blank" rel="noopener">https://www.ulyssesapp.com/</a></li><li>Day One (macOS / iOS)</li><li><a href="http://dayoneapp.com/" target="_blank" rel="noopener">http://dayoneapp.com/</a></li><li>Mou (macOS)</li><li><a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></li><li>MarkdownPad (Windows)</li><li><a href="http://markdownpad.com/" target="_blank" rel="noopener">http://markdownpad.com/</a></li><li>为知笔记（macOS / Windows / Linux / iOS / Android）</li><li><a href="http://www.wiz.cn/" target="_blank" rel="noopener">http://www.wiz.cn/</a></li></ul><h3 id="使用-Markdown-来写博客："><a href="#使用-Markdown-来写博客：" class="headerlink" title="使用 Markdown 来写博客："></a>使用 Markdown 来写博客：</h3><ul><li>Jekyll</li><li><a href="https://jekyllrb.com/" target="_blank" rel="noopener">https://jekyllrb.com/</a></li><li>Hexo</li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li><li>GitHub Pages</li><li><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></li><li>Coding Pages</li><li><a href="https://coding.net/help/doc/pages/" target="_blank" rel="noopener">https://coding.net/help/doc/pages/</a></li></ul><h3 id="一些好用的-Markdown-插件或周边产品："><a href="#一些好用的-Markdown-插件或周边产品：" class="headerlink" title="一些好用的 Markdown 插件或周边产品："></a>一些好用的 Markdown 插件或周边产品：</h3><p>专为印象笔记（Evernote）打造的 Markdown 编辑器：马克飞象<br><a href="https://maxiang.io/" target="_blank" rel="noopener">https://maxiang.io/</a><br>在浏览器上使用随处可用的 Markdown 插件：Markdown Here (Chrome)<br><a href="http://markdown-here.com/" target="_blank" rel="noopener">http://markdown-here.com/</a><br>基于 Markdown 的高颜值的微信公众号图文消息排版工具<br><a href="https://github.com/ufologist/wechat-mp-article" target="_blank" rel="noopener">https://github.com/ufologist/wechat-mp-article</a></p><h1 id="第二部分：原型设计-交互设计-需求文档"><a href="#第二部分：原型设计-交互设计-需求文档" class="headerlink" title="第二部分：原型设计+交互设计+需求文档"></a>第二部分：原型设计+交互设计+需求文档</h1><h2 id="抛弃-Axure-RP-的解决方案："><a href="#抛弃-Axure-RP-的解决方案：" class="headerlink" title="抛弃 Axure RP 的解决方案："></a>抛弃 Axure RP 的解决方案：</h2><ul><li>原型设计：Sketch</li><li>动效设计：Keynote / Flinto</li><li>需求文档：GitBook / GitHub Wiki / Dropbox Paper</li></ul><h2 id="用-Sketch-进行原型设计的一些资源："><a href="#用-Sketch-进行原型设计的一些资源：" class="headerlink" title="用 Sketch 进行原型设计的一些资源："></a>用 Sketch 进行原型设计的一些资源：</h2><ul><li>Sketch App Resources</li><li><a href="https://www.sketchappsources.com/category/wireframe.html" target="_blank" rel="noopener">https://www.sketchappsources.com/category/wireframe.html</a></li><li>Beforweb 的 iOS WireframeKit for Sketch（付费）</li><li><a href="http://mp.weixin.qq.com/s/ZdBcHzWDU4hP7uMgXlUkSw" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/ZdBcHzWDU4hP7uMgXlUkSw</a></li></ul><h2 id="动效设计："><a href="#动效设计：" class="headerlink" title="动效设计："></a>动效设计：</h2><ul><li>Keynote (macOS / iOS / iCloud)</li><li><a href="https://www.apple.com/keynote/" target="_blank" rel="noopener">https://www.apple.com/keynote/</a></li><li>Flinto (macOS)</li><li><a href="https://www.flinto.com/" target="_blank" rel="noopener">https://www.flinto.com/</a></li></ul><h2 id="小众神器GitBook"><a href="#小众神器GitBook" class="headerlink" title="小众神器GitBook"></a>小众神器GitBook</h2><ul><li><a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a></li><li><a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">https://github.com/GitbookIO/gitbook</a></li><li>GitHub Wiki</li><li><a href="https://help.github.com/articles/about-github-wikis/" target="_blank" rel="noopener">https://help.github.com/articles/about-github-wikis/</a></li><li>案例<ul><li><a href="https://nodejs.xiangfa.org/" target="_blank" rel="noopener">Node.js API 中文文档</a></li><li><a href="https://mubu.com/asset/html/book/" target="_blank" rel="noopener">幕布用户使用手册</a></li><li><a href="https://doctorkowj.gitbooks.io/kppolicy/" target="_blank" rel="noopener">柯 P 新政 · 市政白皮书 by 柯文哲</a></li></ul></li></ul><h2 id="小众神器推荐：Dropbox-Paper"><a href="#小众神器推荐：Dropbox-Paper" class="headerlink" title="小众神器推荐：Dropbox Paper"></a>小众神器推荐：Dropbox Paper</h2><ul><li><a href="https://www.dropbox.com/paper" target="_blank" rel="noopener">Dropbox Paper</a></li></ul><h2 id="小众神器推荐：Lingo"><a href="#小众神器推荐：Lingo" class="headerlink" title="小众神器推荐：Lingo"></a>小众神器推荐：Lingo</h2><ul><li><p><a href="https://www.lingoapp.com/" target="_blank" rel="noopener">Lingo</a></p><h3 id="使用-Lingo-必备的图标库："><a href="#使用-Lingo-必备的图标库：" class="headerlink" title="使用 Lingo 必备的图标库："></a>使用 Lingo 必备的图标库：</h3></li><li><p><a href="https://material.io/icons/" target="_blank" rel="noopener">Material Icons by Google</a></p></li><li><a href="https://www.lingoapp.com/store/resource/material_icons/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/material_icons/</a></li><li><a href="https://thenounproject.com/" target="_blank" rel="noopener">Noun Project</a></li><li><a href="https://www.lingoapp.com/store/resource/nounproject/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/nounproject/</a></li><li><a href="https://github.com/twitter/twemoji" target="_blank" rel="noopener">Twemoji</a></li><li><a href="https://www.lingoapp.com/store/resource/twemoji/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/twemoji/</a></li><li><a href="http://facebook.design/devices.html" target="_blank" rel="noopener">Facebook Devices</a></li><li><a href="https://www.lingoapp.com/store/resource/devices/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/devices/</a></li><li><a href="https://www.mapbox.com/maki-icons/" target="_blank" rel="noopener">Maki Map Icons by Mapbox</a></li><li><a href="https://www.lingoapp.com/store/resource/maki_map_icons/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/maki_map_icons/</a></li></ul><h3 id="Noun-Project-网页版"><a href="#Noun-Project-网页版" class="headerlink" title="Noun Project 网页版"></a>Noun Project 网页版</h3><p><a href="https://thenounproject.com/" target="_blank" rel="noopener">https://thenounproject.com/</a><br>Noun Project App (macOS / Windows)<br><a href="https://thenounproject.com/for-mac/" target="_blank" rel="noopener">https://thenounproject.com/for-mac/</a><br><a href="https://thenounproject.com/for-windows/" target="_blank" rel="noopener">https://thenounproject.com/for-windows/</a><br>Icons8 网页版<br><a href="https://icons8.com/" target="_blank" rel="noopener">https://icons8.com/</a><br><a href="https://icons8.com/web-app/new-icons/all" target="_blank" rel="noopener">https://icons8.com/web-app/new-icons/all</a><br>Icons8 App (macOS / Windows)<br><a href="https://icons8.com/app" target="_blank" rel="noopener">https://icons8.com/app</a><br>Nucleo<br><a href="https://nucleoapp.com/" target="_blank" rel="noopener">https://nucleoapp.com/</a></p><h3 id="其他支持搜索的在线图标库："><a href="#其他支持搜索的在线图标库：" class="headerlink" title="其他支持搜索的在线图标库："></a>其他支持搜索的在线图标库：</h3><p>阿里巴巴矢量图标库<br><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a><br>Iconfinder<br><a href="https://www.iconfinder.com/" target="_blank" rel="noopener">https://www.iconfinder.com/</a><br>Easyicon<br><a href="http://www.easyicon.net/" target="_blank" rel="noopener">http://www.easyicon.net/</a></p><h1 id="第三部分：需求管理-团队沟通-协奏平台"><a href="#第三部分：需求管理-团队沟通-协奏平台" class="headerlink" title="第三部分：需求管理+团队沟通+协奏平台"></a>第三部分：需求管理+团队沟通+协奏平台</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Teambition (Web / macOS / Windows / iOS / Android)</li><li><a href="https://www.teambition.com/" target="_blank" rel="noopener">https://www.teambition.com/</a></li><li>Worktile (Web / macOS / Windows / iOS / Android)</li><li><a href="https://worktile.com/" target="_blank" rel="noopener">https://worktile.com/</a></li><li>伙伴云表格 (Web)</li><li><a href="https://www.huoban.com/" target="_blank" rel="noopener">https://www.huoban.com/</a><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2></li><li>Slack (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://slack.com/" target="_blank" rel="noopener">https://slack.com/</a></li><li>倍洽 BearyChat (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://bearychat.com/" target="_blank" rel="noopener">https://bearychat.com/</a></li><li>简聊 (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://jianliao.com/" target="_blank" rel="noopener">https://jianliao.com/</a></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li>《The New Methodology》- Martin Fowler</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;干货大放送。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="个人提高" scheme="http://wittyfans.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
      <category term="互联网" scheme="http://wittyfans.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
</feed>
