<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wittyfans</title>
  
  <subtitle>学则不固,知则不惑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wittyfans.com/"/>
  <updated>2019-06-07T13:59:34.168Z</updated>
  <id>http://wittyfans.com/</id>
  
  <author>
    <name>wittyfans</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 常用命令整理(eng)</title>
    <link href="http://wittyfans.com/writing/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-eng.html"/>
    <id>http://wittyfans.com/writing/Linux-常用命令整理-eng.html</id>
    <published>2019-06-07T13:56:19.000Z</published>
    <updated>2019-06-07T13:59:34.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>常用命令的cheatsheet，如果想了解更多理论部分，请参考之前的文章<a href="http://wittyfans.com/coding/Linux阅读笔记.html">Linux阅读笔记</a>。</p></blockquote><a id="more"></a><h1 id="Linux-Mac-Commands"><a href="#Linux-Mac-Commands" class="headerlink" title="Linux / Mac Commands"></a>Linux / Mac Commands</h1><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><ul><li>cd</li><li>pwd</li><li>ls</li><li>ls -a</li><li>ls -l </li><li>ls -la</li><li>cd .. </li><li>ls sub_dir/</li><li>cd ~</li></ul><h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><ul><li>mkdir</li><li>touch</li><li>cp, copy a file</li><li>cp -r, copy a directory</li><li>mv, rename or moving a file</li><li>open</li><li>rm</li><li>rm -rf, force removing a directory</li><li>man(-r), show some info</li><li>about, info</li></ul><h1 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><ul><li>man find</li></ul><h2 id="by-name"><a href="#by-name" class="headerlink" title="by name"></a>by name</h2><ul><li>find ., list all file and folder below current</li><li>find folder</li><li>find . -type d, find all foldre, no file</li><li>find . -type f, find all file , no foldre</li><li>find . -type f -name “test.txt”, name as text txt file</li><li>find . -type f -name “text*”, name as txt all file</li><li>find . -type f -iname “text*”, 不区分大小写</li><li>find . -type f -name “*.py”</li></ul><h2 id="by-time"><a href="#by-time" class="headerlink" title="by time"></a>by time</h2><ul><li>find . -type f -mmin -10,过去十分钟修改过的文件</li><li>find . -type f -mmin +10</li><li>find . -type f -mmin +1 -mmin -5</li><li>find . -type f -mtime -20</li></ul><blockquote><p>amin,atime: access min and access day; cmin,ctime: change min and change day; mmin,mtime: modify;</p></blockquote><h2 id="by-size"><a href="#by-size" class="headerlink" title="by size"></a>by size</h2><ul><li><p>find . -size +5m</p><blockquote><p>k,g is work too</p></blockquote></li><li><p>ls -lah ./folders, info about sub folder and files,including size</p></li><li>find . -empty</li></ul><h2 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h2><ul><li>find. -perm 777, read, write, and excute</li><li>find folder -exec chown coreschafer:www-data {} +</li></ul><blockquote><p>find folder, will return all folder, -exec will run the command in that results, {} palceholder, + end of the command.</p></blockquote><ul><li>find folder -type f -exec chmod 664 {} +</li><li>find folder -perm 664</li><li>find . -type f -name “*.jpg”</li><li>find . -type f -name “*.jpg” -maxdepth 1, searched 1 level down</li><li>find . -type f -name “*.jpg” -maxdepth 1 -exec rm {} +, delete serched files</li></ul><h1 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h1><h2 id="Grep-single-file"><a href="#Grep-single-file" class="headerlink" title="Grep single file"></a>Grep single file</h2><blockquote><p>searched text</p></blockquote><ul><li>grep “text_you_want_search” filename.txt</li><li>grep -w “text_you_want_search” filename.txt, have to match all words</li><li>grep -wi “text_you_want_search” filename.txt, igore the lowcase and uppearcse.</li><li>grep -win “text_you_want_search” filename.txt, get info about the line number</li><li>grep -win -B 4 “text_you_want_search” filename.txt, return the context about the searched words, 4 line, behind</li><li>grep -win -A 4 “text_you_want_search” filename.txt, return the context about the searched words, 4 line, ahead</li><li>grep -win -C 4 “text_you_want_search” filename.txt, return the context about the searched words, 4 line, two line before and two behind.</li></ul><h2 id="Grep-multi-file"><a href="#Grep-multi-file" class="headerlink" title="Grep multi file"></a>Grep multi file</h2><ul><li>grep -win “text_” ./*, all file</li><li>grep -win “text_” ./*.txt, txt file</li><li>grep -winr “text” ./ , search all subdir</li><li>grep -wirl “text” ./ , no need match info, just file list</li><li>grep -wirc “text” ./ , show matched number in eatch file</li></ul><h2 id="Grep-command-history"><a href="#Grep-command-history" class="headerlink" title="Grep command history"></a>Grep command history</h2><ul><li>history | grep “git commit”</li><li>history | grep “git commit” | grep “dotfile”</li></ul><h2 id="Grep-rgx"><a href="#Grep-rgx" class="headerlink" title="Grep rgx"></a>Grep rgx</h2><ul><li>grep -P “\d{3}-\d{3}-\d{4}” file.txt, work well in linux, mac need to config, I configed</li></ul><h1 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h1><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><ul><li>curl url</li><li>curl <a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a></li><li>curl http:***/json_file<ul><li>curl -i http:***/json_file, details info about the get</li></ul></li><li>curl http:***/method<ul><li>curl -d “first=name&amp;last=lastname” http:***/method, d for data, Post request</li><li>curl -X PUT -d “first=name&amp;last=lastname” http:***/method, d for data, Pust request</li><li>curl -X DELETE http:***/method, delete request</li></ul></li></ul><h2 id="Verify"><a href="#Verify" class="headerlink" title="Verify"></a>Verify</h2><blockquote><p>could not verify your access ?</p></blockquote><ul><li>curl -u username:password http://***, Auth</li></ul><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><blockquote><p>Download file</p></blockquote><ul><li>curl http://***/folder, return binary file , error</li><li>curl -o filename.jpg http://***/folder, sucess</li></ul><blockquote><p>Saving large json file</p></blockquote><ul><li>curl -o file_name.json http:/.api.the_url*</li></ul><h1 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h1><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><blockquote><p>aviable in Mac, debian-based linux need to install</p></blockquote><ul><li>apt-get install rsync</li><li>yum install rsync</li></ul><h2 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h2><ul><li>rsync folder1/* backup/ , sync fils to backup folder,will skping the subfolder’s file, but affected subfolder</li><li>rsync -r folder1/* backup/ , including subfolder’s file</li><li>rsync -r folder1 backup/, sync folder, not content in it</li></ul><h2 id="Check-chage-before-run"><a href="#Check-chage-before-run" class="headerlink" title="Check chage before run"></a>Check chage before run</h2><ul><li>rsync -a –dry-run folder1/* backup/, check before the command run, now view showed<ul><li>rsync -av –dry-run folder1/* backup/, auto view</li></ul></li></ul><h2 id="Source-folder-has-new-file"><a href="#Source-folder-has-new-file" class="headerlink" title="Source_folder has new file"></a>Source_folder has new file</h2><ul><li>rsync -av –delete –dry-run original/ backup/, check, be careful !</li></ul><h2 id="Do-it-in-local-and-host"><a href="#Do-it-in-local-and-host" class="headerlink" title="Do it in local and host"></a>Do it in local and host</h2><ul><li>rsync -zaP -p local_folder username@ip:~/public/, z for compress, a for all, P for tarnsfer in internet</li><li>rsync 0zaP username@ip:~/public/file ~/Downloads/, revers</li></ul><h1 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h1><ul><li>crontab -l, list the crons</li></ul><blockquote><p>set your editor to nano, default vim</p></blockquote><ul><li><p>export EDITOR=/user/bin/nano</p></li><li><p>crontab -e, open editor</p><ul><li>press i to input</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Algorhythm for schuel you task with time</span><br><span class="line"></span><br><span class="line"># ┌───────────── minute (0 - 59)</span><br><span class="line"># │ ┌───────────── hour (0 - 23)</span><br><span class="line"># │ │ ┌───────────── day of month (1 - 31)</span><br><span class="line"># │ │ │ ┌───────────── month (1 - 12)</span><br><span class="line"># │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday;</span><br><span class="line"># │ │ │ │ │                                       7 is also Sunday on some systems)</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># │ │ │ │ │</span><br><span class="line"># * * * * *  command_to_execute</span><br></pre></td></tr></table></figure><ul><li><a href="https://youtu.be/QZJ1drMQz1A" target="_blank" rel="noopener">More in</a></li><li><a href="https://github.com/CoreyMSchafer/code_snippets/blob/master/Cron-Tasks/snippets.txt" target="_blank" rel="noopener">snippets</a></li><li><a href="https://crontab.guru/" target="_blank" rel="noopener">tools to make a cron job</a></li></ul><h1 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h1><ul><li>PS1=”customer_namae”; , change the name, temporary</li><li>ls -la, show dot file, find .bash_profile</li></ul><h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><ol><li>mv .bash_profile backup_folder</li><li>mv .bashrc back_folder</li></ol><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><ol><li>cd !</li><li>touch .bash_profile</li><li>touch .bashrc</li><li>subl .bash_profile -&gt; echo “Hello from bash_profile”, subl for sublime</li><li>subl .bashrc -&gt; echo “Hello from bashrc”</li></ol><blockquote><p>bash_profile, run every time you open terminal, or ssh login to some machine. when you input bash, you will get the print from bashrc.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [-f ~/.bashrc]; then</span><br><span class="line">source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="config-terminal-view"><a href="#config-terminal-view" class="headerlink" title="config terminal view"></a>config terminal view</h2><p>You can add the keywords in below list to the ps1, to show some extra info.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># config display name</span><br><span class="line">ps1 = &quot;-&gt;&quot;; export PS1</span><br><span class="line"></span><br><span class="line"># if you config command is too long, you can += it</span><br><span class="line">ps1 += &quot;some_other_config&quot;</span><br><span class="line"></span><br><span class="line"># add the infomation of you computer, or time</span><br><span class="line"></span><br><span class="line">\u: usernmae</span><br><span class="line">\h: hostname</span><br><span class="line">\n: new line</span><br><span class="line">\t: the current time</span><br><span class="line">\w: current working directory</span><br><span class="line">\W: base name of current working directory</span><br></pre></td></tr></table></figure><p>In shell, you can print with {}, like :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># This will print the pwd&apos;s output in shell.</span><br><span class="line">You current diretory is $(pwd)</span><br><span class="line"></span><br><span class="line"># change color, no stop, all font will set to orange</span><br><span class="line">echo &quot;$(tput setaf 166) This is orange&quot;</span><br><span class="line"></span><br><span class="line"># set a stop of the change color command</span><br><span class="line">echo &quot;$(tput setaf 166) This is orange $(tput sgr0)&quot;</span><br></pre></td></tr></table></figure><h1 id="Mac-OS-Keyboard-Shortcuts"><a href="#Mac-OS-Keyboard-Shortcuts" class="headerlink" title="Mac OS Keyboard Shortcuts"></a>Mac OS Keyboard Shortcuts</h1><ul><li>using arrow key to view the history command</li><li>ctrl + a, jump to the begining of line</li><li>ctrl + e, jump to the end</li><li>option + left/rithg, jump by words</li><li>holding option key, move mourse to the point you want to go</li><li>ctrl + u, delete code before the point</li><li>ctrl + k, delete everything after the cursor</li><li>!fi, re run the command in history that begins with fi</li><li>ctrl+ r, search the history command that you inputed</li><li>ctrl + l, clean the screen, without clean the history output</li><li>ctrl + k, clearn the screen ,including the history output</li></ul><h1 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h1><ol><li>sudo vim .bash_profile</li><li>alias dt = ‘cd !/Desktop/‘</li><li>killall Finder</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">alias testhost=&apos;ssh root@8.8.8.8 -p 22&apos;</span><br></pre></td></tr></table></figure><h1 id="generate-key"><a href="#generate-key" class="headerlink" title="generate key"></a>generate key</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 生成本地秘钥，一路回车即可</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"># 上传生成的秘钥到服务器</span><br><span class="line">scp ~/.ssh/id_rsa.pub testhost:~/.ssh/</span><br><span class="line"># 使用以下命令将 id_rsa.pub 更名为 authorized_keys</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br><span class="line"># 修改权限</span><br><span class="line">chmod 700 ~/.ssh/</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;常用命令的cheatsheet，如果想了解更多理论部分，请参考之前的文章&lt;a href=&quot;http://wittyfans.com/coding/Linux阅读笔记.html&quot;&gt;Linux阅读笔记&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用命令整理</title>
    <link href="http://wittyfans.com/writing/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86.html"/>
    <id>http://wittyfans.com/writing/常用命令整理.html</id>
    <published>2019-06-07T13:47:33.000Z</published>
    <updated>2019-06-07T13:47:33.242Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Excel笔记P1</title>
    <link href="http://wittyfans.com/coding/Excel%E7%AC%94%E8%AE%B0P1.html"/>
    <id>http://wittyfans.com/coding/Excel笔记P1.html</id>
    <published>2019-06-07T13:25:55.000Z</published>
    <updated>2019-06-07T13:31:53.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要记录我在YouTube上学习到的Excel知识，没有整理所以顺序比较乱。</p></blockquote><a id="more"></a><h1 id="1-省时的快捷键"><a href="#1-省时的快捷键" class="headerlink" title="1. 省时的快捷键"></a>1. 省时的快捷键</h1><ul><li>alt + pageup/pagedown, 左右移动光标</li><li>ctrl + 右/左, 将光标移动到列尾/列首</li><li>ctrl + 上/下，将光标移动到行首/行尾</li><li>如何根据列名快速找到列？<ol><li>选择cell</li><li>shift + space 选择整行</li><li>ctrl + f </li><li>输入名字搜索</li></ol></li></ul><blockquote><p>我电脑按shift + space 没反应，有冲突？ </p></blockquote><ul><li>F2，快速编辑，在excel中，点击cell不会自动编辑，需要双击，你也可以通过按f2开始快速编辑<ul><li>开始快速编辑后，在右下角会显示edit模式，这时候如果你编辑公式，左右光标会在公式之间移动，如果你想要选择cell作为公式的参数呢？再按一次将edit模式变成enter模式即可</li></ul></li></ul><h1 id="2-高级复制粘贴"><a href="#2-高级复制粘贴" class="headerlink" title="2. 高级复制粘贴"></a>2. 高级复制粘贴</h1><h2 id="拖动粘贴"><a href="#拖动粘贴" class="headerlink" title="拖动粘贴"></a>拖动粘贴</h2><ol><li>选中值</li><li>移动光标至框边缘出现四向箭头</li><li>右键鼠标按住不放</li><li>拖动到其它位置</li><li>松开选择粘贴类型</li></ol><h2 id="粘贴选择多格式"><a href="#粘贴选择多格式" class="headerlink" title="粘贴选择多格式"></a>粘贴选择多格式</h2><ol><li>正常复制</li><li>按 ALT+E+S,打开粘贴格式面板（Mac使用contrl+command+v）<ol><li>自定义粘贴</li><li>比如按v -&gt; 回车，只粘贴值</li></ol></li></ol><p>如果你的键盘有menu键，可以之间使用memu+v粘贴值。</p><h1 id="3-在两个表中使用VLookup-Hlookup函数"><a href="#3-在两个表中使用VLookup-Hlookup函数" class="headerlink" title="3. 在两个表中使用VLookup/Hlookup函数"></a>3. 在两个表中使用VLookup/Hlookup函数</h1><p>如果你表的header在上面，使用vlookup函数，如果你的header在左边，那么hlookup也许更适合你。</p><h2 id="Vertical-Look-UP"><a href="#Vertical-Look-UP" class="headerlink" title="Vertical Look UP"></a>Vertical Look UP</h2><blockquote><p>V stands for Vertical look up, not value, as there is a Hlookup = horzizontal；大家可能把vlookup函数理解为value look up，其实它是 vertical lookup</p></blockquote><p>你只能根据左边的列找出右边列的值，而不可以通过根据右边的列来找出左边列的值。</p><p>先将两个表摊开放到一起看，选择review -&gt; Arrange all -&gt; vertical</p><p>使用vlookup函数，它需要四个参数：</p><ol><li>查什么？选中那个cell</li><li>去哪里查，选中整个范围</li><li>查所选数据中的第几列，需要注意，excel从1开始编号</li><li>精确匹配还是近似匹配（近似匹配：查a，那么abc也会被返回）</li></ol><p>按回车，就可以成功的找出你需要的值。</p><h2 id="Horzizontal-Look-UP"><a href="#Horzizontal-Look-UP" class="headerlink" title="Horzizontal Look UP"></a>Horzizontal Look UP</h2><p>使用hlookup函数，它需要四个参数：</p><ol><li>查什么？选中那个cell</li><li>去哪里查，选中整个范围</li><li>查所选数据中的第几行，需要注意，excel从1开始编号</li><li>精确匹配还是近似匹配（近似匹配：查a，那么abc也会被返回）</li></ol><h1 id="4-如何把两列值相加"><a href="#4-如何把两列值相加" class="headerlink" title="4. 如何把两列值相加"></a>4. 如何把两列值相加</h1><p>假设两个cell的值类型为文本(Text)，也就是字符串，可以直接将两个值使用 &amp; 结合，如果不是文本，你可以使用Text函数完成，即:Text(值的坐标,0).</p><h1 id="5-透视表"><a href="#5-透视表" class="headerlink" title="5. 透视表"></a>5. 透视表</h1><p>我是在Python中使用过 pivot_table 才知道 pivot 操作的意思，接触 excel 后才知道这叫透视表，有些人也叫这个数据剖析.</p><p>anyway, 今天来记录一下透视表的使用。</p><p>我使用的是 excel 2016 英文版，微软的 excel 界面不会差太多，打开excel你的界面应该和我差不多。</p><p>首先你需要打开你的表，然后选择你需要透视的数据：</p><p><img src="https://i.loli.net/2019/06/04/5cf65f311a5c943124.png" alt="pivot_table0.png"></p><h1 id="6-我只要透视后的排名前十的数据"><a href="#6-我只要透视后的排名前十的数据" class="headerlink" title="6. 我只要透视后的排名前十的数据"></a>6. 我只要透视后的排名前十的数据</h1><p>点击 cell 旁边的 sort 按钮，点击 value filter, 选择最下面的 top 10， 当然你也可以在这里做其他的filter操作。</p><h1 id="7-安装-excel-插件"><a href="#7-安装-excel-插件" class="headerlink" title="7 安装 excel 插件"></a>7 安装 excel 插件</h1><p> excel的插件是 xlam 格式的文件，你不可以直接双击打开，需要打开excel.</p><p> file -&gt; add-ins -&gt; manage -&gt; go</p><p> 这时候可以看到你安装好了的和没安装的插件，然后点击 browser，找到你的插件，点击 ok 即可。</p><p> 插件会每次都随着excel的打开而启动，也许有时候你并不需要这样，你可以在 Developer, add-ins 里面 把这个插件的选项 unchec。</p><h1 id="8-完全卸载excel插件"><a href="#8-完全卸载excel插件" class="headerlink" title="8. 完全卸载excel插件"></a>8. 完全卸载excel插件</h1><ol><li>取消选择插件。</li><li>file -&gt; options -&gt; add-ins</li><li>选择需要卸载的插件，找到路径</li><li>打开该路径，删除该插件</li><li>打开选择插件按钮，重新选择，excel会提示无法找到，是否删除，点击确定</li></ol><h1 id="9-插件不见了？重新加载插件"><a href="#9-插件不见了？重新加载插件" class="headerlink" title="9. 插件不见了？重新加载插件"></a>9. 插件不见了？重新加载插件</h1><ol><li>file - options - add-ins</li><li>manage -&gt; disabled items -&gt; go</li></ol><h1 id="10-做一个drop-down-memu（下拉菜单）"><a href="#10-做一个drop-down-memu（下拉菜单）" class="headerlink" title="10. 做一个drop down memu（下拉菜单）"></a>10. 做一个drop down memu（下拉菜单）</h1><p>下拉菜单可以让你在填写cell中的值的时候，有一些选择，不用手动填写也避免了错误的输入，发现一个插件 List Search（免费），可以很简单的创建下拉菜单。</p><h1 id="11-做一个-Table-of-contents-Gallery"><a href="#11-做一个-Table-of-contents-Gallery" class="headerlink" title="11. 做一个 Table of contents Gallery"></a>11. 做一个 Table of contents Gallery</h1><p>我也不知道如何翻译这个词，反正就是把你所有做好的图，整齐的放在第一页做一个预览图，点击后就可以跳转到子页面，类似这样：</p><p><img src="https://i.loli.net/2019/06/04/5cf6780d097a640476.jpeg" alt="56D77E73-AE1E-4F47-853D-55DEFD291D38.jpeg"></p><p>Tab Hound, 需要收费，有兴趣的可以找到这个文章研究一下宏的用法。</p><h1 id="12-过滤器"><a href="#12-过滤器" class="headerlink" title="12. 过滤器"></a>12. 过滤器</h1><p>点击任意的cell，ctrl+shift+L, 启动/关闭过滤器。</p><p>在过滤器中，你可以按照一列中的值去过滤整个表（不是删除，只是隐藏），你也可以在里面排序。</p><p>推荐数据转换成 Table 分析，这样配合过滤器使用，在你插入行和列的时候，exel会自动将你的操作与filter关联起来，利用公式求值的时候，table会自动填充表中其他row的值。</p><p>在table中，你也可以轻松的添加 total 的行，excel会自动帮你计算（不包括隐藏的值），可以选择求和，求平均等操作。</p><p>table还可以对同一个sheet中的两个table一起过滤。</p><p>一些常用的filter快捷键：</p><ul><li>alt + 下箭头，就可以快速调出filter的菜单</li><li>alt + 下 + e, 调出filter菜单然后开始输入文字搜索</li><li>alt + 下 + c, 清除当前列的 filter条件</li><li>shfit + alt + 下，在任意cell调出filter菜单</li><li>alt + 下 + f + e + enter, 快速找出为空的行</li></ul><p>最舒服的是根据当前选择的值进行筛选:</p><ul><li>右键-&gt; filter -&gt; filter by selected cell’s value</li><li>快捷键：menu key + E + V (Windows)</li></ul><h2 id="多列过滤"><a href="#多列过滤" class="headerlink" title="多列过滤"></a>多列过滤</h2><p>过滤器默认是只针对这些看得见的数据的，所以可以很简单的进行多列过滤。你可想象，每次进行一个过滤器的应用，都是给你看得见的结果加了一个条件，在编程的世界里，也就是进行了and操作。</p><p>但如果你想要or操作呢？</p><p>你可以借助or公式来达到这个目的：</p><p><img src="https://i.loli.net/2019/06/04/5cf68eafbf80710954.jpeg" alt="or"></p><p>你可以直接将鼠标移动到filter button上，查看当前的条件，而不需要进去菜单。</p><h2 id="重复值过滤"><a href="#重复值过滤" class="headerlink" title="重复值过滤"></a>重复值过滤</h2><p>你想要找某一列中重复的值，然后把他们放在一起对比。</p><ol><li>选择列</li><li>conditional formating, highlight cell</li><li>筛选，sort</li></ol><h2 id="根据已有的list过滤"><a href="#根据已有的list过滤" class="headerlink" title="根据已有的list过滤"></a>根据已有的list过滤</h2><ol><li>选择列</li><li>打开filter菜单</li><li>搜索到你需要的关键字</li><li>选择第二个，同时加上“添加”选项</li></ol><h1 id="13-Power-Query"><a href="#13-Power-Query" class="headerlink" title="13. Power Query"></a>13. Power Query</h1><h2 id="Tidy-Data"><a href="#Tidy-Data" class="headerlink" title="Tidy Data"></a>Tidy Data</h2><p>在利用Python Pandas分析数据的时候，我们最开始一般都需要将数据转化成容易分析的格式，也就是大家所说的Tiday Data, 如果你不知tidy data的定义，那么可以参考<a href="https://vita.had.co.nz/papers/tidy-data.pdf" target="_blank" rel="noopener">这篇</a>文章。</p><p>那么在Exce中如何进行这样的操作呢？今天发现可以利用 Power Query 实现这个需求。</p><p>如果你的Excel版本是2016，那么Power Query就已经内置在其中了，如果是比较早的版本，那么可以在<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=39379" target="_blank" rel="noopener">这个</a>页面下载到Power Query。</p><p>同时微软也提供了 Power Query 的<a href="https://support.office.com/en-us/article/power-query-overview-and-learning-ed614c81-4b00-4291-bd3a-55d80767f81d" target="_blank" rel="noopener">教程</a>.</p><p>要 unpivolt 你的数据，</p><ol><li>选择你的数据</li><li>Insert -&gt; Table, 将你的数据转化成Table</li><li>再点击Data -&gt; From Table，进入 Power Query 的编辑界面</li><li>选择你需要操作的列</li><li>点击 Transform -&gt; Unpivot Columns (如果你没看到这个选项，将excel拖宽一点)</li></ol><p>这样就完成了你数据的转化，你还可以对 unpivot 后的数据进行过滤操作。</p><h2 id="Unpivot-Columns"><a href="#Unpivot-Columns" class="headerlink" title="Unpivot Columns"></a>Unpivot Columns</h2><p>假设你的数据是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 a,b</span><br><span class="line">2 b,c</span><br></pre></td></tr></table></figure><p>然后你想要把它们分开，就像这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 a</span><br><span class="line">1 b</span><br><span class="line">2 b</span><br><span class="line">2 c</span><br></pre></td></tr></table></figure></p><p>基本操作和上面的是一样的，</p><ol><li>选择data -&gt; from table</li><li>home-&gt; spilt columns -&gt; by delimiter -&gt; ok</li><li>删除多余的列</li><li>transform -&gt; unpivot columns</li></ol><h2 id="根据已有的数据计算百分比"><a href="#根据已有的数据计算百分比" class="headerlink" title="根据已有的数据计算百分比"></a>根据已有的数据计算百分比</h2><ol><li>输入总数</li><li>输入函数开始计算，在这一步需要注意关闭 Generate GetPirovtData选项，方法是:<ol><li>点击需要计算的值</li><li>analyse-&gt; options 去掉Generate GetPirovtData的钩</li><li>输入函数计算值</li><li><strong>control + shift 5</strong> 快速转换成百分比</li></ol></li></ol><h1 id="14-如何根据现有数据绘图"><a href="#14-如何根据现有数据绘图" class="headerlink" title="14. 如何根据现有数据绘图"></a>14. 如何根据现有数据绘图</h1><ol><li>选择你要绘制图的数据</li><li>insert table，选择图类型</li><li>选择labels<ol><li>select data</li><li>edite labels</li><li>选择label的区间</li></ol></li></ol><h1 id="15-如何制作excel选择器"><a href="#15-如何制作excel选择器" class="headerlink" title="15. 如何制作excel选择器"></a>15. 如何制作excel选择器</h1><p>我们在预览数据的时候，可以通过过滤器(Filter)来过滤我们看到的数据，这时候可以在过滤器标签上看到它显示为 Multiple Items, 但是我们并不能很直观的看到它到底选择了什么数据项。</p><p>为了让你所选的项目一目了然，我们可以制作一个多选菜单：</p><ol><li>Add a Slicer</li></ol><p>首先，先将你的数据透视好，然后在你透视操作的基列上面点击，再打开analyse选项卡，插入 Slicer, 选择你需要选择的列，然后你就可以看到 slicer 出现，你可以在这里选择过滤项目。</p><p>但是如何知道你选择了哪些项目呢？也就是说如果你需要在另一个表中使用你选过哪些选项要怎么实现呢？</p><p>你可以copy一份你已经透视过的表（需要注意保留filter），然后在 pivot 选项中，将除了filte的其他值全部删掉，这样你在 slicer中选择的时候，这个list也会实时更新。</p><h1 id="16-excel编程"><a href="#16-excel编程" class="headerlink" title="16. excel编程"></a>16. excel编程</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function func_name(arg as arg_type) as returned_type</span><br><span class="line">    func_name = caculated_value</span><br><span class="line">end function</span><br><span class="line"></span><br><span class="line">用中文解释一遍：</span><br><span class="line"></span><br><span class="line">function 函数名(参数 as 参数数据类型) as 返回值类型</span><br><span class="line">    函数名= 计算的结果</span><br><span class="line">function</span><br></pre></td></tr></table></figure><ul><li>function 是关键字，用来定义函数</li><li>end function 用来标记函数的结束</li><li>excel 的函数没有类似编程语言中的return关键字，只需要把计算结果赋值给函数名即可完成结果的返回</li></ul><h2 id="参考python语法对比"><a href="#参考python语法对比" class="headerlink" title="参考python语法对比"></a>参考python语法对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># python</span><br><span class="line">a = 10</span><br><span class="line"></span><br><span class="line"># excel</span><br><span class="line">dim a as 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># if 语句</span><br><span class="line"># python</span><br><span class="line">if a == b:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"># excel</span><br><span class="line"></span><br><span class="line">if a==b then</span><br><span class="line">    ...</span><br><span class="line">else</span><br><span class="line">    ....</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><h1 id="17-锁定某个Cell"><a href="#17-锁定某个Cell" class="headerlink" title="17. 锁定某个Cell"></a>17. 锁定某个Cell</h1><ol><li>选中所有其他的cell，formate -&gt; proctet -&gt; 取消选中</li><li>在sheet name右键，保护该表</li><li>设置密码</li></ol><p>锁定某个cell的好处：</p><p>假设你按照行统计，用扫码枪去扫描自动输入，果excel会自动换行，某一行你想要直接跳过，就可以设置锁定不允许选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要记录我在YouTube上学习到的Excel知识，没有整理所以顺序比较乱。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="data analyse" scheme="http://wittyfans.com/tags/data-analyse/"/>
    
      <category term="数据分析" scheme="http://wittyfans.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell通过http, https, 和ftp下载文件</title>
    <link href="http://wittyfans.com/coding/PowerShell%E9%80%9A%E8%BF%87Http-HTTPS-%E5%92%8CFTp%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html"/>
    <id>http://wittyfans.com/coding/PowerShell通过Http-HTTPS-和FTp下载文件.html</id>
    <published>2019-04-08T14:13:44.000Z</published>
    <updated>2019-04-08T14:29:56.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用 <em>PowerShell</em> 发起请求，不仅可以下载文件，还可以利用管道对文件进行解析，这一点比 <em>CMD</em> 命令行和 <em>Linux</em> 下的 <em>wget</em> 还要好用。</p></blockquote><a id="more"></a><h1 id="内网环境下"><a href="#内网环境下" class="headerlink" title="内网环境下"></a>内网环境下</h1><p>如果你工作的环境主要是通过 <em>Server Message Block (SMB)</em> 协议来传输文件，那么可以直接在 <em>powershell</em> 中使用 <em>copy-item</em> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy-Item -Source \\server\share\file -Destination C:\path\</span><br></pre></td></tr></table></figure><p>如果你在公司的内网（域环境）下，那么这个命令挺适合你，如果你是要下载外网或者 <em>Internet</em> 上面的数据，事情就变得复杂一点了。</p><h1 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h1><h2 id="任意版本-powershell"><a href="#任意版本-powershell" class="headerlink" title="任意版本 powershell"></a>任意版本 <em>powershell</em></h2><p>如果你用的power shell 2.x 的版本，你需要使用 <em>new-object</em> 配合 <em>System.Net.WebClient</em> 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$WebClient = New-Object System.Net.WebClient</span><br><span class="line">$WebClient.DownloadFile(&quot;https://www.wittyfans.com/file&quot;,&quot;C:\path\file&quot;)</span><br></pre></td></tr></table></figure><h2 id="powershell-版本3-x-以上"><a href="#powershell-版本3-x-以上" class="headerlink" title="powershell 版本3.x 以上"></a><em>powershell</em> 版本3.x 以上</h2><p>如果是 <em>powershell 3.x</em>, 可以用 <em>Invoke-WebRequest</em>命令。Invoke-WebRequest 和Linux其实还有一些关系。它比 <em>wget</em> 还要好用一些，因为它不仅可以下载，而且可以对文件进行解析。</p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -Uri &quot;http://www.wittyfans.com&quot; -OutFile &quot;C:\path\file&quot;</span><br></pre></td></tr></table></figure><ul><li>默认会下载这个网页，所以如果你指定的下载路径只是一个文件夹，<em>powershell</em>会提示找不到路径，这时候你需要指定路径加文件名.</li><li>如果你省略本地路径，则<em>powershell</em>会默认使用脚本所在目录的路径</li></ul><p>举例：</p><p>下载<em>sublime</em>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -uri &quot;https://download.sublimetext.com/Sublime%20Text%20Build%203207%20x64%20Setup.exe&quot; -OutFile &quot;C:\Users\wittyfans\Desktop\sublime.exe&quot;</span><br></pre></td></tr></table></figure><p><em>Invoke-WebRequest</em> 默认把下载的东西传输给管道，如果你需要保存文件，必须要指定 <em>outfile</em> 参数。而且你还可以在管道中后面去分析这个文件，如果你传输的是二进制文件，<em>power shell</em>会默认以文本的方式处理，这时候你就没办法分析了，不过你可以增加一个参数，只分析文本内容，你需要这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest &quot;http://www.wittyfans.com&quot; | Select-Object -ExpandProperty Content | Out-File &quot;file&quot;</span><br></pre></td></tr></table></figure><p>如果你想要保存所有管道中的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest &quot;http://www.wittyfans.com&quot; -OutFile &quot;file&quot; -PassThru | Select-Object -ExpandProperty Content</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如果你的下载需要验证身份，<em>powershell</em>不会提示你，除非你指定了用户名，此时<em>powershell</em>会提示你输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">Invoke-WebRequest -Uri https://www.wittyfans.com/ -OutFile C:&quot;\path\file&quot; -Credential &quot;yourUserName&quot;</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line">$Credentials = Get-Credential</span><br><span class="line">Invoke-WebRequest -Uri &quot;https://www.wittyfans.com&quot; -OutFile &quot;C:\path\file&quot; -Credential $Credentials</span><br></pre></td></tr></table></figure><p>你可以使用<em>-UseDefaultCredentials</em> 参数来使用当前用户的凭据，这样就可以省略 <em>Credential</em> 参数。</p><p>也可以使用弹窗来要求输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$client = new-object System.Net.WebClient</span><br><span class="line">$client.Credentials = Get-Credential</span><br><span class="line">$client.DownloadFile(&quot;http://i.imgur.com/JnphmRt.jpg&quot;,&quot;C:\Users\Fatima Wahab\Desktop\cat.jpg&quot;)</span><br></pre></td></tr></table></figure><p>注意检查资源的路径是对的，如果你的路径是该网站的首页，那么就会出错。</p><p>为了确保安全，建议你使用 <em>https</em> 验证，如果只是基本的验证方式，你的密码可能会被抓包分析出来。</p><p>这种下载的验证方式之适用于那些服务器自己管理凭据的情况，现今很多的公司都是用 <em>content management system (CMS)</em> 来验证用户，这时候你就需要使用<em>powershell</em>填写一些表单再提交,用我写的一个函数来举个例子,这个函数只是验证身份，没有下载的动作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function login-in($userName,$userPassWord)&#123;</span><br><span class="line">    # 请求并保存session</span><br><span class="line">    $R=Invoke-WebRequest &quot;the_url&quot; -SessionVariable fb</span><br><span class="line"></span><br><span class="line">    # 填写表单信息</span><br><span class="line">    $Form = $R.Forms[0]</span><br><span class="line">    $Form.Fields[&quot;account&quot;]=$userName</span><br><span class="line">    $Form.Fields[&quot;password&quot;] = $userPassWord</span><br><span class="line">    $Form.Fields[&quot;signIn&quot;] = &quot;Sign+in&quot;</span><br><span class="line"></span><br><span class="line">    # 提交 </span><br><span class="line">    $R=Invoke-WebRequest -Uri (&quot;the_url&quot; + $Form.Action) -WebSession $FB -Method POST -Body $Form.Fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要安全一些，最好不要使用<em>FTP</em>的方式，建议用<em>SFTP</em> 或者 <em>SCP</em>，但 <em>Invoke-WebRequest</em> 不支持这些协议，你可以安装一些第三方的库来实现，现在已经有相关的库实现了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.addictivetips.com/windows-tips/how-to-download-a-file-with-a-powershell-command-in-windows-10/" target="_blank" rel="noopener">How To Download A File With A PowerShell Command In Windows 10</a></li><li><a href="https://stackoverflow.com/questions/51225598/downloading-a-file-with-powershell" target="_blank" rel="noopener">StackOverFlow上关于 Downloading a file with powershell 的回答</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用 &lt;em&gt;PowerShell&lt;/em&gt; 发起请求，不仅可以下载文件，还可以利用管道对文件进行解析，这一点比 &lt;em&gt;CMD&lt;/em&gt; 命令行和 &lt;em&gt;Linux&lt;/em&gt; 下的 &lt;em&gt;wget&lt;/em&gt; 还要好用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="helpdesk" scheme="http://wittyfans.com/tags/helpdesk/"/>
    
      <category term="powershell" scheme="http://wittyfans.com/tags/powershell/"/>
    
      <category term="windows" scheme="http://wittyfans.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 统计工作数据</title>
    <link href="http://wittyfans.com/coding/Pandas-%E7%BB%9F%E8%AE%A1%E5%B7%A5%E4%BD%9C%E6%95%B0%E6%8D%AE.html"/>
    <id>http://wittyfans.com/coding/Pandas-统计工作数据.html</id>
    <published>2019-03-28T12:19:18.000Z</published>
    <updated>2019-03-28T12:20:58.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用Pandas统计工作中的数据，包括数据导入、时间序列处理、loc方法，绘图等等。</p></blockquote><a id="more"></a><h1 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h1><p><img src="https://i.loli.net/2019/03/28/5c9cb955919aa.png" alt="import_data.png"></p><ul><li>因为从txt导入数据，所以固定sep为，</li><li>header即没有头部</li><li>爬取日期数据则会将string类型的date自动转化为date类型，方便整理</li></ul><h1 id="设置index"><a href="#设置index" class="headerlink" title="设置index"></a>设置index</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwdlog = pwdlog.set_index(&apos;date&apos;)</span><br></pre></td></tr></table></figure><p>设置index方便索引，对时间进行切片。</p><h1 id="探索数据"><a href="#探索数据" class="headerlink" title="探索数据"></a>探索数据</h1><h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb919e4393.png" alt="describe.png"></p><h2 id="按天数计算数据"><a href="#按天数计算数据" class="headerlink" title="按天数计算数据"></a>按天数计算数据</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb9561af75.png" alt="resample_d.png"></p><p>resample方法将按照时间区间统计数量，count方法为统计，如果是sum则为相加，另也有机酸平均值等方法可选，resample可以将天数缩小为时间，对于的值将会被填充为你想要设置的值，也可以将分钟，小时等统计成天数，周数，工作日等等。</p><h2 id="谁的数据最多？"><a href="#谁的数据最多？" class="headerlink" title="谁的数据最多？"></a>谁的数据最多？</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb956112b1.png" alt="reset_numbers.png"></p><p>to_frame方法主要将这些数据转化为frame。</p><h2 id="哪一天的数据最多？"><a href="#哪一天的数据最多？" class="headerlink" title="哪一天的数据最多？"></a>哪一天的数据最多？</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb9561cd6c.png" alt="reset_order_by_day.png"></p><h2 id="探索2-13这一天的数据"><a href="#探索2-13这一天的数据" class="headerlink" title="探索2/13这一天的数据"></a>探索2/13这一天的数据</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb9553474b.png" alt="2_13_loc .png"></p><p>可以看到一共收到133个用户改密码请求。</p><h2 id="2-13谁处理的请求最多"><a href="#2-13谁处理的请求最多" class="headerlink" title="2/13谁处理的请求最多"></a>2/13谁处理的请求最多</h2><p><img src="https://i.loli.net/2019/03/28/5c9cb95556338.png" alt="2_13_loc_it.png"></p><h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><h1 id="按天"><a href="#按天" class="headerlink" title="按天"></a>按天</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwdlog.resample(&apos;d&apos;).count()[&apos;name&apos;].plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/03/28/5c9cb955da58b.png" alt="plot_by_day.png"></p><h1 id="按小时"><a href="#按小时" class="headerlink" title="按小时"></a>按小时</h1><p><img src="https://i.loli.net/2019/03/28/5c9cb955dd364.png" alt="plot_h.png"></p><h1 id="按分钟"><a href="#按分钟" class="headerlink" title="按分钟"></a>按分钟</h1><p><img src="https://i.loli.net/2019/03/28/5c9cb955e96ec.png" alt="plot_m.png"></p><h1 id="按名字"><a href="#按名字" class="headerlink" title="按名字"></a>按名字</h1><p><img src="https://i.loli.net/2019/03/28/5c9cb95565cb9.png" alt="fz.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用Pandas统计工作中的数据，包括数据导入、时间序列处理、loc方法，绘图等等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="bigdata" scheme="http://wittyfans.com/tags/bigdata/"/>
    
      <category term="pandas" scheme="http://wittyfans.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>NumPy操作数组</title>
    <link href="http://wittyfans.com/coding/NumPy%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84.html"/>
    <id>http://wittyfans.com/coding/NumPy操作数组.html</id>
    <published>2019-02-09T15:00:40.000Z</published>
    <updated>2019-02-09T16:24:25.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对数组的操作是 <em>NumPy</em> 中很重要的一部分，了解这些内置的方法，可以让你的效率事半功倍。</p></blockquote><a id="more"></a><h1 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h1><h2 id="np-meshgrid方法"><a href="#np-meshgrid方法" class="headerlink" title="np.meshgrid方法"></a>np.meshgrid方法</h2><p>如果你给meshgrid两个一位数组，A像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[𝑎1,𝑎2,𝑎3]</span><br></pre></td></tr></table></figure><p>B像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[𝑏1,𝑏2,𝑏3]</span><br></pre></td></tr></table></figure><p>如果你运行 <em>np.meshgrid(A,B)</em>,那么你会得到一个嵌套数组，里面分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[𝑎1,𝑎1,𝑎1],[𝑎2,𝑎2,𝑎2],[𝑎3,𝑎3,𝑎3]]</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[𝑏1,𝑏1,𝑏1],[𝑏2,𝑏2,𝑏2],[𝑏3,𝑏3,𝑏3]]</span><br></pre></td></tr></table></figure><p>By adding these two arrays together, we can create the 2D array containing, as its elements, every combination of sums between the numbers in the original elements. Arrays such as linspace and arange are typically used to constuct N-D arrays used to plot in 3 dimensions.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import plotly.plotly as py</span><br><span class="line">import plotly.graph_objs as go</span><br><span class="line"></span><br><span class="line">x = np.arange(-10, 10, 0.4)</span><br><span class="line">y = np.arange(-10, 10, 0.4)</span><br><span class="line">XX, YY = np.meshgrid(x, y)</span><br><span class="line">ZZ = np.sin(XX**2 + YY**2) / (XX**2 + YY**2)</span><br><span class="line"></span><br><span class="line">lines = []</span><br><span class="line">line_marker = dict(color=&apos;#0066FF&apos;, width=2)</span><br><span class="line">for i, j, k in zip(XX, YY, ZZ):</span><br><span class="line">    lines.append(go.Scatter3d(x=i, y=j, z=k, mode=&apos;lines&apos;, line=line_marker))</span><br><span class="line"></span><br><span class="line">layout = go.Layout(</span><br><span class="line">    title=&apos;Wireframe with Meshgrid&apos;,</span><br><span class="line">    showlegend=False</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig = go.Figure(data=lines, layout=layout)</span><br><span class="line">py.iplot(fig, filename=&apos;numpy-arange-to-meshgrid&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/02/08/5c5d6f5855efe.png" alt="绘图请配合plotly"></p><h2 id="np-where方法"><a href="#np-where方法" class="headerlink" title="np.where方法"></a>np.where方法</h2><p>假设你有三个数组，第三个数组存的是布尔值，你想要按照条件去前两个数组中选值，如果第三个数组中的值是真，那么就去第一个数组中拿对应的值，否则就拿第二个数组中的值。</p><p>我们可以利用<em>zip</em> 函数实现这一需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])</span><br><span class="line"></span><br><span class="line">yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])</span><br><span class="line"></span><br><span class="line">cond = np.array([True, False, True, True, False])</span><br><span class="line"></span><br><span class="line">result = [(x if contidion else y) for x,y,contidion in zip(xarr,yarr,cond)]</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>虽然这样可以实现，但是会有一些问题：</p><ol><li>如果数组很大就会有性能问题</li><li>多重数组无法这样操作</li></ol><p>利用 <em>np.where</em> 方法，就可以简单的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond,xarr,yarr)</span><br></pre></td></tr></table></figure><p><em>np.where</em> 会返回一个新的数组，其中包含了你需要的值。</p><p>再举一个例子，将一堆数中的值进行替换，正数变成2，负数变成-2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(2, 10)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line"># out</span><br><span class="line">array([[-0.81110748,  0.68433723,  0.52473733, -0.41852741, -2.84401244,</span><br><span class="line">        -1.68747418, -0.11169401, -1.10101844, -0.8750002 ,  1.18884515],</span><br><span class="line">       [-0.30515971,  0.60605408,  0.16320091, -0.99053775, -0.76669183,</span><br><span class="line">        -0.29594746,  0.33500369,  0.28612921, -0.93350166, -0.67301814]])</span><br><span class="line"></span><br><span class="line">np.where(arr&lt;0,-2,2)</span><br><span class="line"># out</span><br><span class="line">array([[-2,  2,  2, -2, -2, -2, -2, -2, -2,  2],</span><br><span class="line">       [-2,  2,  2, -2, -2, -2,  2,  2, -2, -2]])</span><br></pre></td></tr></table></figure><p>通过将arr本身传进去，可以指修改某一部分的值，比如下面是指将负数修改为-2，正数不变:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.where(arr&lt;0,-2,arr)</span><br><span class="line"># out</span><br><span class="line"></span><br><span class="line">array([[-2.        ,  0.68433723,  0.52473733, -2.        , -2.        ,</span><br><span class="line">        -2.        , -2.        , -2.        , -2.        ,  1.18884515],</span><br><span class="line">       [-2.        ,  0.60605408,  0.16320091, -2.        , -2.        ,</span><br><span class="line">        -2.        ,  0.33500369,  0.28612921, -2.        , -2.        ]])</span><br></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p><em>Numpy</em> 支持很多常用的数学方法，比如对数组求和，算平均值，等等，可以直接对数组对象调用，也可以通过 <em>np.method</em> 的方式调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.rand(2,2)*10</span><br><span class="line">arr</span><br><span class="line">out:</span><br><span class="line">array([[ 0.89779239,  8.62581317],</span><br><span class="line">       [ 3.48522587,  5.17990087]])</span><br></pre></td></tr></table></figure><h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><p><em>arr.mean()</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.5471830734485419</span><br></pre></td></tr></table></figure><p>对横向数值求平均：</p><p><em>arr.mean(axis=1)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ 4.76180278,  4.33256337])</span><br></pre></td></tr></table></figure><p>纵向数求平均：</p><p><em>arr.mean(axis=0)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ 2.19150913,  6.90285702])</span><br></pre></td></tr></table></figure><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p><em>arr.sum()</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18.188732293794168</span><br></pre></td></tr></table></figure><p>求和函数也可以用 <em>axis</em> 来指定行或列求和。</p><blockquote><p>更多方法请参考附录。</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><img src="https://i.loli.net/2019/02/09/5c5e8e1bb9f55.jpg" alt="math_funcs.jpg"></p><h2 id="布尔数组方法"><a href="#布尔数组方法" class="headerlink" title="布尔数组方法"></a>布尔数组方法</h2><p>可以对一个包含True和False的布尔数组执行 <em>sum</em> 运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(100)</span><br><span class="line">(arr &gt; 0).sum()</span><br><span class="line"></span><br><span class="line">49</span><br></pre></td></tr></table></figure><p><em>bools.any()</em> 测试数组中是否有 <em>True</em> 的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([False])</span><br><span class="line">bools.any()</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><em>bools.all()</em> 测试所有值是否都是 <em>True</em>.</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>NumPy 的数组排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(6)</span><br><span class="line">arr.sort()</span><br></pre></td></tr></table></figure><p><em>sort</em> 是 <em>in-place</em> 的， 也就是会修改原来数组的数据。</p><h2 id="Unique函数"><a href="#Unique函数" class="headerlink" title="Unique函数"></a>Unique函数</h2><p>unique函数返回排序后的、数组中唯一的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([&apos;Bob&apos;, &apos;Joe&apos;, &apos;Will&apos;, &apos;Bob&apos;, &apos;Will&apos;, &apos;Joe&apos;, &apos;Joe&apos;])</span><br><span class="line">np.unique(names)</span><br></pre></td></tr></table></figure><p>它的作用和下面的代码差不多:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(set(names))</span><br></pre></td></tr></table></figure><h2 id="in1d函数"><a href="#in1d函数" class="headerlink" title="in1d函数"></a>in1d函数</h2><p>in1d函数测试一个数组中的值，是否都在另一个数组中，如果在就返回True，不再返回False:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([1,2,3])</span><br><span class="line">np.in1d(values,[1])</span><br><span class="line"># </span><br><span class="line">arrray([True,False,False])</span><br></pre></td></tr></table></figure><p>更多函数请参考下图：</p><p><img src="https://i.loli.net/2019/02/09/5c5eea638e62f.jpeg" alt="array_set_operations.jpeg"></p><h1 id="NumPy数据持久化、随机数生成"><a href="#NumPy数据持久化、随机数生成" class="headerlink" title="NumPy数据持久化、随机数生成"></a>NumPy数据持久化、随机数生成</h1><p>NumPy可以从磁盘读取数据，也可以将数据保存到本地。这个部分只讲一些基本的内容，因为大家可能更喜欢用 <em>Pandas</em> 来导入数据。</p><p>分别介绍两个方法：</p><ul><li><em>np.save</em></li><li><em>np.load</em></li></ul><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(10)</span><br><span class="line">np.save(&apos;/Users/wittyfans/Desktop/data&apos;,arr)</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">saved = np.load(&apos;/Users/wittyfans/Desktop/data.npy&apos;)</span><br><span class="line">saved</span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br></pre></td></tr></table></figure><h2 id="打包储存"><a href="#打包储存" class="headerlink" title="打包储存"></a>打包储存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(&apos;path&apos;,a=arr,b=arr)</span><br></pre></td></tr></table></figure><h2 id="读取打包文件"><a href="#读取打包文件" class="headerlink" title="读取打包文件"></a>读取打包文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch = np.load(&apos;path.npz&apos;)</span><br><span class="line">arch[&apos;a&apos;] # 通过类似dict的方式来读取数据</span><br><span class="line">arch[&apos;b&apos;]</span><br></pre></td></tr></table></figure><h2 id="随机生成"><a href="#随机生成" class="headerlink" title="随机生成"></a>随机生成</h2><p>生成符合正态分布的4x4数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(4, 4))</span><br><span class="line">samples</span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">array([[ 0.5732,</span><br><span class="line"></span><br><span class="line">0.1933, 0.4429, 1.2796],</span><br><span class="line"></span><br><span class="line">[ 0.575 , [-0.5367, [ 0.1525,</span><br><span class="line"></span><br><span class="line">0.4339, -0.7658, -1.237 ],</span><br><span class="line"></span><br><span class="line">1.8545, -0.92 , -0.1082],</span><br><span class="line"></span><br><span class="line">0.9435, -1.0953, -0.144 ]])</span><br></pre></td></tr></table></figure><p>Python内置的 <em>random</em> 模块，相比于NumPy要慢一个数量级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from random import normalvariate</span><br><span class="line"></span><br><span class="line">N = 1000000</span><br><span class="line"></span><br><span class="line">%timeit samples = [normalvariate(0, 1) for _ in range(N)] 1.77 s +- 126 ms per loop (mean +- std. dev. of 7 runs, 1 loop each)</span><br><span class="line"></span><br><span class="line">%timeit np.random.normal(size=N) 61.7 ms +- 1.32 ms per loop (mean +- std. dev. of 7 runs, 10 loops each)</span><br></pre></td></tr></table></figure><p>这些随机数都是根据种子即 <em>seed</em> 生成的,如果每次生成随机数的时候seed都不变，那么每次生成的随机数都会是一样的。默认NumPy会根据时间来更改seed，这样每次我们就可以拿到不一样的随机数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 随机产生一个数据，此随机数是变动的</span><br><span class="line">print(np.random.random())</span><br><span class="line">print(&apos;--分割线0--&apos;)</span><br><span class="line"># 设置随机数种子</span><br><span class="line">np.random.seed(1)</span><br><span class="line"># 产生一组顺序的固定的数数据</span><br><span class="line">for _ in range(5):</span><br><span class="line">    print(np.random.random())</span><br><span class="line"># 此时，如果再生成一个数据，该数据也是固定的</span><br><span class="line">print(&apos;--分割线1--&apos;)</span><br><span class="line">print(np.random.random())</span><br><span class="line"># 说明我们设置的种子会一直有效，除非我们再次设置</span><br><span class="line">np.random.seed()</span><br><span class="line">print(&apos;--分割线2--&apos;)</span><br><span class="line"># 此随机数是变动的</span><br><span class="line">print(np.random.random())</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/7f4f2303a125" target="_blank" rel="noopener">数据分析学习笔记</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对数组的操作是 &lt;em&gt;NumPy&lt;/em&gt; 中很重要的一部分，了解这些内置的方法，可以让你的效率事半功倍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="numpy" scheme="http://wittyfans.com/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>Numpy Universal Functions</title>
    <link href="http://wittyfans.com/coding/Numpy-Universal-Functions.html"/>
    <id>http://wittyfans.com/coding/Numpy-Universal-Functions.html</id>
    <published>2019-02-09T08:01:12.000Z</published>
    <updated>2019-02-09T08:05:49.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Numpy中一些基本函数参考。</p></blockquote><a id="more"></a><h1 id="Universal-Functions"><a href="#Universal-Functions" class="headerlink" title="Universal Functions"></a>Universal Functions</h1><p><em>Universal Functions</em> 也叫 <em>ufunc</em>，比如开根 <em>sqrt</em>，<em>exp</em>:</p><p><em>Sqrt:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(10)</span><br><span class="line">np.sqrt(arr)</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,</span><br><span class="line">        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])</span><br></pre></td></tr></table></figure><p><em>exp:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.exp(arr)</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,</span><br><span class="line">         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,</span><br><span class="line">         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,</span><br><span class="line">         8.10308393e+03])</span><br></pre></td></tr></table></figure><p>你有两个数组，它们的长度都是一样的，你需要对比两个数组中对应的值，返回大的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(1,10)*10</span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">array([[  7.45106569,   2.47039999,  13.3143474 ,  11.73359137,</span><br><span class="line">         -5.16471496,   3.37688733,  -3.03783497,  13.94821303,</span><br><span class="line">        -13.79166595,   4.35553629]])</span><br><span class="line"></span><br><span class="line">b = np.random.randn(1,10)*10</span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">array([[  0.73315303,   5.87494888,   4.01168595,   3.78652398,</span><br><span class="line">         -0.35151181,  -5.61564742,   3.0190971 ,  -2.28944227,</span><br><span class="line">          6.45900038,  14.22907421]])</span><br></pre></td></tr></table></figure><p>利用 <em>np</em> 的 <em>maximun</em> 函数就可以做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.maximum(a,b)</span><br><span class="line"># 输出：</span><br><span class="line"></span><br><span class="line">array([[  7.45106569,   5.87494888,  13.3143474 ,  11.73359137,</span><br><span class="line">         -0.35151181,   3.37688733,   3.0190971 ,  13.94821303,</span><br><span class="line">          6.45900038,  14.22907421]])</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><img src="https://i.loli.net/2019/02/09/5c5e89c06da7b.jpg" alt="ufuncs"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Numpy中一些基本函数参考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="numpy" scheme="http://wittyfans.com/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>Windows 批量映射并重命名网络驱动器</title>
    <link href="http://wittyfans.com/coding/Windows-%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E5%B9%B6%E9%87%8D%E5%91%BD%E5%90%8D%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E5%99%A8.html"/>
    <id>http://wittyfans.com/coding/Windows-批量映射并重命名网络驱动器.html</id>
    <published>2019-02-08T09:24:34.000Z</published>
    <updated>2019-02-08T09:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何用脚本批量映射windows网络驱动器，并修改其名称？</p></blockquote><a id="more"></a><p>映射网络驱动器后，可以直接在windows的资源管理器中访问指定的网络路径，不用每次都输入常常的路径地址，非常方便。</p><p><img src="https://msegceporticoprodassets.blob.core.windows.net/inline-media/0e21d35a-52f5-4ea4-9971-d0c4a23ea705-zh-hans" alt=""></p><h1 id="手动映射"><a href="#手动映射" class="headerlink" title="手动映射"></a>手动映射</h1><p>映射网络路径很简单</p><ol><li>直接打开文件资源管理器，然后选择映射网络驱动器</li><li>在“驱动器”列表中，选择驱动器号。（任何可用驱动器号均可。）</li><li>在“文件夹”框中，键入文件夹或计算机的路径，或者选择“浏览”以查找文件夹或计算机。若要在每次登录到电脑时都进行连接，请选中“登录时重新连接”复选框。<br>选择“完成”。</li></ol><p>但这有个问题，即它映射后显示的名字是该文件夹的路径，如果名字中有空格或者中文，可能会出现名字就是整个路径的情况，尽管你可以手动改过来，但如果你要在域中批量给电脑映射，这种方式就不太方便了。</p><h1 id="bat直接映射"><a href="#bat直接映射" class="headerlink" title="bat直接映射"></a>bat直接映射</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ECHO OFF</span><br><span class="line">net use Z: /delete</span><br><span class="line">net use Z: \\you\\net\\url /persistent:yes</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>通过bat批量映射，不过这种方法也无法自定义名字。</p><h1 id="修改注册表-bat"><a href="#修改注册表-bat" class="headerlink" title="修改注册表+bat"></a>修改注册表+bat</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use F: /delete</span><br><span class="line">reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\##\10.22.22.2#disk#file#&apos;wittyfans file&apos;#files /v _LabelFromReg /t REG_SZ /f /d &quot;我随便映射的一个盘&quot;</span><br><span class="line">net use F: &quot;\\10.22.22.2\disk\file\wittyfans file\files&quot; /persistent:yes</span><br></pre></td></tr></table></figure><p>先将需要命名的盘符删除，再将路径和需要定义的名字添加到注册表,随后映射即可。<br>需要注意几点：</p><ul><li>在注册表编辑语句中，后面的路径中的斜杠需要用井号替代</li><li>路径中文件夹的名字中包含空格的，需要用引号括起来</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如何用脚本批量映射windows网络驱动器，并修改其名称？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="windows" scheme="http://wittyfans.com/tags/windows/"/>
    
      <category term="cmd" scheme="http://wittyfans.com/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>NumPy之NDarrays创建、运算、切片、索引</title>
    <link href="http://wittyfans.com/coding/NumPy%E4%B9%8BNDarrays%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%90%E7%AE%97%E3%80%81%E5%88%87%E7%89%87%E3%80%81%E7%B4%A2%E5%BC%95.html"/>
    <id>http://wittyfans.com/coding/NumPy之NDarrays创建、运算、切片、索引.html</id>
    <published>2019-02-08T08:55:13.000Z</published>
    <updated>2019-02-08T08:57:19.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无须多讲，Most important foundational packages for numerical computing in Python.</p></blockquote><a id="more"></a><h1 id="NumPy之NDarrays创建、运算、切片、索引"><a href="#NumPy之NDarrays创建、运算、切片、索引" class="headerlink" title="NumPy之NDarrays创建、运算、切片、索引"></a>NumPy之NDarrays创建、运算、切片、索引</h1><p>为什么要使用Numpy？给你两组数据运算，然后对比一下性能就知道了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">my_arr = np.arange(1000000)</span><br><span class="line"></span><br><span class="line">my_list = list(range(1000000))</span><br></pre></td></tr></table></figure><p>现在对两组数乘以2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%time for _ in range(10): my_arr2 = my_arr * 2 </span><br><span class="line"></span><br><span class="line">CPU times: user 20 ms, sys: 50 ms, total: 70 ms Wall time: 72.4 ms</span><br><span class="line"></span><br><span class="line">%time for _ in range(10): my_list2 = [x * 2 for x in my_list] </span><br><span class="line"></span><br><span class="line">CPU times: user 760 ms, sys: 290 ms, total: 1.05 s</span><br></pre></td></tr></table></figure><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy中生成随机数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">data = np.random.randn(2,3)</span><br></pre></td></tr></table></figure><p>数据长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-0.05094946, -1.54555805, -1.19695135],</span><br><span class="line">       [-1.06169454,  1.13763682,  0.57538678]])</span><br></pre></td></tr></table></figure><p>将它们乘10:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[  9.41882893,   3.20674452,  18.05866858],</span><br><span class="line">       [ -7.97835594,  -9.56449228,  -0.83342424]])</span><br></pre></td></tr></table></figure><p>两份数据相加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-2.37617968,  3.45388874, -0.64218591],</span><br><span class="line">       [-2.99399147, -1.11118452, -1.11992404]])</span><br></pre></td></tr></table></figure><p>对于Numpy的数据：</p><blockquote><p>An ndarray is a generic multidimensional container for homogeneous data; that is, all of the elements must be the same type. Every array has a shape, a tuple indicating the size of each dimension, and a dtype, an object describing the data type of the array:</p></blockquote><ul><li>所有的数据必须是同样的类型</li><li>每个数组都有一个元组类型的shape属性，表示这个数组的维度信息</li><li>每个数组都有一个dtype属性用来描述它其中的数据类型</li></ul><p>如上面的data：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.shape ---&gt; (2, 3)</span><br><span class="line">data.dtype --&gt; dtype(&apos;float64&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>While it’s not necessary to have a deep understanding of NumPy for many data analytical applications, becoming proficient in array-oriented programming and thinking is a key step along the way to becoming a scientific Python guru.</p></blockquote><h2 id="创建-NDarrays"><a href="#创建-NDarrays" class="headerlink" title="创建 NDarrays"></a>创建 NDarrays</h2><p>直接从数组创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data1 = [6,7.5,8,0,1]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1</span><br></pre></td></tr></table></figure><p>也可以从多维数组创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line"></span><br><span class="line">arr2.shape --&gt; (2,4)</span><br><span class="line">arr2.dim --&gt;2</span><br></pre></td></tr></table></figure><p>可以用 <em>ndim</em> 属性来看数组的维度信息。</p><p>Numpy还有一些有趣的方法，可以直接创建0和1，或者空值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(10) --&gt; 创建10个0的数组</span><br><span class="line">np.zeros((3,6))</span><br><span class="line">np.empty((2,3,2)) --&gt; 创建两个两列三行的数组</span><br></pre></td></tr></table></figure><p>还有一些创建<em>ndarrays</em>的方法：</p><ul><li>array: Convert input data (list, tuple, array, or other sequence type) to an ndarray either by inferring a dtype</li><li>asarray: Convert input to ndarray, but do not copy if the input is already an ndarray</li><li>arange: Like the built-in range but returns an ndarray instead of a list</li></ul><p>更多的方法可以参考：<em>Python for data analyse, Table 4-1</em></p><h2 id="NDarrays的数据类型"><a href="#NDarrays的数据类型" class="headerlink" title="NDarrays的数据类型"></a>NDarrays的数据类型</h2><p>ndarrays 的data type或者是dtype包含了一些基本的信息(meta),array在定义的时候是可以指定数据类型的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([1,2,3],dtype=np.float64)</span><br><span class="line">arr2 = np.array([1,2,3],dtype=np.int32)</span><br></pre></td></tr></table></figure><p>数据类型可以相互转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([1,2,3,4])</span><br><span class="line">arr.dtype</span><br><span class="line"># 输出 dtype(&apos;int64&apos;)</span><br><span class="line"></span><br><span class="line">arr = np.array([1,2,3,4])</span><br><span class="line">floatarr = arr.astype(np.float64)</span><br><span class="line">floatarr.dtype</span><br><span class="line"># 输出 dtype(&apos;float64&apos;)</span><br></pre></td></tr></table></figure><p>相反的<em>float</em>也可以转化成 <em>int</em>,十进制多出来的部分会被四舍五入。</p><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>下面是基本的运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[1., 2., 3.], [4., 5., 6.]])</span><br></pre></td></tr></table></figure><p>乘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr*arr</span><br><span class="line"># out</span><br><span class="line">array([[  1.,   4.,   9.],</span><br><span class="line">       [ 16.,  25.,  36.]])</span><br></pre></td></tr></table></figure><p>减:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr-arr</span><br><span class="line"># out</span><br><span class="line">array([[ 0.,  0.,  0.],</span><br><span class="line">       [ 0.,  0.,  0.]])</span><br></pre></td></tr></table></figure><p>所有的运算都是基于相对关系的，记住这一点即可。除此之外，np还支持比较，假设两个arr对比，返回结果会是一个包含true或false的数组。</p><h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><p>Numpy的切片和索引和数组的差不多，切片就是按照坐标或者坐标范围来找出对应，或对应范围内的值，根据坐标来理解就很简单</p><p><img src="https://i.loli.net/2019/02/08/5c5d05c2d4a0f.jpeg" alt=""></p><p>你可以对一个切片范围内的值重新赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(10)</span><br><span class="line">arr[5] --&gt; 5</span><br><span class="line">arr[5:8] --&gt; [5,6,7]</span><br><span class="line">arr[5:8] = 12</span><br><span class="line">arr --&gt; array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span><br></pre></td></tr></table></figure><p>np设计需要处理大量的数据，所以对于数组的操作，都是在原来的数据上改动，不会copy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr_slice = arr[5:8]</span><br><span class="line">arr_slice</span><br><span class="line"># out: array([5, 6, 7])</span><br><span class="line"></span><br><span class="line">arr_slice[:] = 9 # [:]是应用在数组中的所有元素</span><br><span class="line">arr</span><br><span class="line"># out: array([0, 1, 2, 3, 4, 9, 9, 9, 8, 9])</span><br></pre></td></tr></table></figure><p>如果你要copy，np提供了一个copy函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])</span><br><span class="line">copyed = arr3d.copy()</span><br><span class="line">copyed</span><br><span class="line"># out:</span><br><span class="line">array([[[ 1,  2,  3],</span><br><span class="line">        [ 4,  5,  6]],</span><br><span class="line"></span><br><span class="line">       [[ 7,  8,  9],</span><br><span class="line">        [10, 11, 12]]])</span><br></pre></td></tr></table></figure><p>可以在两个维度上切片：</p><p><em>arr2d[:]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br></pre></td></tr></table></figure><p><em>arr2d[:2]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br></pre></td></tr></table></figure><p><em>arr2d[:2,1:]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[2, 3],</span><br><span class="line">       [5, 6]])</span><br></pre></td></tr></table></figure><p><em>arr2d[:,:0]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1],</span><br><span class="line">       [4],</span><br><span class="line">       [7]])</span><br></pre></td></tr></table></figure><p>参照下图，动手实践几次，就会懂其中的套路了。</p><p><img src="https://i.loli.net/2019/02/08/5c5d054478e7b.jpeg" alt=""></p><h2 id="Boolean-Indexing"><a href="#Boolean-Indexing" class="headerlink" title="Boolean Indexing"></a>Boolean Indexing</h2><p>我们有一批名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([&apos;Bob&apos;, &apos;Joe&apos;, &apos;Will&apos;, &apos;Bob&apos;, &apos;Will&apos;, &apos;Joe&apos;, &apos;Joe&apos;])</span><br></pre></td></tr></table></figure><p>我们可以直接通过 <em>names == ‘Bob’</em> 来返回一个检查结果，这个结果包含的是一个 <em>bollean</em> 的 <em>list</em>.</p><p><em>names == ‘Bob’</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ True, False, False,  True, False, False, False], dtype=bool)</span><br></pre></td></tr></table></figure><p>如果我们有一份数据，也是7行，那么我们可以吧这个包含 <em>True</em> 和 <em>False</em> 的l <em>List</em> 传进去，这样 <em>Numpy</em> 会选出那些对应 <em>True</em> 的行。</p><p><em>data = np.random.randn(7,4)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[-0.71030181, -0.14900916, -1.15238417, -0.49395683],</span><br><span class="line">       [-0.92601472,  0.88452947, -0.9206763 , -0.43338155],</span><br><span class="line">       [-0.68093622,  0.93612942,  0.03261537,  1.44615091],</span><br><span class="line">       [ 1.40919226, -0.07214425, -0.07973205, -1.01432059],</span><br><span class="line">       [-0.4042085 ,  0.66812768,  0.4715137 ,  0.34981598],</span><br><span class="line">       [ 0.89631112, -0.70534677,  0.44560626,  0.6133761 ],</span><br><span class="line">       [-0.28979691,  0.58481489, -0.06945283, -0.99545537]])</span><br></pre></td></tr></table></figure><p><em>data[names==’Bob’]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-0.71030181, -0.14900916, -1.15238417, -0.49395683],</span><br><span class="line">       [ 1.40919226, -0.07214425, -0.07973205, -1.01432059]])</span><br></pre></td></tr></table></figure><blockquote><p> Boolean selection will not fail if the boolean array is not the correct length, so I recommend care when using this feature.</p></blockquote><p>上面的选择，也可以配合切片：</p><p><em>data[names==’Bob’,:1]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-0.71030181],</span><br><span class="line">       [ 1.40919226]])</span><br></pre></td></tr></table></figure><p>选择除了 <em>Bob</em> 之外的名字：</p><ul><li><em>names != ‘Bob’</em></li><li><em>~(names == ‘Bob’)</em></li></ul><p>对于 <em>names</em> 的过滤，可以用组合条件：</p><ul><li><em>cond = names == ‘Bob’</em></li><li><em>cond = (names==’Bob’) | (names == ‘will’)</em></li></ul><p>对于 <em>data</em> 也一样：</p><p><em>data[data &lt; 0] = 0</em></p><p>设置整行的值也非常简单：</p><p><em>data[names != ‘Joe’] = 7</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[ 7.        ,  7.        ,  7.        ,  7.        ],</span><br><span class="line">       [-0.92601472,  0.88452947, -0.9206763 , -0.43338155],</span><br><span class="line">       [ 7.        ,  7.        ,  7.        ,  7.        ],</span><br><span class="line">       [ 7.        ,  7.        ,  7.        ,  7.        ],</span><br><span class="line">       [ 7.        ,  7.        ,  7.        ,  7.        ],</span><br><span class="line">       [ 0.89631112, -0.70534677,  0.44560626,  0.6133761 ],</span><br><span class="line">       [-0.28979691,  0.58481489, -0.06945283, -0.99545537]])</span><br></pre></td></tr></table></figure><h2 id="Fancy-Indexing"><a href="#Fancy-Indexing" class="headerlink" title="Fancy Indexing"></a>Fancy Indexing</h2><p>Fancy indexing is a term adopted by NumPy to describe indexing using integer arrays. Suppose we had an 8 × 4 array:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((8,4),dtype=np.int)</span><br><span class="line">for i in range(8):</span><br><span class="line">    arr[i] = i</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>选择单个值：</p><p><em>arr[3,0]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out: 3</span><br></pre></td></tr></table></figure><p>选择多行：</p><p><em>arr[[3,0]]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[3, 3, 3, 3],</span><br><span class="line">       [0, 0, 0, 0]])</span><br></pre></td></tr></table></figure><p>让我们构建一个按顺序排列的 <em>8x4</em> 的数组：</p><p><em>arr = np.arange(32).reshape((8,4))</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0,  1,  2,  3],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15],</span><br><span class="line">       [16, 17, 18, 19],</span><br><span class="line">       [20, 21, 22, 23],</span><br><span class="line">       [24, 25, 26, 27],</span><br><span class="line">       [28, 29, 30, 31]])</span><br></pre></td></tr></table></figure><p>按选择前两个子数组的第一个数：</p><p><em>arr[[1,2],[0,0]]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([4, 8])</span><br></pre></td></tr></table></figure><p>你也可以对选择出来的数组，进行排序：</p><p><em>arr[[1,2]][:]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11]])</span><br></pre></td></tr></table></figure><p><em>arr[[1,2]][:,[0]]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[4],</span><br><span class="line">       [8]])</span><br></pre></td></tr></table></figure><p><em>arr[[1,2]][:,[0,3,2,1]]</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[ 4,  7,  6,  5],</span><br><span class="line">       [ 8, 11, 10,  9]])</span><br></pre></td></tr></table></figure><blockquote><p>Fancy indexing always copies the data into a new array.</p></blockquote><h2 id="Transposing-Arrays-and-Swapping-Axes"><a href="#Transposing-Arrays-and-Swapping-Axes" class="headerlink" title="Transposing Arrays and Swapping Axes"></a>Transposing Arrays and Swapping Axes</h2><h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = 18</span><br><span class="line">x = 2</span><br><span class="line">y = 9</span><br><span class="line">arr = np.arange(value).reshape((x,y))</span><br><span class="line">arr</span><br><span class="line"># 输出 </span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8],</span><br><span class="line">       [ 9, 10, 11, 12, 13, 14, 15, 16, 17]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = 18</span><br><span class="line">x = 3</span><br><span class="line">y = 6</span><br><span class="line">arr = np.arange(value).reshape((x,y))</span><br><span class="line"># 输出</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17]])</span><br></pre></td></tr></table></figure><p>只需要确保 Value = X <em> Y 就可以任意 </em>shape* 了。</p><h3 id="Transposing"><a href="#Transposing" class="headerlink" title="Transposing"></a>Transposing</h3><p>看例子：</p><p><em>arr = np.arange(18).reshape((3,6))</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17]])</span><br></pre></td></tr></table></figure><p><em>arr.T</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0,  6, 12],</span><br><span class="line">       [ 1,  7, 13],</span><br><span class="line">       [ 2,  8, 14],</span><br><span class="line">       [ 3,  9, 15],</span><br><span class="line">       [ 4, 10, 16],</span><br><span class="line">       [ 5, 11, 17]])</span><br></pre></td></tr></table></figure><p><em>Transposing</em> 在矩阵计算中用的非常多，比如用 <em>np.dot</em> 方法计算矩阵的内积:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arra = np.array([2,3,0])</span><br><span class="line">arrb = np.array([2,-1,1])</span><br><span class="line">np.dot(arra,arrb)</span><br><span class="line"># 输出 1</span><br></pre></td></tr></table></figure><blockquote><p>怎么计算内积？看下图就明白了</p></blockquote><p><img src="https://i.loli.net/2019/02/08/5c5d41ff41077.png" alt=""></p><p><img src="https://i.loli.net/2019/02/08/5c5d4246ea899.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无须多讲，Most important foundational packages for numerical computing in Python.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="numpy" scheme="http://wittyfans.com/tags/numpy/"/>
    
      <category term="ndarrays" scheme="http://wittyfans.com/tags/ndarrays/"/>
    
  </entry>
  
  <entry>
    <title>Python文件操作与编码</title>
    <link href="http://wittyfans.com/coding/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BC%96%E7%A0%81.html"/>
    <id>http://wittyfans.com/coding/Python文件操作与编码.html</id>
    <published>2019-02-06T14:34:30.000Z</published>
    <updated>2019-02-06T14:38:32.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在数据分析中，我们通常用<em>pandas</em>的 <em>read_csv</em>方法来读取系统中的文件，但理解这背后的原理也是非常重要的，而且幸运的是，这很简单。</p></blockquote><a id="more"></a><h1 id="Python与文件、操作系统交互"><a href="#Python与文件、操作系统交互" class="headerlink" title="Python与文件、操作系统交互"></a>Python与文件、操作系统交互</h1><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>python使用open方法接受一个路径（绝对或相对路径都可以）来读取读取文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = &apos;/Users/wittyfans/Documents/data/all_girls.csv&apos; # :)</span><br><span class="line">f = open(path)</span><br></pre></td></tr></table></figure><p>默认打开是以 <em>r</em> 模式打开的，即只读。</p><p>我们可以用推导式来读取文件中的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = [x.rstrip() for x in open(path)]</span><br></pre></td></tr></table></figure><p>当你使用open方法创建一个文件的时候，一定要关掉这个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>python也考虑到了一些人可能记性不好，所以建议你使用这种方式跟文件交互：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(path) as f:</span><br><span class="line">lines = [x.rstrip() for x in f]</span><br></pre></td></tr></table></figure><p><em>with</em> 语句会自动关闭文件。</p><p>在使用open语句的是，有一点要小心，如果当前文件夹內有一个a.txt的文件，如果你不小心使用了 <em>f = open(‘./a.txt’,’w’)</em> 语句，那么python会立即创建一个a.txt文件，并替换掉当前的（小心⚠️）。</p><p>假设当前文件夹中有一个ftext.txt文件，如果我运行下面的代码，则可以正常显示文件中的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;./ftest.txt&quot;) as f:</span><br><span class="line">    lines = [line for line in f]</span><br><span class="line">    print(lines)</span><br></pre></td></tr></table></figure></p><p>如果我这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;./ftest.txt&quot;,&apos;w&apos;) as f:</span><br><span class="line">    lines = [line for line in f]</span><br><span class="line">    print(lines)</span><br></pre></td></tr></table></figure><p>则会报错：<em>UnsupportedOperation: not readable</em>，因为文件依据被覆盖。<br>文件模式还有一个 <em>x</em>，它也会在path指定的路径中创建文件，不过如果路径中已经有了文件，则会创建失败。</p><p>如果你想在读取文件的时候，了解当前读取到了哪一行，或者根据行数去做控制，可以使用 <em>f.tell()</em> 函数。</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>使用文件对象的 <em>write</em> 或者 <em>writelines</em> 方法即可向文件执行写操操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;tmp.txt&apos;,&apos;w&apos;) as handle:</span><br><span class="line">handle.writelines(x for x in open(path) if len(x) &gt; 1)</span><br><span class="line"></span><br><span class="line">with open(&apos;tmp.txt&apos;) as f:</span><br><span class="line">lines = f.readlines()</span><br></pre></td></tr></table></figure><h2 id="Bytes和Unicode类型"><a href="#Bytes和Unicode类型" class="headerlink" title="Bytes和Unicode类型"></a>Bytes和Unicode类型</h2><p>计算机最早的编码类型是ASCII，能存一个字节的信息，对与英文刚好够用，但是如果对于汉字，最少需要两个字节才能存下来，所以后面为了统一，就制定了Unicode。因为用两个字节去存本来一个字节就可以存下来的东西，unicode会有些浪费，于是就出现了utf-8，它把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节，这样在网络上传输的时候，可以节省很多带宽。</p><p>这些编码都是可以相互转化的，在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节，如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>python中的字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;# 字节类型的数据，只占用一个字节</span><br><span class="line">x = &apos;ABC&apos; # str，unicode类型的数据，占用多个字节</span><br></pre></td></tr></table></figure><p>unicode类型的数据（str），可以转化成字节类型表示的数据，通过encode方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;ABC&apos;.encode(&apos;ascii&apos;) # unicode类型的str，转化成ascii编码类型的数据，转化后占用1个字节</span><br><span class="line">&apos;中文&apos;.encode(&apos;utf-8&apos;) # unicode类型的str，转化成utf-8编码类型的数据，例如从内存到硬盘</span><br></pre></td></tr></table></figure><p>在python中，如果你想要读取10个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(path) as f:</span><br><span class="line">chars = f.read(10)</span><br></pre></td></tr></table></figure><p>这样会从文件中读取10个字符，也就是UTF-8格式下的10个字符。</p><p>如果你以 <em>rb</em> 模式打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(path,&apos;rb&apos;) as f:</span><br><span class="line">data = f.read(10)</span><br></pre></td></tr></table></figure><p>则python会读取10个字节，如果是同一份数据，则读取10个字节的这种方式会少一些数据。</p><p>对于file的seek方法要注意，如果你使用的时候出错，会导致后面的读取也出错。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">字符串和编码-廖雪峰</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在数据分析中，我们通常用&lt;em&gt;pandas&lt;/em&gt;的 &lt;em&gt;read_csv&lt;/em&gt;方法来读取系统中的文件，但理解这背后的原理也是非常重要的，而且幸运的是，这很简单。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数、生成器、异常处理</title>
    <link href="http://wittyfans.com/coding/Python%E5%87%BD%E6%95%B0%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"/>
    <id>http://wittyfans.com/coding/Python函数、生成器、异常处理.html</id>
    <published>2019-02-06T07:40:48.000Z</published>
    <updated>2019-02-06T07:44:37.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数：命名空间、多个值返回、函数作为对象、Lambda；<br>生成器：生成器表达式、itertools；<br>错误与异常捕获：try 语句的使用；</p></blockquote><a id="more"></a><h1 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数是实现代码复用与组织化最重要的方法，函数用 <strong>def</strong> 关键字定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_func(x,y,z=1.5):</span><br><span class="line">if z&gt;1:</span><br><span class="line">return z*(x+y)</span><br><span class="line">else:</span><br><span class="line">return z/(x+y)</span><br></pre></td></tr></table></figure><p>python中返回多个值也是没问题的，如果你写的函数没有返回值，那么默认python会返回 <strong>None</strong>.</p><p>每个函数都有 <em>positional arguments</em> 和 <em>keyword arguments</em>. <em>keyword arguments</em> 在设置函数的默认参数的时候用的比较多，在前面的函数中，x和y是 <em>positional arguments</em>，而z是 <em>keyword arguments</em>。</p><p>这些参数的顺序是有限制的：</p><blockquote><p>keyword arguments must follow the positional arguments(if any).</p></blockquote><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>函数可以访问两种类型的变量，<em>global</em> 和 <em>local</em> 的，中文叫全局的或局部的。</p><p>局部变量在函数运行的时候马上创建，如果函数运行完毕，马上会被销毁（也有例外，但不在这里的讨论范围之内）。</p><p>比如下面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">a = []</span><br><span class="line">for i in range(5):</span><br><span class="line">a.append(i)</span><br></pre></td></tr></table></figure><p><strong>func()</strong>函数调用后，在它的内部创建了一个空的数组，然后5个元素添加了进去，但当函数运行结束后，a马上就会被销毁。</p><p>假设将代码改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">def func():</span><br><span class="line">for i in range(5):</span><br><span class="line">a.append(i)</span><br></pre></td></tr></table></figure><p>修改函数外面的变量是可能的，但这些变量必须声明为 <em>global</em> 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = None</span><br><span class="line">def bind_a_variable():</span><br><span class="line">global a</span><br><span class="line">a = []</span><br><span class="line">bind_a_variable() # 输出 []</span><br></pre></td></tr></table></figure><blockquote><p>个人不是很推荐使用 <em>global</em> 关键字，通常来说全局变量都用来存储一些系统的状态，如果你需要大量的使用，更推荐你用更面向对象的方式，例如类。</p></blockquote><h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f():</span><br><span class="line">a = 5</span><br><span class="line">b = 6</span><br><span class="line">c = 7</span><br><span class="line">return a,b,c</span><br></pre></td></tr></table></figure><p>python的函数可以返回多个值，它们会被包装成一个元组，随后再被解包。</p><h2 id="函数作为对象"><a href="#函数作为对象" class="headerlink" title="函数作为对象"></a>函数作为对象</h2><p>因为python的函数也是对象，所以可以做很多别的语言很难做到的事情。<br>假设我们有一些数据需要清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states = [&apos; Alabama &apos;, &apos;Georgia!&apos;, &apos;Georgia&apos;, &apos;georgia&apos;, &apos;FlOrIda&apos;,&apos;south carolina##&apos;, &apos;West virginia?&apos;]</span><br></pre></td></tr></table></figure><p>如果你处理过用户提交上来的数据就懂我说的，很多简直想象不到输入都会发生，对于那些输入，我们要去掉首尾空格，多余的符号，正确的首字母大小写等等。一种方法是，我们可以用自带的re正则模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">def clean_strings(strings):</span><br><span class="line">result = []</span><br><span class="line">for value in strings:</span><br><span class="line">value = value.strip()</span><br><span class="line">value = re.sub(&apos;[!#?]&apos;,&apos;&apos;,value)</span><br><span class="line">value = value.title()</span><br><span class="line">result = append(value)</span><br></pre></td></tr></table></figure><p>上面的结果看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean_strings(states)</span><br><span class="line">输出:</span><br><span class="line">[&apos;Alabama&apos;,&apos;Georgia&apos;, &apos;Georgia&apos;, &apos;Georgia&apos;, &apos;Florida&apos;, &apos;South Carolina&apos;, &apos;West Virginia&apos;]</span><br></pre></td></tr></table></figure><p>我们函数作为对象，存到数组中，来实现这一需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def remove_punctuation(value):</span><br><span class="line">return re.sub(&apos;[!#?]&apos;, &apos;&apos;, value)</span><br><span class="line"># 函数数组</span><br><span class="line">clean_ops = [str.strip,remove_punctuation,str.title]</span><br><span class="line"></span><br><span class="line"># ops参数接受函数数组对象</span><br><span class="line">def clean_string(strings,ops):</span><br><span class="line">result = []</span><br><span class="line">for value in strings:</span><br><span class="line">for function in ops:</span><br><span class="line">value = function(value)</span><br><span class="line">result.append(value)</span><br><span class="line">return result</span><br><span class="line"></span><br><span class="line">clean_string(states,clean_ops)</span><br><span class="line"></span><br><span class="line">输出是一样的:</span><br><span class="line">[&apos;Alabama&apos;,&apos;Georgia&apos;, &apos;Georgia&apos;, &apos;Georgia&apos;, &apos;Florida&apos;, &apos;South Carolina&apos;, &apos;West Virginia&apos;]</span><br></pre></td></tr></table></figure><p>这种方式可以让你的代码更解耦。</p><p>用map方法也可以将一个函数作用到序列的每一个元素上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in map(remove_punctuation,states):</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda是把那些很简短的函数形式做了简化，让你可以用一种非常简单的方式定义一个函数，然后将这个小函数用在需要它的地方，这在特定的情境下，非常方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def short_function(x):</span><br><span class="line">return x* 2</span><br><span class="line"># 等于</span><br><span class="line">equiv_anon = lambda x: x*2</span><br></pre></td></tr></table></figure><p>看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def apply_to_list(some_list,f):</span><br><span class="line">return [f(x) for x in some_list]</span><br><span class="line"></span><br><span class="line">ints = [1,2,3,4]</span><br><span class="line">apply_to_list(ints,lambdax:x*2)</span><br></pre></td></tr></table></figure><p>你可以在参数中，直接定义要传进去的参数。</p><p>再来看另一个例子，你有一堆字符，你需要根据每一个字符中字母出现的个数多少来排序（重复的不算）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings = [&apos;foo&apos;, &apos;card&apos;, &apos;bar&apos;, &apos;aaaa&apos;, &apos;abab&apos;]</span><br><span class="line">strings.sort(key= lambda x: len(set(list(x))))</span><br></pre></td></tr></table></figure><ul><li>list,会将字母串分解</li><li>set,会去掉重复的字母</li></ul><p>最后算出每个字母串的长度并以此排序。</p><blockquote><p>lambda函数是没有<strong>name</strong>属性的</p></blockquote><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>可以将<em>iter</em>函数作用到序列上，这样便返回了一个生成器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_iterator = iter(some_dict)</span><br><span class="line"></span><br><span class="line">dict_iterator </span><br><span class="line">输出: &lt;dict_keyiterator at 0x7fbbd5a9f908&gt;</span><br></pre></td></tr></table></figure><p>可以用list包含一个生成器，得到内部的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(dict_iterator)</span><br></pre></td></tr></table></figure><p>生成器是惰性的，比如你要读一个文件有一万行，你不需要一次性全部的读取，用生成器，你只需要一行一行的返回。</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式和列表推导式有些类似，不过包裹它的是括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen = (x ** 2 for x in range(100))</span><br><span class="line">gen </span><br><span class="line"># 输出 &lt;generator object &lt;genexpr&gt; at 0x109cbf3b8&gt;</span><br></pre></td></tr></table></figure><p>上面这种写法和下面的代码完全一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def make_gen():</span><br><span class="line">for x in range(100):</span><br><span class="line">yield x**2</span><br><span class="line">gen = make_gen()</span><br></pre></td></tr></table></figure><p>生成器可以像数组一样当作函数的参数，比如计算list內所有数的和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gen = [x ** 2 for x in range(100)]</span><br><span class="line">sum(gen) # 输出328350</span><br><span class="line"></span><br><span class="line">gen = （x ** 2 for x in range(100)）</span><br><span class="line">sum(gen) # 生成器当作参数，一样输出328350</span><br></pre></td></tr></table></figure><h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p><em>itertools</em>标准库为一些常用的数据，内置了一些通用的生成器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">first_letter = lambda x: x[0]</span><br><span class="line"></span><br><span class="line">names = [&apos;Alan&apos;, &apos;Adam&apos;, &apos;Wes&apos;, &apos;Will&apos;, &apos;Albert&apos;, &apos;Steven&apos;]</span><br><span class="line"></span><br><span class="line">for letter, names in itertools.groupby(names, first_letter):</span><br><span class="line">print(letter, list(names)) # names is a generator</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">A [&apos;Alan&apos;, &apos;Adam&apos;] </span><br><span class="line">W [&apos;Wes&apos;, &apos;Will&apos;] </span><br><span class="line">A [&apos;Albert&apos;] </span><br><span class="line">S [&apos;Steven&apos;]</span><br></pre></td></tr></table></figure><h1 id="错误与异常捕获"><a href="#错误与异常捕获" class="headerlink" title="错误与异常捕获"></a>错误与异常捕获</h1><p>健壮的程序一定要有错误与异常捕获，我么要进行类型转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&apos;1.2345&apos;) ---&gt; 1.2345</span><br><span class="line">float(&apos;string&apos;) ---&gt; value error</span><br></pre></td></tr></table></figure><p>我们定义一个函数来捕获这个异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def attemp_float(x)</span><br><span class="line">tyr:</span><br><span class="line">return float(x)</span><br><span class="line">except:</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><p>这时候，如果捕获到了value error，就会返回输出的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(&apos;1.2345&apos;) ---&gt; 1.2345</span><br><span class="line">float(&apos;string&apos;) ---&gt; string</span><br></pre></td></tr></table></figure><p>函数有可能会返回别的错误，这时候需要把可能出现的错误写出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">except(TypeError,ValueError)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在文件读取中，你打开了一个文件，不管你有没有操作，你都需要把它关闭，这时候就需要用到final语句，即不管前面是否捕获到了异常，最终都要做的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(path,&apos;w&apos;)</span><br><span class="line">try:</span><br><span class="line">write_to_file(f)</span><br><span class="line">finally:</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数：命名空间、多个值返回、函数作为对象、Lambda；&lt;br&gt;生成器：生成器表达式、itertools；&lt;br&gt;错误与异常捕获：try 语句的使用；&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python推导式探究</title>
    <link href="http://wittyfans.com/coding/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E6%8E%A2%E7%A9%B6.html"/>
    <id>http://wittyfans.com/coding/Python推导式探究.html</id>
    <published>2019-02-06T04:08:59.000Z</published>
    <updated>2019-02-06T04:13:26.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推导式应该是python中最受喜爱的一部分内容了，它可以让你以一种简单的形式过滤原来的数据生成一份新的数据。</p></blockquote><a id="more"></a><h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在数组中，推导式的用法类似这样：</p><p>[<em>expr</em> for val in collection if <em>condition</em>]</p><p>基本上和下面的for循环的意思一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">for val in collection:</span><br><span class="line">    if condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = [&apos;a&apos;,&apos;as&apos;,&apos;bat&apos;,&apos;car&apos;,&apos;dove&apos;,&apos;python&apos;]</span><br><span class="line">[x.upper() for x in strings if len(x) &gt;2]</span><br><span class="line"></span><br><span class="line">[&apos;BAT&apos;,&apos;CAR&apos;,&apos;DOVE&apos;,&apos;PYTHON&apos;]</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典的推导式，类似这样，注意外面是花括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_comp = &#123;key-expr:value-expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure><p>快速建立键值对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc_mapping = &#123;val:index for index,val in enumerate(strings)&#125;</span><br></pre></td></tr></table></figure><p>假设你有一堆股票数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    &apos;ACME&apos;: 45.23,</span><br><span class="line">    &apos;AAPL&apos;: 612.78,</span><br><span class="line">    &apos;IBM&apos;: 205.55,</span><br><span class="line">    &apos;HPQ&apos;: 37.20,</span><br><span class="line">    &apos;FB&apos;: 10.75</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用字典推导来过滤这些数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 过滤出价格高于200的</span><br><span class="line">p1 = &#123;key: value for key, value in prices.items() if value &gt; 200&#125;</span><br><span class="line"></span><br><span class="line"># 找出科技公司</span><br><span class="line">tech_names = &#123;&apos;AAPL&apos;, &apos;IBM&apos;, &apos;HPQ&apos;, &apos;MSFT&apos;&#125;</span><br><span class="line">p2 = &#123;key: value for key, value in prices.items() if key in tech_names&#125;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的推导式和列表几乎一样，除了外面的括号不一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们需要一个集合，里面包含了所有集合元素的长度，那么可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_lengths = &#123;len(x) for x in strings&#125;</span><br></pre></td></tr></table></figure><p>利用map函数，可以更简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(map(len,strings))</span><br></pre></td></tr></table></figure><h2 id="复合推导"><a href="#复合推导" class="headerlink" title="复合推导"></a>复合推导</h2><p>假设我们有个二维数组包含了英语和西班牙语的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">all_data = [</span><br><span class="line">                [&apos;John&apos;, &apos;Emily&apos;, &apos;Michael&apos;, &apos;Mary&apos;, &apos;Steven&apos;],</span><br><span class="line">                [&apos;Maria&apos;, &apos;Juan&apos;, &apos;Javier&apos;, &apos;Natalia&apos;, &apos;Pilar&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们现在想要找出这两个子列表中，包含e字母的个数大于等于两个的，这样我们写一个复合推导:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = [name for names in all_data for name in names if name.count(&apos;e&apos;) &gt;=2 ]</span><br><span class="line">result = [&apos;Steven&apos;]</span><br></pre></td></tr></table></figure><p>这样写也许有点难以理解，再来看一个将元组合并成数组的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_tuples = [(1,2,3),(4,5,6),(7,8,9)]</span><br><span class="line">flattened = [x for tup in some_tuples for x in tup]</span><br><span class="line">flattened #输出 [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p>在[]中的表达式的顺序，其实和我们自己写的遍历数组是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flattened = []</span><br><span class="line">for tup in some_tuples:</span><br><span class="line">    for x in tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure><p>推导式尽管很方便，但是我们有时候也要从代码可读性上去思考问题，而不是让人在语法上面很困惑你写的代码，虽然这样也是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_tuples = [(1,2,3),(4,5,6),(7,8,9)]</span><br><span class="line">[[x for x in tup] for tup in some_tuples]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><em>Python for data analyse - List,Set, and Dict Comprehensions</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;推导式应该是python中最受喜爱的一部分内容了，它可以让你以一种简单的形式过滤原来的数据生成一份新的数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Built-in Data Structures in Python</title>
    <link href="http://wittyfans.com/coding/Built-in-Data-Structures-in-Python.html"/>
    <id>http://wittyfans.com/coding/Built-in-Data-Structures-in-Python.html</id>
    <published>2019-02-06T02:38:36.000Z</published>
    <updated>2019-02-06T04:05:28.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>元组、数组、字典、集合，及常用操作。</p></blockquote><a id="more"></a><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>元组内部元素确定以后，不可修改；如果元组里可以放数组，数组的元素是可以修改的，创建一个元组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup = 4,5,6</span><br></pre></td></tr></table></figure><p>嵌套元组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup = (4,5,6),(7,8,9)</span><br></pre></td></tr></table></figure><p>其实等于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup = ((4,5,6),(7,8,9))</span><br></pre></td></tr></table></figure><p>任何序列或可迭代的对象都可以转化为元组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple([3,4,5])</span><br><span class="line">tuple(&apos;string&apos;)</span><br></pre></td></tr></table></figure><p>通过tuple[]这种方式起来访问元组的内容。</p><p>元组可以相加，变成一个更长的元组，即a+b = ab；也可相乘，即ab*4 = abababab</p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>如果你尝试将元组赋值给多个变量，Python会尝试把元组拆开分别赋值给这些变量（即解包）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (1,2,3)</span><br><span class="line">a,b,c = tup</span><br></pre></td></tr></table></figure><p>这时候，a = 1, b = 2, c = 3;</p><p>嵌套的元组也是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (1,2,(3,4))</span><br><span class="line">a,b,(c,d) = tup</span><br></pre></td></tr></table></figure><p>这时候，d = 4；</p><p>在别的语言中，如果你要交换两个元素，需要这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure><p>python里面可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b,a = a,b</span><br></pre></td></tr></table></figure><p>解包还有一些其他的用法，比如按照元组的数据结构解包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [(1,2,3),(4,5,6),(7,8,9)]</span><br><span class="line">for a,b,c in seq:</span><br><span class="line">    print(&apos;a=&#123;&#125;,b=&#123;&#125;,c=&#123;&#125;&apos;.format(a,b,c))</span><br></pre></td></tr></table></figure><p>只提取前面几个元素，后面的放一起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = 1,2,3,4,5</span><br><span class="line">a,b,*rest = values</span><br></pre></td></tr></table></figure><p>元组有一个方法，可以统计特定的值在元组中出现的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (1,2,2,3)</span><br><span class="line">a.count(2) # 输出2,因为2出现了两次</span><br></pre></td></tr></table></figure><h2 id="命名元组"><a href="#命名元组" class="headerlink" title="命名元组"></a>命名元组</h2><blockquote><p>这部分为高级内容，看不懂的可以跳过。</p></blockquote><p>使用命名元组需要先导入,假设我们有一个故事Stock，里面有股票的名字，股份数量shares，还有股价price，那我们就可以设置一个命名元组如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line">Stock = namedtuple(&apos;Stock&apos;, [&apos;name&apos;, &apos;shares&apos;, &apos;price&apos;])</span><br></pre></td></tr></table></figure></p><p>同时我们可以定义一个函数用来计算市值，可以注意到，在这个函数内部，我们创建了一个命名元组对象s,有了这个对象以后，我们就可以直接调用s的shares和price属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def compute_cost(records):</span><br><span class="line">    total = 0.0</span><br><span class="line">    for rec in records:</span><br><span class="line">        s = Stock(*rec)</span><br><span class="line">        total += s.shares * s.price</span><br><span class="line">    return total</span><br></pre></td></tr></table></figure></p><p>我们也可以直接这样操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple = Stock(&apos;name&apos;,100,297)</span><br><span class="line">apple.shares * apple.price</span><br></pre></td></tr></table></figure><p>需注意这样会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compute_cost(&apos;apple&apos;,100,297) ---&gt; takes 1 positional argument but 3 were given</span><br></pre></td></tr></table></figure><p>命名元祖创建后不可修改，比如 apple.shares = 10 , 会报错。如果实在要改，可以使用apple = apple._replace(shares=10)，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。 这时候你应该考虑定义一个包含 <strong>slots</strong> 方法的类。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组相信大家都不陌生，数组可以包含None值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_list = [1,2,None]</span><br></pre></td></tr></table></figure><p>可以从元组转化而来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = (&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;)</span><br><span class="line">b_list = list(tup)</span><br></pre></td></tr></table></figure><p>可以按照索引来修改数组的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b_list[1] = &apos;peekaboo&apos;</span><br></pre></td></tr></table></figure><p>list可以直接转化生成器或者迭代器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen = range(10)</span><br><span class="line">gen # 输出range(0,10)</span><br><span class="line"></span><br><span class="line">list(gen) # 输出[0,1,2,3,4,5,6,7,8,9,10]</span><br></pre></td></tr></table></figure><h2 id="添加、删除"><a href="#添加、删除" class="headerlink" title="添加、删除"></a>添加、删除</h2><p>使用append方法即可往数组添加元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">values.append(&apos;c&apos;)</span><br></pre></td></tr></table></figure><p>也可以使用insert方法向指定的位置插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values.sert(1,&apos;-&apos;)</span><br><span class="line">values 输出# [&apos;a&apos;,&apos;-&apos;,&apos;b&apos;,&apos;c&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>insert比append要花费更多的资源，因为insert后，其后面的元素都要挪位置，如果你要在数组的首尾操作，可以去看看collections.deque</p></blockquote><p>相反的，我们可以使用pop方法来取出指定位置的元素, 这时候后面的元素也都会往前面移动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.pop(0) # a</span><br></pre></td></tr></table></figure><p>也可以直接根据值来删除某个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.remove(&apos;b&apos;)</span><br></pre></td></tr></table></figure><p>检查某个元素是否在数组中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; in [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">&apos;a&apos; not in [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>在数组是否包含某个元素，比字典和sets要慢的多。</p></blockquote><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>数组的相加，即首尾相连，a+b = ab; 数组的相加需要创建新的数组，还要进行复制运算，所以耗费的资源会比较多，所以我们一般使用extend方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;]+[&apos;b&apos;] # [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">[&apos;a&apos;].extend([&apos;b&apos;])</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>你可以直接排序一个数组，且不需要创建一个新的数组，只需要调用sort方法即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [7,2,1]</span><br><span class="line">a.sort()</span><br><span class="line">a #输出 [1,2,7]</span><br></pre></td></tr></table></figure><p>sort接收第二个参数，可以定义sort的条件，比如我们通过字符的长度来排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = [&apos;saw&apos;,&apos;small&apos;,&apos;he&apos;,&apos;six&apos;]</span><br><span class="line">b.sort(key=len)</span><br></pre></td></tr></table></figure><h2 id="二分查找与操作"><a href="#二分查找与操作" class="headerlink" title="二分查找与操作"></a>二分查找与操作</h2><p>python内置了一个bisect模块，实现了基于二分查找的算法，在列表中查找元素可以使用 list.index() 方法，其时间复杂度为O(n)。对于大数据量，则可以用二分查找进行优化，二分查找也成为折半查找，算法每一次比较都使搜索范围缩小一半， 其时间复杂度为 O(logn)，需要注意，二分查找要求对象必须有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = [1,2,2,2,3,4,7]</span><br><span class="line">bisect.bisect(c,2) # 返回会插入的位置，即索引4</span><br><span class="line">bisect.bisect(c,5) # 返回5</span><br><span class="line">bisect.insort(c,6) # 插入到4后面</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>通过将形如start:stoped的格式传给[],就可以在序列对象中切出你想要的部分，举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq = [6,5,3,5,7,2]</span><br><span class="line">seq[2:4] # 输出 [3, 5]</span><br></pre></td></tr></table></figure><p>切片也可以赋值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq[2:4] = [0,0]</span><br><span class="line">seq # 输出 [6, 5, 0, 0, 7, 2]</span><br></pre></td></tr></table></figure><p>如果你要选择之前或者之后的所有值，将一边省略即可，比如我要选择index=3之后的所有值，即[3:]。</p><p>你甚至可以指定步长，也就是隔多远选一个值，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [6,5,3,5,7,2]</span><br><span class="line">seq[::2] # 输出 [6, 3, 7]</span><br><span class="line">seq[::3] # 输出 [6, 5]</span><br></pre></td></tr></table></figure><p>如果你想将数组反转，将步长设为-1试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq = [6,5,3,5,7,2]</span><br><span class="line">seq[::-1] # 输出[2, 7, 5, 3, 5, 6]</span><br></pre></td></tr></table></figure><h1 id="内置的序列函数"><a href="#内置的序列函数" class="headerlink" title="内置的序列函数"></a>内置的序列函数</h1><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><p>在用for in循环一个序列的时候，我们经常想要跟踪index，为此你可能会声明一个i来记录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">for v in values:</span><br><span class="line">    ...</span><br><span class="line">    i+=1</span><br></pre></td></tr></table></figure><p>不过python已经内置了一个函数，可以帮到你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for index,value in enumerate([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]):</span><br><span class="line">    print(value,index)</span><br></pre></td></tr></table></figure><p>这里的index就是你想要的那个i了。enumerate在将列表转化为字典的时候尤其方便:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some_list = [&apos;for&apos;,&apos;bar&apos;,&apos;baz&apos;]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line">for i,v in enumerate(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">    </span><br><span class="line">#输出: &#123;&apos;bar&apos;:1,&apos;baz&apos;:2,&apos;foo&apos;:0&#125;</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted函数接收一个序列对象，排序后返回一个新的。</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip会将两个序列中的元素一一对应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq1 = [&apos;scott&apos;,&apos;frank&apos;,&apos;jason&apos;]</span><br><span class="line">seq2 = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]</span><br><span class="line">zipped = zip(seq1,seq2)</span><br><span class="line">list(zipped) # 输出: [(&apos;scott&apos;,&apos;1&apos;),(&apos;frank&apos;,&apos;2&apos;),(&apos;jason&apos;,&apos;3&apos;)]</span><br></pre></td></tr></table></figure><p>zip可以接受3个序列一一对应，对应关系按照最短的处理。</p><p>将如上函数结合，可以实现一些很骚的写法，看下面的例子，将序列结合并按顺序打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i (a,b) in enmerate(zip(se1,seq2)):</span><br><span class="line">    print(&apos;&#123;&#125;:&#123;&#125;,&#123;&#125;&apos;.format(i,a,b))</span><br></pre></td></tr></table></figure></p><p>统计名和姓：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pitchers = [(&apos;Nolan&apos;, &apos;Ryan&apos;), (&apos;Roger&apos;, &apos;Clemens&apos;),(&apos;Schilling&apos;, &apos;Curt&apos;)]</span><br><span class="line"></span><br><span class="line">first_names, last_names = zip(*pitchers)</span><br><span class="line"></span><br><span class="line">first_names # (&apos;Nolan&apos;, &apos;Roger&apos;, &apos;Schilling&apos;)</span><br><span class="line"></span><br><span class="line">last_names # (&apos;Ryan&apos;, &apos;Clemens&apos;, &apos;Curt&apos;)</span><br></pre></td></tr></table></figure><h2 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(reversed(range(10)))</span><br></pre></td></tr></table></figure><p>reversed返回一个生成器，如果你想要取出其中数据，需要用list包装一下。</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是python中最重要的数据结构之一，创建dict很简单，直接使用花括号就创建了一个dict。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br></pre></td></tr></table></figure><p>增加元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d[1] = &apos;hi&apos;</span><br><span class="line">d[&apos;one&apos;] = 1</span><br></pre></td></tr></table></figure><p>检查字典中是否有某个key(检查的不是values，而是key)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 in d</span><br></pre></td></tr></table></figure><p>删除字典中的值，可以用del命令，或者pop方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[&apos;v&apos;] = 10</span><br><span class="line">d[&apos;C&apos;] = 11</span><br><span class="line">del d[&apos;v&apos;]</span><br><span class="line"></span><br><span class="line">ret = d.pop(&apos;C&apos;)</span><br><span class="line">ret # 11</span><br></pre></td></tr></table></figure><p>pop方法会返回删除的元素。</p><p>可以直接使用d.keys()，和d.values()方法访问dict的所有keys和values。</p><p>使用d.update()方法，可以将两个dict合并。</p><p>从两个序列创建一个字典，你也许会准备一个index列表和values列表，再用for循环手动创建，大可不必。你可以直接使用dict+zip函数来定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping = dict(zip(indexs,values))</span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>检测dict是否拥有某个值，如果有就取出来，没有就设置默认值，这应该是很常用的操作了，为此你可能会写如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if key in some_dict:</span><br><span class="line">    value = some_dict[key]</span><br><span class="line">else:</span><br><span class="line">    value = default_value</span><br></pre></td></tr></table></figure><p>使用dict内置的get方法，可以让你的代码更简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = some_dict.get(key,default_value)</span><br></pre></td></tr></table></figure><p>如果你有一堆字符串需要按照首字母分类，你可能会这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">words = [&apos;apple&apos;,&apos;bat&apos;,&apos;bar&apos;,&apos;atom&apos;,&apos;book&apos;]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for word in words:</span><br><span class="line">letter = word[0]</span><br><span class="line">if letter not in by_letter:</span><br><span class="line">    by_letter[letter] = [word]</span><br><span class="line">else:</span><br><span class="line">    by_letter[letter].append(word)</span><br></pre></td></tr></table></figure><p>借助dict的setdefault方法，可以让你的代码更简洁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">words = [&apos;apple&apos;,&apos;bat&apos;,&apos;bar&apos;,&apos;atom&apos;,&apos;book&apos;]</span><br><span class="line">by_letter = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="key的类型"><a href="#key的类型" class="headerlink" title="key的类型"></a>key的类型</h2><p>字典的值可以是任何python的对象，而key则不行，必须是不可变类型，你可以用hash函数去检测，如果能返回值，说明它可以作为字典的key，如果报错就不行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(&apos;string&apos;) # ok</span><br><span class="line">hash((1,2,[2,3])) # 报错，因为list是可变的</span><br></pre></td></tr></table></figure><p>如果一定要list作为键，可以先将它转化成元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[tuple([1,2,3])] = 5</span><br><span class="line">d</span><br></pre></td></tr></table></figure><h2 id="字典高级用法"><a href="#字典高级用法" class="headerlink" title="字典高级用法"></a>字典高级用法</h2><p>collection模块对字典也提供了很多方便的方法：</p><h3 id="多个字典遍历"><a href="#多个字典遍历" class="headerlink" title="多个字典遍历"></a>多个字典遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from collections import ChainMap</span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line">print(c[&apos;x&apos;]) # Outputs 1 (from a)</span><br><span class="line">print(c[&apos;y&apos;]) # Outputs 2 (from b)</span><br><span class="line">print(c[&apos;z&apos;]) # Outputs 3 (from a)</span><br></pre></td></tr></table></figure><h2 id="字典合并"><a href="#字典合并" class="headerlink" title="字典合并"></a>字典合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&apos;x&apos;: 1, &apos;z&apos;: 3 &#125;</span><br><span class="line">b = &#123;&apos;y&apos;: 2, &apos;z&apos;: 4 &#125;</span><br><span class="line">merged = ChainMap(a, b)</span><br><span class="line">merged[&apos;x&apos;] # 输出 1</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">a[&apos;x&apos;] = 42</span><br><span class="line">merged[&apos;x&apos;] # 输出42</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是没有顺序关系的元素放在一起。你可以想象成是字典中，只有key，没有值。字典的创建有两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set([1,2,3,4])</span><br><span class="line">&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure><p>集合支持数学层面的运算，比如交集、并集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a =&#123;1,2,3,4,5,6,7,8&#125;</span><br><span class="line">b = &#123;3,4,5,6,7,8&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.union(b) 或者 a | b</span><br><span class="line">a.intersection(b) 或者 a &amp; b</span><br><span class="line"></span><br><span class="line">&#123;1,2,3&#125;.issubset(a)</span><br></pre></td></tr></table></figure><p>更多的运算规则可以去网上查查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;元组、数组、字典、集合，及常用操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Dash 基础</title>
    <link href="http://wittyfans.com/coding/Dash-%E5%9F%BA%E7%A1%80.html"/>
    <id>http://wittyfans.com/coding/Dash-基础.html</id>
    <published>2019-01-31T13:48:29.000Z</published>
    <updated>2019-01-31T14:11:46.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dash是一个高效的 Web APP构建框架，这个部分包含了Dash的安装，dash中的layout，如何去个性化dash中的html元素，以及复用dash的元素，如何使用dash的回调函数，实时数据监控等.</p></blockquote><a id="more"></a><h1 id="Dash-的特点"><a href="#Dash-的特点" class="headerlink" title="Dash 的特点"></a>Dash 的特点</h1><p>Dash is a productive Python framework for building web applications,This part contains dash install, layout of dash, how to style the html tag in dash, using the callbacks, update data in real time,etc.</p><ul><li>building data visualization apps</li><li>Inherently cross-platform and mobile ready</li></ul><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>如果直接pip install dash,那在导入某些组件（例如我导入Event组件）的时候会提示找不到包，后面我重新通过指定dash官方文档中的命令重新安装后，成功解决了该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install dash==0.35.1  # The core dash backend</span><br><span class="line">pip install dash-html-components==0.13.4  # HTML components</span><br><span class="line">pip install dash-core-components==0.42.1  # Supercharged components</span><br><span class="line">pip install dash-table==3.1.11  # Interactive DataTable component (new!)</span><br></pre></td></tr></table></figure><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><h2 id="Hello-Dash"><a href="#Hello-Dash" class="headerlink" title="Hello Dash"></a>Hello Dash</h2><blockquote><p>Layout描述了该app是什么样子,所有的可视化组建都用python类来定义，主要有两种dash_core_components和dash_html_components，不过你也可以定义自己的js和react.js类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div(children=[</span><br><span class="line">    html.H1(children=&apos;Hello Dash&apos;),</span><br><span class="line"></span><br><span class="line">    html.Div(children=&apos;&apos;&apos;</span><br><span class="line">        Dash: A web application framework for Python.</span><br><span class="line">    &apos;&apos;&apos;),</span><br><span class="line"></span><br><span class="line">    dcc.Graph(</span><br><span class="line">        id=&apos;example-graph&apos;,</span><br><span class="line">        figure=&#123;</span><br><span class="line">            &apos;data&apos;: [</span><br><span class="line">                &#123;&apos;x&apos;: [1, 2, 3], &apos;y&apos;: [4, 1, 2], &apos;type&apos;: &apos;bar&apos;, &apos;name&apos;: &apos;SF&apos;&#125;,</span><br><span class="line">                &#123;&apos;x&apos;: [1, 2, 3], &apos;y&apos;: [2, 4, 5], &apos;type&apos;: &apos;bar&apos;, &apos;name&apos;: u&apos;Montréal&apos;&#125;,</span><br><span class="line">            ],</span><br><span class="line">            &apos;layout&apos;: &#123;</span><br><span class="line">                &apos;title&apos;: &apos;Dash Data Visualization&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><p>html.Div()是一个div组件，其中可以增加子元素，方法是直接在里面定义children即可，children在html组件中是可以嵌套的，所以在H1元素中，你还可以继续定义children，通过这种嵌套关系，你就可以构建需要的网页元素。</p><p>dcc.Graph()是一个图形元素，其id是这个对象的id，通常我们可以通过这个id来找到这个元素，并与其交互。<br>figure是这个图形对象的数据，比如最重要的数据，以及该图的标题。</p><p>最后，app.run_server(debug=True)会启动服务，我们可以进入到当前文件夹，将该python文件直接运行，随后即可看到相关的服务启动，通过dash提供网址就可以看到app的页面了。</p><p>下面是一些注意事项：</p><ul><li>The dash_core_components describe higher-level components that are interactive and are generated with JavaScript, HTML, and CSS through the React.js library.</li><li>html.H1(children=’Hello Dash’) is the same as html.H1(‘Hello Dash’)</li></ul><p>Dash是 hot-reloading 的，即如果你的app已经运行起来了，你做了任何更改，网页都会自动刷新，你可以直接看到新的变化。</p><blockquote><p>Dash will automatically refresh your browser when you make a change in your code.</p></blockquote><h2 id="Style-html"><a href="#Style-html" class="headerlink" title="Style html"></a>Style html</h2><p>Dash的元素都可以自定义，你可以通过自定义CSS的方式来更改元素的属性和排版，还是上面的代码，可以对比下面和上面的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">colors = &#123;</span><br><span class="line">    &apos;background&apos;: &apos;#111111&apos;,</span><br><span class="line">    &apos;text&apos;: &apos;#7FDBFF&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.layout = html.Div(style=&#123;&apos;backgroundColor&apos;: colors[&apos;background&apos;]&#125;, children=[</span><br><span class="line">    html.H1(</span><br><span class="line">        children=&apos;Hello Dash&apos;,</span><br><span class="line">        style=&#123;</span><br><span class="line">            &apos;textAlign&apos;: &apos;center&apos;,</span><br><span class="line">            &apos;color&apos;: colors[&apos;text&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    html.Div(children=&apos;Dash: A web application framework for Python.&apos;, style=&#123;</span><br><span class="line">        &apos;textAlign&apos;: &apos;center&apos;,</span><br><span class="line">        &apos;color&apos;: colors[&apos;text&apos;]</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    dcc.Graph(</span><br><span class="line">        id=&apos;example-graph-2&apos;,</span><br><span class="line">        figure=&#123;</span><br><span class="line">            &apos;data&apos;: [</span><br><span class="line">                &#123;&apos;x&apos;: [1, 2, 3], &apos;y&apos;: [4, 1, 2], &apos;type&apos;: &apos;bar&apos;, &apos;name&apos;: &apos;SF&apos;&#125;,</span><br><span class="line">                &#123;&apos;x&apos;: [1, 2, 3], &apos;y&apos;: [2, 4, 5], &apos;type&apos;: &apos;bar&apos;, &apos;name&apos;: u&apos;Montréal&apos;&#125;,</span><br><span class="line">            ],</span><br><span class="line">            &apos;layout&apos;: &#123;</span><br><span class="line">                &apos;plot_bgcolor&apos;: colors[&apos;background&apos;],</span><br><span class="line">                &apos;paper_bgcolor&apos;: colors[&apos;background&apos;],</span><br><span class="line">                &apos;font&apos;: &#123;</span><br><span class="line">                    &apos;color&apos;: colors[&apos;text&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><p>需要注意dash html组件和html元素的区别：</p><ol><li>HTML中的style属性是以分号分隔的字符串。在Dash中用字典</li><li>The children of the HTML tag is specified through the children keyword argument. By convention, this is always the first argument and so it is often omitted.</li></ol><h2 id="复用组件"><a href="#复用组件" class="headerlink" title="复用组件"></a>复用组件</h2><h2 id="Pandas-dataframe到table"><a href="#Pandas-dataframe到table" class="headerlink" title="Pandas dataframe到table"></a>Pandas dataframe到table</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(</span><br><span class="line">    &apos;https://gist.githubusercontent.com/chriddyp/&apos;</span><br><span class="line">    &apos;c78bf172206ce24f77d6363a2d754b59/raw/&apos;</span><br><span class="line">    &apos;c353e8ef842413cae56ae3920b8fd78468aa4cb2/&apos;</span><br><span class="line">    &apos;usa-agricultural-exports-2011.csv&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_table(dataframe, max_rows=10):</span><br><span class="line">    return html.Table(</span><br><span class="line">        # Header</span><br><span class="line">        [html.Tr([html.Th(col) for col in dataframe.columns])] +</span><br><span class="line"></span><br><span class="line">        # Body</span><br><span class="line">        [html.Tr([</span><br><span class="line">            html.Td(dataframe.iloc[i][col]) for col in dataframe.columns</span><br><span class="line">        ]) for i in range(min(len(dataframe), max_rows))]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div(children=[</span><br><span class="line">    html.H4(children=&apos;US Agriculture Exports (2011)&apos;),</span><br><span class="line">    generate_table(df)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><h2 id="更多的可视化组件"><a href="#更多的可视化组件" class="headerlink" title="更多的可视化组件"></a>更多的可视化组件</h2><p>dash_core_components库中，有一个Graph的组件，这是一个绘制可交互的可视化组建，使用开源的plotly.js，支持35种图像绘制。</p><p>graph中的figure参数，跟plotly.py中的figure参数是一样的，你可以参考<a href="https://plot.ly/python/" target="_blank" rel="noopener">plotly</a>的官方文档了解更多。</p><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><p>dash支持markdown,用‘’‘括起来，然后在其中写markdown即可，最后在html中，将children指定为该markdown格式的string对象。</p><h2 id="Core-Components"><a href="#Core-Components" class="headerlink" title="Core Components"></a>Core Components</h2><p>The dash_core_components includes a set of higher-level components like dropdowns, graphs, markdown blocks, and more.</p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>你可以在python命令行中，使用help(dcc.Dropdown)类似形式来了解dash的元素。</p><h2 id="Layout-总结"><a href="#Layout-总结" class="headerlink" title="Layout 总结"></a>Layout 总结</h2><p>The layout of a Dash app describes what the app looks like. The layout is a hierarchical tree of components. The dash_html_components library provides classes for all of the HTML tags and the keyword arguments describe the HTML attributes like style, className, and id. The dash_core_components library generates higher-level components like controls and graphs.</p><h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>在上一章，我们学习dash的基本组件，长什么样子，html模块提供了许多python实现的html类，可以用来构建html元素，同时你也可以使用html的属性如stile，classname，id来自定义html的元素。</p><p>这一章，我们来看看如何和Dash交互。</p><h2 id="实时数据跟踪"><a href="#实时数据跟踪" class="headerlink" title="实时数据跟踪"></a>实时数据跟踪</h2><p>首先看一个实时数据显示的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html #for tags like div,table</span><br><span class="line">from dash.dependencies import Input,Output</span><br><span class="line"></span><br><span class="line">app = dash.Dash() # dash is a flask app</span><br><span class="line">app.layout = html.Div(children=[</span><br><span class="line">    dcc.Input(id=&apos;input&apos;,value=&apos;Enter something&apos;,type=&apos;text&apos;)</span><br><span class="line">    html.Div(id=&apos;output&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">@app.callback(</span><br><span class="line">    Output(component_id=&apos;output&apos;,component_property=&apos;children&apos;),</span><br><span class="line">    [Input(component_id=&apos;input&apos;,component_property=&apos;value&apos;)]</span><br><span class="line">)</span><br><span class="line">def update_value(input_data): # update_value并没有在哪里运行，这个效果是怎么实现的？当input更新的时候，被装饰器包裹的函数，会自动运行</span><br><span class="line">    return &quot;Input: &#123;&#125;&quot;.format(input_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run_server(debug=True)</span><br></pre></td></tr></table></figure><ul><li>在children中，使用的是dcc.Input，不是dependencies中的</li><li>dcc.Input()基本上是类似html中的文本输入框,且必须指定id</li><li>@可以理解为，在之后的函数即update_value运行后，对它的返回值进行二次处理（装饰），在这类是更新网页中的值</li><li>当input更新的时候，被装饰器包裹的函数，会自动运行</li><li>component_id和component_property是可以省略的,The component_id and component_property keywords are optional</li><li>注意到，我们没有去设置input的初值，事实上，dash运行的时候，会先调用一遍callback，这样就能达到设置初始值的目的</li></ul><p>看一下官方的文档:</p><p><em>In Dash, the inputs and outputs of our application are simply the properties of a particular component. In this example, our input is the “value” property of the component that has the ID “my-id”. Our output is the “children” property of the component with the ID “my-div”.</em></p><p>那么，为什么output是 Output() 这样的，input是 [input()] 的呢？</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/fd746acbdf1e" target="_blank" rel="noopener">装饰器</a></li><li><a href="https://dash.plot.ly/getting-started-part-2" target="_blank" rel="noopener">关于这一节的更多例子与解答</a></li></ul><h2 id="Slider图绘制"><a href="#Slider图绘制" class="headerlink" title="Slider图绘制"></a>Slider图绘制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line">import pandas as pd</span><br><span class="line">import plotly.graph_objs as go</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(</span><br><span class="line">    &apos;https://raw.githubusercontent.com/plotly/&apos;</span><br><span class="line">    &apos;datasets/master/gapminderDataFiveYear.csv&apos;)</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div([</span><br><span class="line">    dcc.Graph(id=&apos;graph-with-slider&apos;),</span><br><span class="line">    dcc.Slider(</span><br><span class="line">        id=&apos;year-slider&apos;,</span><br><span class="line">        min=df[&apos;year&apos;].min(),</span><br><span class="line">        max=df[&apos;year&apos;].max(),</span><br><span class="line">        value=df[&apos;year&apos;].min(),</span><br><span class="line">        marks=&#123;str(year): str(year) for year in df[&apos;year&apos;].unique()&#125;</span><br><span class="line">    )</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.callback(</span><br><span class="line">    dash.dependencies.Output(&apos;graph-with-slider&apos;, &apos;figure&apos;),</span><br><span class="line">    [dash.dependencies.Input(&apos;year-slider&apos;, &apos;value&apos;)])</span><br><span class="line">def update_figure(selected_year):</span><br><span class="line">    filtered_df = df[df.year == selected_year]</span><br><span class="line">    traces = []</span><br><span class="line">    for i in filtered_df.continent.unique():</span><br><span class="line">        df_by_continent = filtered_df[filtered_df[&apos;continent&apos;] == i]</span><br><span class="line">        traces.append(go.Scatter(</span><br><span class="line">            x=df_by_continent[&apos;gdpPercap&apos;],</span><br><span class="line">            y=df_by_continent[&apos;lifeExp&apos;],</span><br><span class="line">            text=df_by_continent[&apos;country&apos;],</span><br><span class="line">            mode=&apos;markers&apos;,</span><br><span class="line">            opacity=0.7,</span><br><span class="line">            marker=&#123;</span><br><span class="line">                &apos;size&apos;: 15,</span><br><span class="line">                &apos;line&apos;: &#123;&apos;width&apos;: 0.5, &apos;color&apos;: &apos;white&apos;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            name=i</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;data&apos;: traces,</span><br><span class="line">        &apos;layout&apos;: go.Layout(</span><br><span class="line">            xaxis=&#123;&apos;type&apos;: &apos;log&apos;, &apos;title&apos;: &apos;GDP Per Capita&apos;&#125;,</span><br><span class="line">            yaxis=&#123;&apos;title&apos;: &apos;Life Expectancy&apos;, &apos;range&apos;: [20, 90]&#125;,</span><br><span class="line">            margin=&#123;&apos;l&apos;: 40, &apos;b&apos;: 40, &apos;t&apos;: 10, &apos;r&apos;: 10&#125;,</span><br><span class="line">            legend=&#123;&apos;x&apos;: 0, &apos;y&apos;: 1&#125;,</span><br><span class="line">            hovermode=&apos;closest&apos;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><ul><li>使用pandas读取数据</li><li>dcc.Slider()指定来Slider图的基本属性</li><li>当数据有更新的时候，update_figure方法就会被调用</li><li>go.Scatter定义了每一个Scatter应该是什么样子，其中的数据从df中分析得到</li><li>traces是所有Scatter组成的数组，也是该图的数据源</li></ul><p>⚠️：The callback does not modify the original data, it just creates copies of the dataframe by filtered through pandas filters. This is important: <strong>Your callbacks should never mutate variables outside of their scope</strong></p><h2 id="多个输入"><a href="#多个输入" class="headerlink" title="多个输入"></a>多个输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line">import pandas as pd</span><br><span class="line">import plotly.graph_objs as go</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(</span><br><span class="line">    &apos;https://gist.githubusercontent.com/chriddyp/&apos;</span><br><span class="line">    &apos;cb5392c35661370d95f300086accea51/raw/&apos;</span><br><span class="line">    &apos;8e0768211f6b747c0db42a9ce9a0937dafcbd8b2/&apos;</span><br><span class="line">    &apos;indicators.csv&apos;)</span><br><span class="line"></span><br><span class="line">available_indicators = df[&apos;Indicator Name&apos;].unique()</span><br><span class="line"></span><br><span class="line">app.layout = html.Div([</span><br><span class="line">    html.Div([</span><br><span class="line"></span><br><span class="line">        html.Div([</span><br><span class="line">            dcc.Dropdown(</span><br><span class="line">                id=&apos;xaxis-column&apos;,</span><br><span class="line">                options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in available_indicators],</span><br><span class="line">                value=&apos;Fertility rate, total (births per woman)&apos;</span><br><span class="line">            ),</span><br><span class="line">            dcc.RadioItems(</span><br><span class="line">                id=&apos;xaxis-type&apos;,</span><br><span class="line">                options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in [&apos;Linear&apos;, &apos;Log&apos;]],</span><br><span class="line">                value=&apos;Linear&apos;,</span><br><span class="line">                labelStyle=&#123;&apos;display&apos;: &apos;inline-block&apos;&#125;</span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">        style=&#123;&apos;width&apos;: &apos;48%&apos;, &apos;display&apos;: &apos;inline-block&apos;&#125;),</span><br><span class="line"></span><br><span class="line">        html.Div([</span><br><span class="line">            dcc.Dropdown(</span><br><span class="line">                id=&apos;yaxis-column&apos;,</span><br><span class="line">                options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in available_indicators],</span><br><span class="line">                value=&apos;Life expectancy at birth, total (years)&apos;</span><br><span class="line">            ),</span><br><span class="line">            dcc.RadioItems(</span><br><span class="line">                id=&apos;yaxis-type&apos;,</span><br><span class="line">                options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in [&apos;Linear&apos;, &apos;Log&apos;]],</span><br><span class="line">                value=&apos;Linear&apos;,</span><br><span class="line">                labelStyle=&#123;&apos;display&apos;: &apos;inline-block&apos;&#125;</span><br><span class="line">            )</span><br><span class="line">        ],style=&#123;&apos;width&apos;: &apos;48%&apos;, &apos;float&apos;: &apos;right&apos;, &apos;display&apos;: &apos;inline-block&apos;&#125;)</span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    dcc.Graph(id=&apos;indicator-graphic&apos;),</span><br><span class="line"></span><br><span class="line">    dcc.Slider(</span><br><span class="line">        id=&apos;year--slider&apos;,</span><br><span class="line">        min=df[&apos;Year&apos;].min(),</span><br><span class="line">        max=df[&apos;Year&apos;].max(),</span><br><span class="line">        value=df[&apos;Year&apos;].max(),</span><br><span class="line">        marks=&#123;str(year): str(year) for year in df[&apos;Year&apos;].unique()&#125;</span><br><span class="line">    )</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">@app.callback(</span><br><span class="line">    dash.dependencies.Output(&apos;indicator-graphic&apos;, &apos;figure&apos;),</span><br><span class="line">    [dash.dependencies.Input(&apos;xaxis-column&apos;, &apos;value&apos;),</span><br><span class="line">     dash.dependencies.Input(&apos;yaxis-column&apos;, &apos;value&apos;),</span><br><span class="line">     dash.dependencies.Input(&apos;xaxis-type&apos;, &apos;value&apos;),</span><br><span class="line">     dash.dependencies.Input(&apos;yaxis-type&apos;, &apos;value&apos;),</span><br><span class="line">     dash.dependencies.Input(&apos;year--slider&apos;, &apos;value&apos;)])</span><br><span class="line">def update_graph(xaxis_column_name, yaxis_column_name,</span><br><span class="line">                 xaxis_type, yaxis_type,</span><br><span class="line">                 year_value):</span><br><span class="line">    dff = df[df[&apos;Year&apos;] == year_value]</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;data&apos;: [go.Scatter(</span><br><span class="line">            x=dff[dff[&apos;Indicator Name&apos;] == xaxis_column_name][&apos;Value&apos;],</span><br><span class="line">            y=dff[dff[&apos;Indicator Name&apos;] == yaxis_column_name][&apos;Value&apos;],</span><br><span class="line">            text=dff[dff[&apos;Indicator Name&apos;] == yaxis_column_name][&apos;Country Name&apos;],</span><br><span class="line">            mode=&apos;markers&apos;,</span><br><span class="line">            marker=&#123;</span><br><span class="line">                &apos;size&apos;: 15,</span><br><span class="line">                &apos;opacity&apos;: 0.5,</span><br><span class="line">                &apos;line&apos;: &#123;&apos;width&apos;: 0.5, &apos;color&apos;: &apos;white&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )],</span><br><span class="line">        &apos;layout&apos;: go.Layout(</span><br><span class="line">            xaxis=&#123;</span><br><span class="line">                &apos;title&apos;: xaxis_column_name,</span><br><span class="line">                &apos;type&apos;: &apos;linear&apos; if xaxis_type == &apos;Linear&apos; else &apos;log&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            yaxis=&#123;</span><br><span class="line">                &apos;title&apos;: yaxis_column_name,</span><br><span class="line">                &apos;type&apos;: &apos;linear&apos; if yaxis_type == &apos;Linear&apos; else &apos;log&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            margin=&#123;&apos;l&apos;: 40, &apos;b&apos;: 40, &apos;t&apos;: 10, &apos;r&apos;: 0&#125;,</span><br><span class="line">            hovermode=&apos;closest&apos;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><h2 id="多个输出"><a href="#多个输出" class="headerlink" title="多个输出"></a>多个输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div([</span><br><span class="line">    dcc.RadioItems(</span><br><span class="line">        id=&apos;dropdown-a&apos;,</span><br><span class="line">        options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in [&apos;Canada&apos;, &apos;USA&apos;, &apos;Mexico&apos;]],</span><br><span class="line">        value=&apos;Canada&apos;</span><br><span class="line">    ),</span><br><span class="line">    html.Div(id=&apos;output-a&apos;),</span><br><span class="line"></span><br><span class="line">    dcc.RadioItems(</span><br><span class="line">        id=&apos;dropdown-b&apos;,</span><br><span class="line">        options=[&#123;&apos;label&apos;: i, &apos;value&apos;: i&#125; for i in [&apos;MTL&apos;, &apos;NYC&apos;, &apos;SF&apos;]],</span><br><span class="line">        value=&apos;MTL&apos;</span><br><span class="line">    ),</span><br><span class="line">    html.Div(id=&apos;output-b&apos;)</span><br><span class="line"></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.callback(</span><br><span class="line">    dash.dependencies.Output(&apos;output-a&apos;, &apos;children&apos;),</span><br><span class="line">    [dash.dependencies.Input(&apos;dropdown-a&apos;, &apos;value&apos;)])</span><br><span class="line">def callback_a(dropdown_value):</span><br><span class="line">    return &apos;You\&apos;ve selected &quot;&#123;&#125;&quot;&apos;.format(dropdown_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.callback(</span><br><span class="line">    dash.dependencies.Output(&apos;output-b&apos;, &apos;children&apos;),</span><br><span class="line">    [dash.dependencies.Input(&apos;dropdown-b&apos;, &apos;value&apos;)])</span><br><span class="line">def callback_b(dropdown_value):</span><br><span class="line">    return &apos;You\&apos;ve selected &quot;&#123;&#125;&quot;&apos;.format(dropdown_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><h1 id="状态监听"><a href="#状态监听" class="headerlink" title="状态监听"></a>状态监听</h1><p>之前的代码中，dash会对我们的输入实时监听，一旦有变化就dash就会去更新数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line">from dash.dependencies import Input, Output</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div([</span><br><span class="line">    dcc.Input(id=&apos;input-1&apos;, type=&apos;text&apos;, value=&apos;Montréal&apos;),</span><br><span class="line">    dcc.Input(id=&apos;input-2&apos;, type=&apos;text&apos;, value=&apos;Canada&apos;),</span><br><span class="line">    html.Div(id=&apos;output&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.callback(Output(&apos;output&apos;, &apos;children&apos;),</span><br><span class="line">              [Input(&apos;input-1&apos;, &apos;value&apos;),</span><br><span class="line">               Input(&apos;input-2&apos;, &apos;value&apos;)])</span><br><span class="line">def update_output(input1, input2):</span><br><span class="line">    return u&apos;Input 1 is &quot;&#123;&#125;&quot; and Input 2 is &quot;&#123;&#125;&quot;&apos;.format(input1, input2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure><p>但有时候我们不想这样，我们希望定义一个按钮，等我们输入好了，自己点击按钮来让dash识别，这时候可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import dash</span><br><span class="line">import dash_core_components as dcc</span><br><span class="line">import dash_html_components as html</span><br><span class="line">from dash.dependencies import Input, Output, State</span><br><span class="line"></span><br><span class="line">external_stylesheets = [&apos;https://codepen.io/chriddyp/pen/bWLwgP.css&apos;]</span><br><span class="line"></span><br><span class="line">app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span><br><span class="line"></span><br><span class="line">app.layout = html.Div([</span><br><span class="line">    dcc.Input(id=&apos;input-1-state&apos;, type=&apos;text&apos;, value=&apos;Montréal&apos;),</span><br><span class="line">    dcc.Input(id=&apos;input-2-state&apos;, type=&apos;text&apos;, value=&apos;Canada&apos;),</span><br><span class="line">    html.Button(id=&apos;submit-button&apos;, n_clicks=0, children=&apos;Submit&apos;),</span><br><span class="line">    html.Div(id=&apos;output-state&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.callback(Output(&apos;output-state&apos;, &apos;children&apos;),</span><br><span class="line">              [Input(&apos;submit-button&apos;, &apos;n_clicks&apos;)],</span><br><span class="line">              [State(&apos;input-1-state&apos;, &apos;value&apos;),</span><br><span class="line">               State(&apos;input-2-state&apos;, &apos;value&apos;)])</span><br><span class="line">def update_output(n_clicks, input1, input2):</span><br><span class="line">    return u&apos;&apos;&apos;</span><br><span class="line">        The Button has been pressed &#123;&#125; times,</span><br><span class="line">        Input 1 is &quot;&#123;&#125;&quot;,</span><br><span class="line">        and Input 2 is &quot;&#123;&#125;&quot;</span><br><span class="line">    &apos;&apos;&apos;.format(n_clicks, input1, input2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run_server(debug=True)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Dash是一个高效的 Web APP构建框架，这个部分包含了Dash的安装，dash中的layout，如何去个性化dash中的html元素，以及复用dash的元素，如何使用dash的回调函数，实时数据监控等.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="web" scheme="http://wittyfans.com/tags/web/"/>
    
      <category term="dash" scheme="http://wittyfans.com/tags/dash/"/>
    
      <category term="data" scheme="http://wittyfans.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>Python and Flask - CS50_Beyond_2019 Notes</title>
    <link href="http://wittyfans.com/coding/Python-and-Flask-CS50-Beyond-2019-Notes.html"/>
    <id>http://wittyfans.com/coding/Python-and-Flask-CS50-Beyond-2019-Notes.html</id>
    <published>2019-01-30T13:19:31.000Z</published>
    <updated>2019-01-31T13:58:51.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flask 是一个 Python 实现的 Web 开发微框架.</p></blockquote><a id="more"></a><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>创建一个文件，然后进入该文件夹，创建一个py文件，然后在命令后导入，这样flask才知道要运行哪个程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=hello.py</span><br></pre></td></tr></table></figure><p>导入以后就可以直接在当前目录使用flask run 了。</p><h1 id="第一个flask程序"><a href="#第一个flask程序" class="headerlink" title="第一个flask程序"></a>第一个flask程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask,render_template</span><br><span class="line">app = Flask(__name__) # 新建一个flask app</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;) </span><br><span class="line">def index():</span><br><span class="line">    return &quot;Hello,Word!&quot;</span><br></pre></td></tr></table></figure><ul><li>@app.route(“/“)是一个装饰器，如果有人访问/，那么就运行被装饰器装饰的函数，也就是下面返回Hello,word！</li></ul><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&quot;/wittyfans&quot;) </span><br><span class="line">def wittyfans():</span><br><span class="line">    return &quot;Hello, My master!!!&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&lt;string:name&gt;&quot;) </span><br><span class="line">def hello(name):</span><br><span class="line">    name = name.capitalize()</span><br><span class="line">    return f&quot;Hello! &#123;name&#125;&quot;</span><br></pre></td></tr></table></figure><p>如果输入localhost:/wittyfans就返回”Hello, My master!!!”,如果是别的就返回他输入的名字。</p><blockquote><p>在route中定义变量，它可以传到函数里使用.flask会路由到最具体的网址，也就是说，输入/wittyfans还是会被上面的函数处理.</p></blockquote><h2 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&quot;/&lt;string:admin_name&gt;/&lt;string:password&gt;&quot;) </span><br><span class="line">def varify(admin_name,password):</span><br><span class="line">    if admin_name == &apos;wittyfans&apos; and password == &apos;123&apos;:</span><br><span class="line">        return &apos;Welcome here&apos;</span><br><span class="line">    else:</span><br><span class="line">        return &apos;error&apos;</span><br></pre></td></tr></table></figure><h1 id="使用html文件构建网页"><a href="#使用html文件构建网页" class="headerlink" title="使用html文件构建网页"></a>使用html文件构建网页</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&quot;index.html&quot;)</span><br></pre></td></tr></table></figure><p>对于网页来说，我们更多的是传出html文件,这时候需要在根目录新建templates文件夹，并将html文件放在其中</p><p>我们可以将输入的值做处理后重新填充给html文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&lt;string:name&gt;&apos;)</span><br><span class="line">def index(name):</span><br><span class="line">    return render_template(&quot;index.html&quot;,name=name.capitalize())</span><br></pre></td></tr></table></figure><h1 id="示例：判断是否是新年"><a href="#示例：判断是否是新年" class="headerlink" title="示例：判断是否是新年"></a>示例：判断是否是新年</h1><p>逻辑部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    is_new_years = now.month == 1 and now.day == 1</span><br><span class="line">    print(is_new_years)</span><br><span class="line">    return render_template(&quot;index.html&quot;,is_new_years=is_new_years)</span><br></pre></td></tr></table></figure><p>html中,使用Conditional Templating</p><figure class="highlight plain"><figcaption><span>html> </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            wittyfans</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &#123;% if is_new_years %&#125;</span><br><span class="line">            &lt;h1&gt;YES&lt;/h1&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">            &lt;h1&gt;NO&lt;/h1&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.youtube.com/watch?v=pP23CtOI-1U&amp;t=2772s" target="_blank" rel="noopener">Python and Flask - CS50 Beyond 2019)</a></li><li><a href="https://dormousehole.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flask 是一个 Python 实现的 Web 开发微框架.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="flask" scheme="http://wittyfans.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>用Python来排班？</title>
    <link href="http://wittyfans.com/coding/%E7%94%A8Python%E6%9D%A5%E6%8E%92%E7%8F%AD%EF%BC%9F.html"/>
    <id>http://wittyfans.com/coding/用Python来排班？.html</id>
    <published>2019-01-16T12:58:01.000Z</published>
    <updated>2019-01-16T13:23:57.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这也是可以做的的，并不比excel差哦</p></blockquote><a id="more"></a><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>首先我们需要一份原数据，我得到的数据如下：</p><p><img src="https://bn1301files.storage.live.com/y4m21Og1jBfF-UnSCjBwTTl8sK4ek_tNWEsoLbHnc5WgckaDFeMLEikagYp4GIem_ZafSMVF99qhAKoJyFeQQGAj6WRZ1oBjqvV5rv4qEIM8kqdGQvefUtYNl3jG5u6MP5M6HB3G5AU2ZSmPMJKbD2wJjtAvECQ82EB4276NlVCV3JPUB-tnFXxSPyOFQiK95dQMFz2XF_xC_VwXrZMdNNaww/Raw_data.png?psid=1&amp;width=2743&amp;height=1354" alt=""></p><ul><li>Name: 上班的同事</li><li>A和V: 不同的班次</li><li>0: 当天休息</li></ul><p>我们的需求是，休息时间由组长事先填好，随后随机将班次分给每天上班的人，需要保证分出去的班次不可以重复，并且是随机的，即每个人不可以每天都是一样的班。</p><p>首先我们导入相关的包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import random</span><br></pre></td></tr></table></figure><p>新建一个班次生成类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Schedules:  </span><br><span class="line">    def __init__(self,schedules):</span><br><span class="line">        self._index = len(schedules)</span><br><span class="line">        self._schedules = schedules</span><br><span class="line">        </span><br><span class="line">    def get_schedules(self):</span><br><span class="line">        if self._index &gt; 0:                </span><br><span class="line">            pointer = random.choice([x for x in range(len(self._schedules))])</span><br><span class="line">            scheduleType = self._schedules[pointer]</span><br><span class="line">            del self._schedules[pointer]</span><br><span class="line">            self._index -= 1</span><br><span class="line">            return scheduleType</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure><p>这个类的作用就是，你初始化的是给他一些班次列表，他会返回一个随机的班次，如果班级列表中的班次已经分配完了，则返回None。</p><p>然后我们再写一个针对每一列设置班次的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def set_schedule(col):</span><br><span class="line">    if col.name != &apos;Name&apos;:</span><br><span class="line">        colSchedules = col</span><br><span class="line">        # 该列中值不等于0的索引</span><br><span class="line">        pointers = list(col[col != 0].index)</span><br><span class="line">        # 值班类型</span><br><span class="line">        scheduleType = [&apos;A1&apos;,&apos;A2&apos;,&apos;A3&apos;,&apos;A4&apos;,&apos;V3&apos;,&apos;V2&apos;,&apos;A5&apos;,&apos;A6&apos;,&apos;A8&apos;,&apos;A7&apos;,&apos;V1&apos;,&apos;A9&apos;,&apos;A0&apos;]</span><br><span class="line">        random.shuffle(scheduleType)</span><br><span class="line">        random.shuffle(pointers)</span><br><span class="line">        for pointer in pointers:</span><br><span class="line">#             print(&quot;正在填第&#123;&#125;个&quot;.format(pointer))</span><br><span class="line">#             print(&quot;班表还剩&#123;&#125;个&quot;.format(len(scheduleType)))</span><br><span class="line">            if len(scheduleType) &gt; 0:</span><br><span class="line">                schedule = scheduleType.pop()</span><br><span class="line">#                 print(&quot;拿到班的类型是&#123;&#125;&quot;.format(schedule))</span><br><span class="line">                colSchedules[pointer] = schedule</span><br><span class="line">#                 print(&quot;修改之后的班表是&#123;&#125;&quot;.format(colSchedules))</span><br><span class="line">            else:</span><br><span class="line">                colSchedules[pointer] = &apos;A&apos;</span><br><span class="line">                continue</span><br><span class="line">        col = colSchedules</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>这里我将班次写在了方法里面，当然你也可以从外面传进去，该一下参数即可。最后，用pandas先将原始数据导入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_excel(&quot;/Users/wittyfans/Documents/工作/Python NoteBook/Schedule/Schedule.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>运行就可以看到数据啦！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">days = [x for x in data.columns if x  != &apos;Name&apos;]</span><br><span class="line">data.apply(set_schedule)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><p>你也可以将数据导出为excel，使用pandas的to_excel方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.to_excel(filePath)</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://bn1301files.storage.live.com/y4mgtmM4T-r7AH8W5f3qKw2Lwo5j3UcAzDQKqjXx64gUN0v-af8c9K1_5k36eZSR81X0UKiwKBZCu7aiq8Syryn3bdniNX_VB1UQGVR0QQubDCz31GMRRdyAFmOHh1y82j2hFmy1zc_NtPtVNTPASdhpKriZpKHtrl2xYcSNvf1hVPIsaTz-QhoZwhmeTFxaw78oywC9LXkQpGP0YSApebQ3w/a.png?psid=1&amp;width=2146&amp;height=1146" alt="第一次班表"></p><p><img src="https://bn1301files.storage.live.com/y4m799Xq0W25h8l7V_3QOEXZgBFG2hhTi_5IEVz1G6ZwvNe3uJYNl1_PNw7z3aaWDGdjZ6YgXWb1-Jdm_LpkexITUQ5Q6kKUmZAxLOsH6Idfxx5hcoyJE08fRdZEuN_mZJRn6z3egU9E1UH_EQsSoEVLOfJf6EzpJhhvxfyTiwnYpkrGwI7mu3eOI3EOJjgbbrFclxQV9ZXEXtBS5c-PD6FYg/b.png?psid=1&amp;width=2144&amp;height=1154" alt="第二次班表"></p><p><img src="https://bn1301files.storage.live.com/y4mmmd_AK_zt5HwbnyJ4cKtO6UIRCEfot9dkcnyWXRo0T-Jh1TQjoTLxp1ujOvjh9rKtFxrH7hwgAtQni_OvfKOEDIL2oWoJvUjHAfoEadE2MVtqP-R2TWSej27Scl1Sh7oIvviZuB5dZlekB7f2Zs7nVswpPS-fldACbYuKJLU8LH85C7Dc0NcXCVuxS_jnZszmMoh4XXumEPzpxL6JV97rQ/c.png?psid=1&amp;width=2132&amp;height=1132" alt="第三次运行"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Schedules:  </span><br><span class="line">    def __init__(self,schedules):</span><br><span class="line">        self._index = len(schedules)</span><br><span class="line">        self._schedules = schedules</span><br><span class="line">        </span><br><span class="line">    def get_schedules(self):</span><br><span class="line">        if self._index &gt; 0:                </span><br><span class="line">            pointer = random.choice([x for x in range(len(self._schedules))])</span><br><span class="line">            scheduleType = self._schedules[pointer]</span><br><span class="line">            del self._schedules[pointer]</span><br><span class="line">            self._index -= 1</span><br><span class="line">            return scheduleType</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">def set_schedule(col):</span><br><span class="line">    if col.name != &apos;Name&apos;:</span><br><span class="line">        colSchedules = col</span><br><span class="line">        # 该列中值不等于0的索引</span><br><span class="line">        pointers = list(col[col != 0].index)</span><br><span class="line">        # 值班类型</span><br><span class="line">        scheduleType = [&apos;A1&apos;,&apos;A2&apos;,&apos;A3&apos;,&apos;A4&apos;,&apos;V3&apos;,&apos;V2&apos;,&apos;A5&apos;,&apos;A6&apos;,&apos;A8&apos;,&apos;A7&apos;,&apos;V1&apos;,&apos;A9&apos;,&apos;A0&apos;]</span><br><span class="line">        random.shuffle(scheduleType)</span><br><span class="line">        random.shuffle(pointers)</span><br><span class="line">        for pointer in pointers:</span><br><span class="line">#             print(&quot;正在填第&#123;&#125;个&quot;.format(pointer))</span><br><span class="line">#             print(&quot;班表还剩&#123;&#125;个&quot;.format(len(scheduleType)))</span><br><span class="line">            if len(scheduleType) &gt; 0:</span><br><span class="line">                schedule = scheduleType.pop()</span><br><span class="line">#                 print(&quot;拿到班的类型是&#123;&#125;&quot;.format(schedule))</span><br><span class="line">                colSchedules[pointer] = schedule</span><br><span class="line">#                 print(&quot;修改之后的班表是&#123;&#125;&quot;.format(colSchedules))</span><br><span class="line">            else:</span><br><span class="line">                colSchedules[pointer] = &apos;A&apos;</span><br><span class="line">                continue</span><br><span class="line">        col = colSchedules</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">data = pd.read_excel(&quot;/Users/wittyfans/Documents/工作/Python NoteBook/Schedule/Schedule.xlsx&quot;)</span><br><span class="line">days = [x for x in data.columns if x  != &apos;Name&apos;]</span><br><span class="line">data.apply(set_schedule)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这也是可以做的的，并不比excel差哦&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="pandas" scheme="http://wittyfans.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python如何连接WindowsSMB共享文件夹?</title>
    <link href="http://wittyfans.com/coding/Python%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5WindowsSMB%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9.html"/>
    <id>http://wittyfans.com/coding/Python如何连接WindowsSMB共享文件夹.html</id>
    <published>2019-01-16T12:48:05.000Z</published>
    <updated>2019-01-16T12:50:19.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想访问 Windows SMB 服务器上的共享文件？试试这招</p></blockquote><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>安装pysmb, pip install pysmb</li><li>导入相关的包</li><li>使用方法见注释</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://pysmb.readthedocs.io/en/latest/api/smb_SMBConnection.html" target="_blank" rel="noopener">SMBConnection Class</a></li><li><a href="http://melonteam.com/posts/cong_yi_ge_xiao_ren_wu_kai_shi__python_xue_xi_bi_ji/#%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB" target="_blank" rel="noopener">一个小任务</a></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from smb.SMBConnection import SMBConnection</span><br><span class="line"># 新建连接对象</span><br><span class="line">conn = SMBConnection(&apos;domain_user_name&apos;, &apos;you_password&apos;, &apos;device_hostname&apos;, &apos;server_ip&apos;, domain = &apos;domain_address&apos;, use_ntlm_v2=True, is_direct_tcp=True)</span><br><span class="line"># 返回值为布尔型，表示连接成功与否</span><br><span class="line">result = conn.connect(&apos;server_ip&apos;, 445)</span><br><span class="line"></span><br><span class="line"># 检索文件</span><br><span class="line">for f in conn.listPath(&apos;share_folder_name&apos;,&apos;folder_name_in_prvious_one&apos;):</span><br><span class="line">    print(f.filename)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想访问 Windows SMB 服务器上的共享文件？试试这招&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="windows" scheme="http://wittyfans.com/tags/windows/"/>
    
      <category term="smb" scheme="http://wittyfans.com/tags/smb/"/>
    
  </entry>
  
  <entry>
    <title>如何用Scrapy开发一个贴吧爬虫</title>
    <link href="http://wittyfans.com/coding/%E5%A6%82%E4%BD%95%E7%94%A8Scrapy%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%B4%B4%E5%90%A7%E7%88%AC%E8%99%AB.html"/>
    <id>http://wittyfans.com/coding/如何用Scrapy开发一个贴吧爬虫.html</id>
    <published>2019-01-16T12:38:35.000Z</published>
    <updated>2019-01-16T12:44:39.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>就是看看大家在贴吧玩啥，爬了100多兆母校的数据，回来慢慢分析，以后再做个数据可视化，感兴趣的可以拿去爬一下自己喜欢的贴吧。</p></blockquote><a id="more"></a><h1 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h1><p>A scrapy projects, <a href="https://github.com/wittyfans/scrapy" target="_blank" rel="noopener">Github Link</a>.</p><h1 id="贴吧爬虫开发记录"><a href="#贴吧爬虫开发记录" class="headerlink" title="贴吧爬虫开发记录"></a>贴吧爬虫开发记录</h1><h2 id="抓取数据并存储"><a href="#抓取数据并存储" class="headerlink" title="抓取数据并存储"></a>抓取数据并存储</h2><p>因为我要抓取很多链接，最开始的想法就是直接把所有的url给内置的start_urls方法，于是我自己写了个生成器，直接怼给了它，但发现不管用。<br>翻了下官方的文档：</p><blockquote><p>make_requests_from_url() 将被调用来创建Request对象。 该方法仅仅会被Scrapy调用一次，因此您可以将其实现为生成器</p></blockquote><p>于是就自己写了生成器给make_requests_from_url() 用，在把response 返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def start_requests(self):</span><br><span class="line">    self.logger.info(&quot;START:&quot;)</span><br><span class="line">    for url in self.getBBSUrl(&quot;守望先锋&quot;,10):</span><br><span class="line">        yield self.make_requests_from_url(url)</span><br></pre></td></tr></table></figure><blockquote><p>但后面又发现这个在最新的官方文档里面没有, 原来, Spider.make_requests_from_url is deprecated (issue 1728, fixes issue 1495), 看来又要改一下才行，先挖个坑吧。</p></blockquote><p><em>更新：</em></p><p>看了下官方的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Return multiple Requests and items from a single callback:</span><br><span class="line"></span><br><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line">class MySpider(scrapy.Spider):</span><br><span class="line">    name = &apos;example.com&apos;</span><br><span class="line">    allowed_domains = [&apos;example.com&apos;]</span><br><span class="line">    start_urls = [</span><br><span class="line">        &apos;http://www.example.com/1.html&apos;,</span><br><span class="line">        &apos;http://www.example.com/2.html&apos;,</span><br><span class="line">        &apos;http://www.example.com/3.html&apos;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        for h3 in response.xpath(&apos;//h3&apos;).extract():</span><br><span class="line">            yield &#123;&quot;title&quot;: h3&#125;</span><br><span class="line"></span><br><span class="line">        for url in response.xpath(&apos;//a/@href&apos;).extract():</span><br><span class="line">            yield scrapy.Request(url, callback=self.parse)</span><br></pre></td></tr></table></figure><p>直接将 yield self.make_requests_from_url(url) 换成 yield scrapy.Request(url, callback=self.parse) 就好了。</p><p>之前是使用直接赋值的方式来将xpath解析到的值给item，也就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    alltitles = []</span><br><span class="line">    item = TiebaItem()</span><br><span class="line">    titles = response.xpath(&quot;//a[@class=&apos;j_th_tit &apos;]//text()&quot;).extract()</span><br><span class="line">    for title in titles:</span><br><span class="line">        alltitles.append(title)</span><br><span class="line">    item[&quot;summarys&quot;] = alltitles</span><br><span class="line">    return item</span><br></pre></td></tr></table></figure><p>titles是一个页面中所有的title，是一个数组对象，但发现如果我直接将title赋值到item，也是可以的，这里纯粹多此一举，所以变成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    item = TiebaItem()</span><br><span class="line">    titles = response.xpath(&quot;//a[@class=&apos;j_th_tit &apos;]//text()&quot;).extract()</span><br><span class="line">    item[&quot;summarys&quot;] = titles</span><br><span class="line">    return item</span><br></pre></td></tr></table></figure><p>后面改用了ItemLoader，ItemLoader是更抽象的一种使用方式。我们知道，数据都是存储在item里面的，每次使用的时候都需要创建item，之后再<br>通过response.xpath选择需要的值，赋值给item里面对应的字段。</p><p>itemLoader把这个过程抽象为，你在新建itemLoader的时候把要装数据的item给我，然后只需要给我字段和要存的值就好，另一个好处是，你还可以在itemLoader这个环节对一些数据做处理，比如首尾空格去除，添加特定字段等。</p><p>所以修改后的存储代码变成了这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">        l = ItemLoader(item=TiebaItem(),response=response)</span><br><span class="line">        l.add_xpath(&quot;summarys&quot;,&quot;//a[@class=&apos;j_th_tit &apos;]//text()&quot;)</span><br><span class="line">        l.add_xpath(&quot;links&quot;,&apos;//a[@class=&quot;j_th_tit &quot;]//@href&apos;)</span><br><span class="line">        return l.load_item()</span><br></pre></td></tr></table></figure><p>另一种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    post = l.nested_xpath(&quot;//a[@class=&apos;j_th_tit &apos;]&quot;)</span><br><span class="line">    post.add_xpath(&apos;summary&apos;, &apos;text()&apos;)</span><br><span class="line">    post.add_xpath(&apos;link&apos;, &apos;@href&apos;)</span><br><span class="line">    return l.load_item()</span><br></pre></td></tr></table></figure><p>现在我提取了帖子的两条数据，一个是标题，另一个是标题的链接，存储在item里面是这个样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;summarys&quot;:[&quot;标题1&quot;,&quot;标题2&quot;],&quot;Links&quot;:[&quot;Link1&quot;,&quot;Link2&quot;]&#125;,</span><br><span class="line">    &#123;&quot;summarys&quot;:[&quot;标题3&quot;,&quot;标题4&quot;],&quot;Links&quot;:[&quot;Link3&quot;,&quot;Link4&quot;]&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>这基本上是请求一次，返回了贴吧里面一页的数据，然后从中提取了所有标题和链接，所以是一次请求，一行数据。那有没有办法把所有的标题和链接合并到一起呢？也就是从多个请求提取到的数据存到item中的同一个字段里。</p><p>仔细想想这样有必要吗？用pd分析一下这个json数据看看。</p><blockquote><p>Method 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">summarys = []</span><br><span class="line">links = []</span><br><span class="line"></span><br><span class="line">for link in data.link:</span><br><span class="line">    for value in link:</span><br><span class="line">        url = &quot;tieba.baidu.com&quot;+str(value)</span><br><span class="line">        links.append(url)</span><br><span class="line">for summary in data.summary:</span><br><span class="line">    for value in summary:</span><br><span class="line">        summarys.append(value)</span><br><span class="line">post = pd.DataFrame()</span><br><span class="line">post[&quot;summarys&quot;] = summarys</span><br><span class="line">post[&quot;link&quot;] = links</span><br><span class="line">post</span><br></pre></td></tr></table></figure><blockquote><p>Method 2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def toPD(data):</span><br><span class="line">    post = pd.DataFrame()</span><br><span class="line">    for col in data.columns:</span><br><span class="line">        coldata = []</span><br><span class="line">        for value in data[col]:</span><br><span class="line">            for j in value:</span><br><span class="line">                coldata.append(j)</span><br><span class="line">        post[col] = pd.Series(coldata)</span><br><span class="line">    return post</span><br><span class="line">toPD(data)</span><br></pre></td></tr></table></figure><p>输出的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0哈哈哈哈大幺蛾子tieba.baidu.com/p/5982395208</span><br><span class="line">1安娜玩家表示看到堡垒和奥丽莎就高兴，打不动靶太安逸了tieba.baidu.com/p/5984392212</span><br><span class="line">2这个200hz的有人用过吗，和144的差多少?平常只打守望先tieba.baidu.com/p/5978507290</span><br><span class="line">3这麦克雷是挂吗 大家帮忙看看tieba.baidu.com/p/5984115608</span><br><span class="line">4我真是服了，削猪的时候，我不出声，因为我不玩；削76的时候，tieba.baidu.com/p/5982819128</span><br><span class="line">5这难道就是开窍了吗？tieba.baidu.com/p/5979734484</span><br></pre></td></tr></table></figure><p>检查了下链接，跟标题一样，那就先这样吧，继续研究深度爬取，多抓一些信息。</p><p>用scrapy 的shell调试了一下，得到了这些信息的xpath的表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l.add_xpath(&apos;replysCount&apos;,&apos;//span[@class=&quot;threadlist_rep_num center_text&quot;]//text()&apos;) #回复数</span><br><span class="line">l.add_xpath(&apos;authorName&apos;,&apos;//span[@class=&quot;frs-author-name-wrap&quot;]//text()&apos;) #作者名字</span><br><span class="line">l.add_xpath(&apos;authorMainPageUrl&apos;,&apos;//span[@class=&quot;frs-author-name-wrap&quot;]//@href&apos;) #作者主页链接</span><br></pre></td></tr></table></figure><p>用panda处理了一下，得到如下数据:</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Index</th><th style="text-align:center">authorMainUrl</th><th style="text-align:center">author</th><th style="text-align:center">posturl</th><th style="text-align:center">replys</th><th>summary</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">tieba.baidu.com/home/main/?un=%E7%BA%AF%E5%B1%</td><td style="text-align:center">一呼吸一</td><td style="text-align:center">tieba.baidu.com/p/5978804665</td><td style="text-align:center">94</td><td style="text-align:center">毛妹这个英雄是不是该削了?竞技把把都有，万金油的存在，她的盾</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">tieba.baidu.com/home/main/?un=q526246486&amp;ie=ut</td><td style="text-align:center">贴吧用户</td><td style="text-align:center">tieba.baidu.com/p/5924655619</td><td style="text-align:center">41</td><td style="text-align:center">这波刀大家打几分</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">tieba.baidu.com/home/main/?un=%E9%99%86%E6%95%</td><td style="text-align:center">陆散散</td><td style="text-align:center">tieba.baidu.com/p/5984318268</td><td style="text-align:center">3</td><td style="text-align:center">算了 不想骂了 鱼塘水真多我佛了</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">tieba.baidu.com/home/main/?un=%E8%99%90%E7%88%</td><td style="text-align:center">虐爆</td><td style="text-align:center">tieba.baidu.com/p/5983683236</td><td style="text-align:center">104</td><td style="text-align:center">为什么你们有那么多小姐姐一起玩</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">tieba.baidu.com/home/main/?un=G7IP9&amp;ie=utf-8&amp;i</td><td style="text-align:center">黎曦</td><td style="text-align:center">tieba.baidu.com/p/5983616276</td><td style="text-align:center">65</td><td style="text-align:center">问几个问题</td></tr></tbody></table><p><strong>Tips:</strong></p><ul><li>String 的startwith()方法可以接受多个参数，但必须是tuple，也就是string.startwith((‘a’,’b’))</li></ul><p>但此时又遇到了一个新问题，当我在pandas里进行列数据合并的时候，提示出错，应该是列长不一样，也就是某些数据有遗漏。然后用<br>pd.Series()解决了问题，它会将缺失的数据填充为NaN，但缺发现标题和发帖人的对应关系出错了。</p><p>这时候就抛出了一个问题，既然要保留item中数据的结构，那么在合并数据的时候，是否可以保证数据的对应关系呢？</p><h2 id="2018-12-22"><a href="#2018-12-22" class="headerlink" title="2018.12.22"></a>2018.12.22</h2><p><strong>新问题的新思考：</strong></p><blockquote><p>目前解决问题的思路是这样的，假设一个分页有10个帖子，我一次性拿10个帖子的标题，发帖人，回复量，这10个帖子处理完了，再进行下一步。这样会遇到合并数据的问题,<br>其次出来的数据，也是十条一组的存储在item里面。如果我之后再想得到这个帖子的内容，回复这个帖子的人，这些人的信息，难道再去找之前的URL，再把拿到的数据去做复杂的合并吗？<br>这么一想觉得现在的方法不行，一开始我只是考虑到了爬这些标题做分析，但现在想要更多的数据，就必须换一种方法。</p></blockquote><p>Todo:</p><ul><li>有一个div有两个class，一个是gril, 另一个是hot gril, 那么在我通过girl定位到了这个“gril”之后，怎么知道她是hot girl呢？</li></ul><h2 id="新的架构"><a href="#新的架构" class="headerlink" title="新的架构"></a>新的架构</h2><p>现在的方法是，利用深层爬取。刚开始的请求还是一样的，请求一页的数据，然后从中收集所有帖子的链接，这时候返回这一页的帖子链接的list，然后在一个个循环请求，回来的数据传给回调方法处理并存储到item里面。</p><p>这里的关键在于，第一页的数据抓取完了之后，得找到下一页的链接继续请求，从请求的数据中继续找帖子，找下一页，如此循环，通过指定CLOSESPIDER_ITEMCOUNT的值可以让爬虫在爬了特定的值后停下来，不然会一直继续下一页，参见下面的tips.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    # get the next page info</span><br><span class="line">    nextPageUrls = response.xpath(&quot;//a[@class=&apos;next pagination-item &apos;]//@href&quot;)</span><br><span class="line">    for url in nextPageUrls.extract():</span><br><span class="line">        self.logger.info(&quot;=====Now request:&#123;&#125;=====&quot;.format(url))</span><br><span class="line">        yield scrapy.Request(urljoin(&apos;https://tieba.baidu.com&apos;,url))</span><br><span class="line"></span><br><span class="line">    # get the post urls and collec the info.</span><br><span class="line">    postSubUrls = response.xpath(&quot;//a[@class=&apos;j_th_tit &apos;]//@href&quot;).extract()</span><br><span class="line">    postUrls = list(map(self.addPref,postSubUrls))</span><br><span class="line">    for url in postUrls.__reversed__():</span><br><span class="line">        yield scrapy.Request(url,callback=self.parsePost,meta=&#123;&apos;url&apos;:url&#125;)</span><br><span class="line"></span><br><span class="line">def parsePost(self,response):</span><br><span class="line">    l = ItemLoader(item=TiebaItem(),response=response)</span><br><span class="line">    title = response.xpath(&quot;//div[@class=&apos;core_title_wrap_bright clearfix&apos;]//text()&quot;).extract()[0]</span><br><span class="line">    l.add_value(&quot;link&quot;,response.meta[&apos;url&apos;])</span><br><span class="line">    l.add_value(&quot;title&quot;,title)</span><br><span class="line">    l.add_xpath(&quot;replyUsers&quot;,&quot;//div[@class=&apos;d_author&apos;]//li[@class=&apos;d_name&apos;]//a[@class=&apos;p_author_name j_user_card&apos;]//text()&quot;)</span><br><span class="line">    l.add_xpath(&quot;replyContent&quot;,&quot;//div[@class=&apos;d_post_content j_d_post_content &apos;]//text()&quot;)</span><br><span class="line">    yield l.load_item()</span><br></pre></td></tr></table></figure><p>上面的代码，我将下一页的请求放在抽取帖子内容后面，就会出现只能抓一页的情况，折腾了半天，后参考《精通PYTHON爬虫框架Scrapy——异步图书》代码才解决，不知何故，待研究。</p><p>一些技巧：</p><ul><li><a href="https://www.zhihu.com/question/54773510" target="_blank" rel="noopener">利用meta参数，在请求之间传信息</a></li><li>多利用 urljoin 来合并url，而不是自己写函数再map</li><li>scrapy crawl name -s CLOSESPIDER_ITEMCOUNT=100 通过-s指定CLOSESPIDER_ITEMCOUNT的值可以让爬虫在爬了特定的值后停下来</li></ul><h2 id="2018-12-23"><a href="#2018-12-23" class="headerlink" title="2018.12.23"></a>2018.12.23</h2><p>今天换了个个音乐主题的贴吧billboard吧抓数据，发现xpath表达式都抓不到东西了，检查了一下发现不同的吧某些东西还不一样，比如billboard吧和守望先锋吧帖子内容的class：</p><ul><li>“d_post_content j_d_post_content ”</li><li>“d_post_content j_d_post_content  clearfix”</li></ul><p>billboard吧的class增加了一个clearfix的值，这是用来清除浮动的，要了解清楚浮动是干嘛，可以参考<a href="https://www.jianshu.com/p/9d6a6fc3e398" target="_blank" rel="noopener">这篇文章</a>，现在有两个办法</p><ul><li>找到这个clearfix的规律，有clearfix的吧或者帖子就给我们的xpath表达式加上</li><li>还是按照原来的方法去取值，如果取不到，那就加上clearfix</li></ul><p>目前来看第二种方法比较简单，先试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 标题</span><br><span class="line">title = response.xpath(&quot;//div[@class=&apos;core_title_wrap_bright clearfix&apos;]//text()&quot;)</span><br><span class="line">if title:</span><br><span class="line">    title = title.extract()[0]</span><br><span class="line">else:</span><br><span class="line">    title = response.xpath(&quot;//div[@class=&apos;core_title core_title_theme_bright&apos;]//text()&quot;).extract()[0]</span><br><span class="line">                                        </span><br><span class="line"># 链接</span><br><span class="line">l.add_value(&quot;link&quot;,response.meta[&apos;url&apos;])</span><br><span class="line">l.add_value(&quot;title&quot;,title)</span><br><span class="line"># 跟帖用户</span><br><span class="line">l.add_xpath(&quot;replyUsers&quot;,&quot;//div[@class=&apos;d_author&apos;]//li[@class=&apos;d_name&apos;]//a[@class=&apos;p_author_name j_user_card&apos;]//text()&quot;)</span><br><span class="line"># 跟帖内容</span><br><span class="line">replyContent = response.xpath(&quot;//div[@class=&apos;d_post_content j_d_post_content  clearfix&apos;]//text()&quot;)</span><br><span class="line">if replyContent:</span><br><span class="line">    replyContent = replyContent.extract()</span><br><span class="line">else:</span><br><span class="line">    replyContent = response.xpath(&quot;//div[@class=&apos;d_post_content j_d_post_content &apos;]//text()&quot;).extract()</span><br><span class="line">l.add_value(&quot;replyContent&quot;,replyContent)</span><br></pre></td></tr></table></figure><p>没问题，成功抓到所需要的信息,现在我要抓去更多用户的信息，这帖子回复的人是个妹子还是汉子那肯定得知道不，通过分析html结果，被我发现了这么一个字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data-field=&quot;&#123;</span><br><span class="line"></span><br><span class="line">    &quot;author&quot;:&#123;&quot;user_id&quot;:2350893056,&quot;user_name&quot;:&quot;GYGGYFDDH&quot;,&quot;name_u&quot;:&quot;GYGGYFDDH&amp;ie=utf-8&quot;,&quot;user_sex&quot;:2,&quot;portrait&quot;:&quot;00c84759474759464444481f8c&quot;,&quot;is_like&quot;:1,&quot;level_id&quot;:6,&quot;level_name&quot;:&quot;\u51cc\u6ce2\u55b5\u6b65&quot;,&quot;cur_score&quot;:118,&quot;bawu&quot;:0,&quot;props&quot;:null,&quot;user_nickname&quot;:&quot;\u767d\u00ba\u82d7\u7f2a&quot;&#125;,</span><br><span class="line"></span><br><span class="line">    &quot;content&quot;:&#123;&quot;post_id&quot;:123353095371,&quot;is_anonym&quot;:false,&quot;open_id&quot;:&quot;tbclient&quot;,&quot;open_type&quot;:&quot;android&quot;,&quot;date&quot;:&quot;2018-12-23 10:35&quot;,&quot;vote_crypt&quot;:&quot;&quot;,&quot;post_no&quot;:1,&quot;type&quot;:&quot;0&quot;,&quot;comment_num&quot;:0,&quot;is_fold&quot;:0,&quot;ptype&quot;:&quot;0&quot;,&quot;is_saveface&quot;:false,&quot;props&quot;:null,&quot;post_index&quot;:0,&quot;pb_tpoint&quot;:null&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;&quot;</span><br></pre></td></tr></table></figure><p>这就是突破口了，author是用户的信息，content是这个帖子的信息，比如回复的时间。user_sex就是性别，1是男，2是女，仔细一看这里面还有用户的设备信息，比如用的是苹果还是安卓。<br>试着抓一些信息下来，xpath表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">l.add_xpath(&quot;replyUsers&quot;,&quot;//div[@class=&apos;p_postlist&apos;]/div/attribute::data-field&quot;)</span><br></pre></td></tr></table></figure><p>选取所有class是p_postlist的第一个子节点，然后选择它的叫做data-field的属性，即上面的信息了，抓到了所有的数据，用pd过滤一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usernames = []</span><br><span class="line">usersexs = []</span><br><span class="line">for users in sxyData.replyUsers:</span><br><span class="line">    for userinfo in users:</span><br><span class="line">        userInfoString = &quot;&quot;.join(userinfo)</span><br><span class="line">        if userInfoString.startswith(&quot;&#123;&quot;):</span><br><span class="line">            user = pd.read_json(userInfoString)</span><br><span class="line">            usernames.append(user.author[&quot;user_name&quot;])</span><br><span class="line">            usersexs.append(user.author[&quot;user_sex&quot;])</span><br><span class="line">users = &#123;&apos;names&apos;:usernames,&apos;sex&apos;:usersexs&#125;</span><br><span class="line">users = pd.DataFrame(users)</span><br><span class="line">users</span><br></pre></td></tr></table></figure><p>这里会从中提取出用户名和性别，因为某些数据不是以{}包装的，所以在用pd提取json对象之前，先判断一下,得到的数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0夜和海19961</span><br><span class="line">1华丽atobekeigo2</span><br><span class="line">5永中一小生0</span><br><span class="line">6哦啦啦旅途啦0</span><br><span class="line">7lzlzyz1</span><br></pre></td></tr></table></figure></p><ul><li>1：男生</li><li>2：女生</li><li>0:未知</li></ul><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>下午突然想到，应该可以通过子或父节点获取这个class的属性，再去提取信息，这样就不需要判断了，直接可以根据相对关系选择它的class名</li></ul><h2 id="2018-12-24"><a href="#2018-12-24" class="headerlink" title="2018.12.24"></a>2018.12.24</h2><p>在处理抓帖子内容的时候出现一些问题，因为有一些帖子的评论很多，也是有下一页的，虽然处理逻辑和帖子列表的差不多，但仔细研究后发现是不一样的，并且找出了之前的代码的缺陷:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">        # get the post urls and collec the info.</span><br><span class="line">        postSubUrls = response.xpath(&quot;//a[@class=&apos;j_th_tit &apos;]//@href&quot;).extract()</span><br><span class="line">        self.logger.info(&quot;==============Now Request pages===========&#123;&#125;&quot;.format(postSubUrls))</span><br><span class="line">        for subrul in postSubUrls:</span><br><span class="line">            url = urljoin(self.urlPrefix,subrul)</span><br><span class="line">            self.logger.info(&quot;----------Now request url=============&#123;&#125;&quot;.format(url))</span><br><span class="line">            yield scrapy.Request(url,callback=self.parsePost,meta=&#123;&apos;url&apos;:url&#125;)</span><br><span class="line"></span><br><span class="line">        # get the next page info</span><br><span class="line">        nextPageUrls = response.xpath(&quot;//a[@class=&apos;next pagination-item &apos;]//@href&quot;)    </span><br><span class="line">        for url in nextPageUrls.extract():</span><br><span class="line">            yield scrapy.Request(urljoin(self.urlPrefix,url),callback=self.parse)</span><br></pre></td></tr></table></figure><p>主要是这里的抓帖子内容和下一页的顺序对调了，以及之前我在yield下一页的时候，竟然没有指定回掉方法，这导致第一页帖子里面就有些帖子没有抓下来。随后开始研究如何抓第二页的评论，此处遇到一个大坑, 即第二页的标题变了，变成了”回复： {原来的标题}”,导致新抓下来的标题都<br>存到了另一个字段，我还以为没抓下来，一直在改，之所以存到了下一个字段，是因为我在下一页的请求发起之前，就已经yield返回了l.load_item().</p><p>找到原因了就好办了，对于那些抓下一页的评论的帖子，它的title我们可以一开始就指定，然后通过meta传递给下一个请求，在下一个请求中判断如果meta中有title，那么title就设置为meta中的，这里在判断meta(meta是一个字典)中是否某个key的时候犯了个小错,我是这么写的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if d.meta[&apos;apples&apos;]:</span><br></pre></td></tr></table></figure><p>但其实应该这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if &apos;apples&apos; in d:</span><br></pre></td></tr></table></figure><p>参见：<a href="https://stackoverflow.com/questions/44035287/check-key-exist-in-python-dict/44035382" target="_blank" rel="noopener">Check key exist in python dict</a></p><p>但这样抓下来的帖子还是有一个问题，当爬虫爬下一个评论页的时候，这一页的数据它就会返回，所以在json数据中，就会有标题，链接重复，但评论和跟帖用户不一样的数据，本来的数据是一个帖子一条数据，但现在是只要这个帖子又下一页的评论，就会新建一条数据，虽然它的标题和链接是一样的。</p><h2 id="2018-12-26"><a href="#2018-12-26" class="headerlink" title="2018.12.26"></a>2018.12.26</h2><p>这问题困扰了我好几天，还是没有找到解决的办法，尝试过:</p><ul><li>在爬取comments的过程中，不yeild数据，将爬下来的评论append给meta，回调方法指向自身，重复直到没有下一页为止，但这样scrapy直接把之前的数据都丢掉了，可能是因为每次重新<br>进入方法的时候，都new了一个新的itemLoader。</li></ul><blockquote><p>暂时搁置一下，反正帖子标题是一样的，后面用pandas处理一下吧。</p></blockquote><p>我想提取出来的数据是，每个comments作为一条记录，同时记录帖子的标题和用户，但比对抓下来的数据后发现评论中的用户数量和评论本身不一致，这就尴尬了，不建立好对应关系，数据根本就没办法分析啊。</p><p>不过基本可以确定，评论中的第一条就是楼主，先把楼主的信息抓出来吧。</p><h2 id="2019-01-07"><a href="#2019-01-07" class="headerlink" title="2019.01.07"></a>2019.01.07</h2><p>今天了解到scrapy的另一个特性，即CrawlSpider类型的爬虫，在这个爬虫里面，它可以像下面这样去抽取post的连接和下一页的链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules = (</span><br><span class="line">    Rule(LinkExtractor(restrict_xpaths=&quot;//div[@class=&apos;pb_footer&apos;]//ul[@class=&apos;l_posts_num&apos;]//a&quot;),callback=&apos;parse&apos;),</span><br><span class="line">    Rule(LinkExtractor(restrict_xpaths=&quot;//a[@class=&apos;j_th_tit &apos;]&quot;),callback=&apos;parsePost&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>《精通python爬虫》这本书上说：</p><blockquote><p>Rule中可以指定回调函数，也就是上面我写的callback=’parse’(这里只能是函数的字符串名字，而不是self.parse)。如果我们没有指定callback函数，那么scrapy将会跟踪已经抽取的链接，如果你希望跟踪链接，那么需要再callback中使用return或yield返回它们，或者将Rule的follow参数设置为true，当你的页面既包含item又包含其他有用的导航链接时，该功能可能会非常有用。</p></blockquote><p>看完这一段，我有几个疑问：</p><ul><li>callback函数中，如何拿到想跟踪的链接？</li><li>yield的链接，直接返回这个链接，还是返回response对象？</li><li>返回的数据（或者链接），由谁来处理？</li></ul><p>rules: 是Rule对象的集合，用于匹配目标网站并排除干扰<br>parse_start_url: 用于爬取起始响应，必须要返回Item，Request中的一个。</p><p>查了一些资料，rules的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules = [</span><br><span class="line">    Rule(</span><br><span class="line">        link_extractor,     # LinkExtractor对象</span><br><span class="line">        callback=None,      # 请求到响应数据时的回调函数</span><br><span class="line">        cb_kwargs=None,     # 调用函数设置的参数,不要指定为parse</span><br><span class="line">        follow=None,        # 是否从response跟进链接，为布尔值</span><br><span class="line">        process_links=None, # 过滤linkextractor列表，每次获取列表时都会调用</span><br><span class="line">        process_request=None    # 过滤request,每次提取request都会调用</span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>LinkExtractor的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class scrapy.contrib.linkextractor.sgml.SgmlLinkExtractor(</span><br><span class="line">    allow = (),         # 符合正则表达式参数的数据会被提取</span><br><span class="line">    deny = (),          # 符合正则表达式参数的数据禁止提取</span><br><span class="line">    allow_domains = (),     # 包含的域名中可以提取数据</span><br><span class="line">    deny_domains = (),      # 包含的域名中禁止提取数据</span><br><span class="line">    deny_extensions = (),       </span><br><span class="line">    restrict_xpath = (),        # 使用xpath提取数据，和allow共同起作用</span><br><span class="line">    tags = (),          # 根据标签名称提取数据</span><br><span class="line">    attrs = (),         # 根据标签属性提取数据</span><br><span class="line">    canonicalize = (),</span><br><span class="line">    unique = True,          # 剔除重复链接请求</span><br><span class="line">    process_value = None</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="xpath参考"><a href="#xpath参考" class="headerlink" title="xpath参考"></a>xpath参考</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 进入scrapy调试界面</span><br><span class="line">scrapy shell &apos;url&apos;</span><br><span class="line"></span><br><span class="line">2. 调试界面使用xpath</span><br><span class="line">response.xpath(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">3. 抓取指定类的元素,//为获取所有元素，返回的是list，所有如果在上一级使用了//,那么下一级也是用//,如果是/,那么提取的就是该list中的第一个元素</span><br><span class="line">xpath(&apos;//div[@class=&quot;title&quot;]//text()&apos;),text()为获取该元素下的文本，如果需要纯文本，还需要在后面加extract()方法</span><br><span class="line"></span><br><span class="line">4. 提取属性</span><br><span class="line">xpath(&quot;//div[@class=&apos;pb_footer&apos;]//ul[@class=&apos;l_posts_num&apos;]//a//@href&quot;),主要是后面的@href</span><br></pre></td></tr></table></figure><h1 id="scrapy参考"><a href="#scrapy参考" class="headerlink" title="scrapy参考"></a>scrapy参考</h1><h2 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h2><blockquote><p>这里说的设置，只要在setting.py中添加一条记录即可</p></blockquote><ol><li><p>设置utf-8格式，避免中文出错<br>FEED_EXPORT_ENCODING = ‘utf-8’</p></li><li><p>不遵守网站的爬虫策略<br>ROBOTSTXT_OBEY = False</p></li></ol><h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><ol><li><p>启动爬虫<br>scrapy crawl CrawlerName</p></li><li><p>启动爬虫，导出数据为json<br>scrapy crawl CrawlerName -o filename.json </p></li><li><p>爬了指定的数据后，就关闭<br>scrapy crawl CrawlerName -o filename.json -s CLOSESPIDER_ITEMCOUNT=50</p></li></ol><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>scrapy shell环境下，配置user-agent:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">url = &apos;http://www.example.com&apos;</span><br><span class="line">request = scrapy.Request(url, headers=&#123;&apos;User-Agent&apos;: &apos;Mybot&apos;&#125;)</span><br><span class="line">fetch(request)</span><br></pre></td></tr></table></figure><ol><li>生成爬虫<br>scrapy genspider -l 查看可用的模版<br>scrapy genspider -t crawl name url </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;就是看看大家在贴吧玩啥，爬了100多兆母校的数据，回来慢慢分析，以后再做个数据可视化，感兴趣的可以拿去爬一下自己喜欢的贴吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="crawler" scheme="http://wittyfans.com/tags/crawler/"/>
    
      <category term="scrapy" scheme="http://wittyfans.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>用Python做数据可视化</title>
    <link href="http://wittyfans.com/coding/%E7%94%A8Python%E5%81%9A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html"/>
    <id>http://wittyfans.com/coding/用Python做数据可视化.html</id>
    <published>2019-01-16T12:24:41.000Z</published>
    <updated>2019-01-16T12:35:42.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Talk is cheap, show me the picture!</p></blockquote><a id="more"></a><h1 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h1><p>Import the plt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><h1 id="不同的图表"><a href="#不同的图表" class="headerlink" title="不同的图表"></a>不同的图表</h1><p>you can do this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data.plt.bar()</span><br></pre></td></tr></table></figure><p>and this is the diffrent types plot:</p><ul><li>‘bar’ or ‘barh’ for bar plots</li><li>‘hist’ for histogram</li><li>‘box’ for boxplot</li><li>‘kde’ or ‘density’ for density plots</li><li>‘area’ for area plots</li><li>‘scatter’ for scatter plots</li><li>‘hexbin’ for hexagonal bin plots</li><li>‘pie’ for pie plots</li></ul><p>and you can specific the kind in methond:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(kind=&apos;bar&apos;)</span><br></pre></td></tr></table></figure><p>Reference:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.plot.area     df.plot.barh     df.plot.density  df.plot.hist     df.plot.line     df.plot.scatter</span><br><span class="line">df.plot.bar      df.plot.box      df.plot.hexbin   df.plot.kde      df.plot.pie</span><br></pre></td></tr></table></figure><h1 id="把列合并展示"><a href="#把列合并展示" class="headerlink" title="把列合并展示"></a>把列合并展示</h1><p>When you plotting,stacked = True means conbined the columns value,from this:</p><p><img src="https://pandas.pydata.org/pandas-docs/stable/_images/bar_plot_multi_ex.png" alt=""></p><p>to this</p><p><img src="https://pandas.pydata.org/pandas-docs/stable/_images/bar_plot_stacked_ex.png" alt=""></p><p>plot.bar(stacked=True); </p><p>If you want thehorizontal bar plots, use the barh method:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df2.plot.barh(stacked=True)</span><br></pre></td></tr></table></figure><h1 id="使用绘图对象"><a href="#使用绘图对象" class="headerlink" title="使用绘图对象"></a>使用绘图对象</h1><p>Plots in matplotlib is a Figure object, you can new a plot window:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><h2 id="多个图一起绘制"><a href="#多个图一起绘制" class="headerlink" title="多个图一起绘制"></a>多个图一起绘制</h2><p>and you can add the sub plots to this object,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure() </span><br><span class="line">ax1 = fig.add_subplot(2, 2, 1) </span><br><span class="line">ax2 = fig.add_subplot(2, 2, 2) </span><br><span class="line">ax3 = fig.add_subplot(2, 2, 3)</span><br><span class="line">ax4 = fig.add_subplot(2, 2, 4)</span><br></pre></td></tr></table></figure><p>This will let you get four plot sub plots in one  window, and any command will show in the last plot.</p><h2 id="快速创建多个子图"><a href="#快速创建多个子图" class="headerlink" title="快速创建多个子图"></a>快速创建多个子图</h2><p>and you create subplots fast like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(3,3)</span><br><span class="line">axes[0,0].hist(np.random.randn(100),bins=20,color=&apos;k&apos;,alpha=0.3)</span><br></pre></td></tr></table></figure><h2 id="控制子图之间的间隙"><a href="#控制子图之间的间隙" class="headerlink" title="控制子图之间的间隙"></a>控制子图之间的间隙</h2><p>subplots spacing is under control by </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.subplots_adjust(wspace=0,hspace=0)</span><br></pre></td></tr></table></figure><h1 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h1><h2 id="线的虚实、颜色"><a href="#线的虚实、颜色" class="headerlink" title="线的虚实、颜色"></a>线的虚实、颜色</h2><p>In the plot() method, it can accept a string to stylying, to plot x verus y with green dashes , you would execute:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.plot(x,y,&apos;g--&apos;)</span><br></pre></td></tr></table></figure><p>of course, the color and dash can setting seperate:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ax.plot(x, y, linestyle=&apos;--&apos;, color=&apos;g&apos;)</span><br></pre></td></tr></table></figure><p>linestyle:</p><ul><li>-</li><li>--</li></ul><p>Line plots can additionally have <em>markers</em> to highlight the actual data points.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plot(&apos;ko--&apos;)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">plot(marker=&apos;o&apos;)</span><br></pre></td></tr></table></figure><h2 id="一份数据，多种展示方式"><a href="#一份数据，多种展示方式" class="headerlink" title="一份数据，多种展示方式"></a>一份数据，多种展示方式</h2><p>我们可以将不同的drawstyle结合在一起，放在同一幅图中显示，比如这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby(ri.stop_datetime.dt.hour).drugs_related_stop.mean().plot(linestyle=&apos;--&apos;,color=&apos;g&apos;,marker=&apos;o&apos;,label=&apos;Default&apos;)</span><br><span class="line">ri.groupby(ri.stop_datetime.dt.hour).drugs_related_stop.mean().plot(linestyle=&apos;-&apos;,color=&apos;r&apos;,marker=&apos;o&apos;,label=&apos;steps-post&apos;,drawstyle=&apos;steps-post&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://xfjlcq.bn.files.1drv.com/y4mHSUL0Fe0J2icuEUtKoUHovl1jCzOHR3BSoy5LdPsDttVbG0OJYys58TNGyXOLLj0elzuvTe8dSPxanf28ZanIF5y-qdjw_BoG3hlVLh0HiLxXbQpTRX2Mdg_wqv7jHA-cWaQdKRwpT07LUWhQNNF97VE4rtUSwCGLslxsludS7d7FTp1X9_c9z1eMPE5Nj2-Z4FZYU6zSUZXSD_iLFspsw/legendPlot.png?psid=1" alt=""></p><p>drawstyle的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;default&apos;, &apos;steps&apos;, &apos;steps-pre&apos;, &apos;steps-mid&apos;, &apos;steps-post&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="多份数据合并展示"><a href="#多份数据合并展示" class="headerlink" title="多份数据合并展示"></a>多份数据合并展示</h2><p>An easy way to adding legends:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from numpy.random import randn </span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(1, 1, 1)</span><br><span class="line">ax.plot(randn(1000).cumsum(), &apos;k&apos;, label=&apos;one&apos;) ax.plot(randn(1000).cumsum(), &apos;k--&apos;, label=&apos;two&apos;)</span><br><span class="line">ax.plot(randn(1000).cumsum(), &apos;k.&apos;, label=&apos;three&apos;) </span><br><span class="line">ax.legend(loc=&apos;best&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>The loc tells matplotlib where to place the plot. If you aren’t picky, ‘best’ is a good option, as it will choose a location that is most out of the way. To exclude one or more elements from the legend, pass no label or label=’<em>nolegend</em>‘.</p></blockquote><h2 id="设置图的基本属性"><a href="#设置图的基本属性" class="headerlink" title="设置图的基本属性"></a>设置图的基本属性</h2><p>设置plot的标题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ax.set_title(&apos;Drugs Releted Stop Search Rate&apos;)</span><br></pre></td></tr></table></figure><p>设置x轴的标题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ax.set_xlabel(&apos;hours&apos;)</span><br></pre></td></tr></table></figure><p>下面的x轴的单位和标签也可以设置，注意个数必须统一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drm = ri.groupby(ri.stop_datetime.dt.hour).drugs_related_stop.mean()</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(1,1,1)</span><br><span class="line">ax.plot(drm)</span><br><span class="line"></span><br><span class="line">ticks = ax.set_xticks([0,6,12,18])</span><br><span class="line">labels = ax.set_xticklabels([&apos;Mid Night&apos;,&apos;Morning&apos;,&apos;Moon&apos;,&apos;AftenNoon&apos;])</span><br></pre></td></tr></table></figure><blockquote><p>Y-axis is same, substituting y for x in above.</p></blockquote><h2 id="如何根据GroupBy中多列的值绘制"><a href="#如何根据GroupBy中多列的值绘制" class="headerlink" title="如何根据GroupBy中多列的值绘制"></a>如何根据GroupBy中多列的值绘制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig,ax = plt.subplots(figsize=(16,7))</span><br><span class="line">data.groupby(&apos;A&apos;,&apos;B&apos;).count().unstack().plot(ax=ax)</span><br></pre></td></tr></table></figure><p>Use the unstack method to plotting.</p><blockquote><p>To be contiuned…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Talk is cheap, show me the picture!&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="python" scheme="http://wittyfans.com/tags/python/"/>
    
      <category term="bigdata" scheme="http://wittyfans.com/tags/bigdata/"/>
    
      <category term="numpy" scheme="http://wittyfans.com/tags/numpy/"/>
    
      <category term="pandas" scheme="http://wittyfans.com/tags/pandas/"/>
    
      <category term="ploting" scheme="http://wittyfans.com/tags/ploting/"/>
    
  </entry>
  
  <entry>
    <title>利用Pandas分析美国交警开放的搜查数据</title>
    <link href="http://wittyfans.com/coding/%E5%88%A9%E7%94%A8Pandas%E5%88%86%E6%9E%90%E7%BE%8E%E5%9B%BD%E4%BA%A4%E8%AD%A6%E5%BC%80%E6%94%BE%E7%9A%84%E6%90%9C%E6%9F%A5%E6%95%B0%E6%8D%AE.html"/>
    <id>http://wittyfans.com/coding/利用Pandas分析美国交警开放的搜查数据.html</id>
    <published>2019-01-12T06:23:30.000Z</published>
    <updated>2019-01-16T12:16:56.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次偶然的机会看到<a href="">王树义</a>老师的推荐YouTube上的这个pandas视频教程，于是花了点时间学习了一下，也就有了这篇笔记，因为课程是英文的，也没有提供<br>中文字幕，所以我的笔记也就懒得再用中文写了。</p></blockquote><a id="more"></a><h1 id="利用Pandas分析美国交警开放的搜查数据"><a href="#利用Pandas分析美国交警开放的搜查数据" class="headerlink" title="利用Pandas分析美国交警开放的搜查数据"></a>利用Pandas分析美国交警开放的搜查数据</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>The tutorial will not cover pandas basics. If you are new to pandas or just need a refresher, I recommend watching some videos from my <a href="http://www.dataschool.io/easier-data-analysis-with-pandas/" target="_blank" rel="noopener">free pandas course</a>. Alternatively, you can review all of the code from my pandas course in this Jupyter notebook.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/justmarkham/pycon-2018-tutorial" target="_blank" rel="noopener">Using pandas for Better (and Worse) Data Science, Git主页</a></li><li><a href="https://www.youtube.com/watch?v=hl-TGI4550M&amp;list=PL5-da3qGB5IBITZj_dYSFqnd_15JgqwA6&amp;index=1" target="_blank" rel="noopener">Pandas best practices, Youtube 链接</a></li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="DownLoad-the-data"><a href="#DownLoad-the-data" class="headerlink" title="DownLoad the data"></a>DownLoad the data</h2><h3 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h3><ul><li><a href="https://openpolicing.stanford.edu/data/" target="_blank" rel="noopener">Link</a></li><li><a href="https://github.com/5harad/openpolicing/blob/master/DATA-README.md" target="_blank" rel="noopener">How to use the date</a></li></ul><h3 id="教程使用的数据"><a href="#教程使用的数据" class="headerlink" title="教程使用的数据"></a>教程使用的数据</h3><ul><li><a href="https://github.com/justmarkham/pycon-2018-tutorial/blob/master/police.csv" target="_blank" rel="noopener">police</a></li></ul><h2 id="About-the-data"><a href="#About-the-data" class="headerlink" title="About the data"></a>About the data</h2><ul><li>For each state in the dataset, They provide data in three formats(We use csv format)</li><li>If a column cannot be computed using the data a state has provided, it is set to NA.</li><li>For several fields (e.g., driver_race) we include a “raw” column which records the original data values from which we infer standardized values</li></ul><p>We include the raw columns because our data processing pipeline is extensive, requiring judgment calls and subjective decisions.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Column name</td><td>Column meaning</td><td>Example value</td></tr><tr><td>id</td><td>The unique ID we assign to each stop. Contains the state and year.</td><td>VT-2011-00012</td></tr><tr><td>state（州）</td><td>The two-letter code for the state in which the stop occurred.</td><td>VT</td></tr><tr><td>stop_date（被搜查的日期）</td><td>The date of the stop, in YYYY-MM-DD format. Some states do not provide the exact stop date: for example, they only provide the year or quarter in which the stop occurred. For these states, stop_date is set to the date at the beginning of the period: for example, January 1 if only year is provided.</td><td>2011-11-27</td></tr><tr><td>stop_time(被警察搜查时的时间)</td><td>The 24-hour time of the stop, in HH:MM format.</td><td>20:15</td></tr><tr><td>location_raw</td><td>The original data value from which we compute the county (or comparably granular location) in which the stop occurred. Not in a standardized format across states.</td><td>Winooski</td></tr><tr><td>county_name</td><td>The standardized name of the county in which the stop occurred.</td><td>Chittenden County</td></tr><tr><td>county_fips</td><td>The standardized 5-digit FIPS code in which the stop occurred.</td><td>50007</td></tr><tr><td>district</td><td>In several states (e.g., Illinois) the stop county cannot be inferred, but a comparably granular location can. This comparably granular location is stored in the district column. Most states do not have this column.</td><td>ILLINOIS STATE POLICE 01</td></tr><tr><td>fine_grained_location</td><td>Any higher-resolution data about where the stop occurred: e.g., milepost or address. Not standardized across states.</td><td>90400 I 89 N; EXIT 15 MM90/40</td></tr><tr><td>police_department</td><td>The police department or agency that made the stop. Not in a standard format across states.</td><td>WILLISTON VSP</td></tr><tr><td>driver_gender</td><td>The driver’s gender, as recorded by the trooper. M, F, or NA.</td><td>M</td></tr><tr><td>driver_age_raw</td><td>The original data value from which we compute the driver’s age when they were stopped. May be age, birth year, or birth date. Not in a standard format across states.</td><td>1988</td></tr><tr><td>driver_age</td><td>The driver’s age when they were stopped. Set to NA if less than 15 or greater than or equal to 100.</td><td>23</td></tr><tr><td>driver_race_raw</td><td>The original data value from which the driver’s standardized race is computed. Not in a standard format across states.</td><td>African American</td></tr><tr><td>driver_race</td><td>The standardized driver race. Possible values are White, Black, Hispanic, Asian, Other, and NA, with NA denoting values which are unknown. Asian refers to Asian, Pacific Islander, and Indian. Native Americans/American Indians are included in the “other” category. Anyone with Hispanic ethnicity is classified as Hispanic, regardless of their recorded race.</td><td>Black</td></tr><tr><td>violation_raw</td><td>The violation committed by the driver, in the language of the original data. Not in a standard format across states. Some stops have multiple violations.</td><td>Speeding (10–19 MPH Over Prima Facie Limit *)</td></tr><tr><td>violation</td><td>The violation committed by the driver, standardized into categories which are consistent across states.</td><td>Speeding</td></tr><tr><td>search_conducted（是否被搜查）</td><td>A TRUE/FALSE value indicating whether a search was performed.</td><td>TRUE</td></tr><tr><td>search_type_raw</td><td>The justification for the search, in the language of the original data. NA if no search was performed. Not in a standard format across states. Some states have multiple justifications for a search.</td><td>CONSENT SEARCH CONDUCTED</td></tr><tr><td>search_type</td><td>The normalized justification for the search. Where possible, this is standardized into categories which are consistent across states. For example, if something is clearly a consent search, search_type is referred to as “Consent”.</td><td>Consent</td></tr><tr><td>contraband_found</td><td>A TRUE/FALSE value indicating whether a search was performed and contraband was found. FALSE if no search was performed.</td><td>TRUE</td></tr><tr><td>stop_outcome</td><td>The outcome of the stop. Many states have idiosyncratic outcomes — for example, “CHP 215” in California — so this column is not standardized across states. “Citation” and “Warning” are the values which occur most commonly across states. If the stop has multiple outcomes, the most severe outcome is used. For example, if a stop resulted in a citation and a warning, stop_outcome would be “Citation”.</td><td>Citation</td></tr><tr><td>is_arrested</td><td>A TRUE/FALSE value indicating whether an arrest was made.</td><td>TRUE</td></tr></tbody></table><ul><li>FIPS：<a href="https://zh.wikipedia.org/wiki/%E8%81%AF%E9%82%A6%E8%B3%87%E6%96%99%E8%99%95%E7%90%86%E6%A8%99%E6%BA%96" target="_blank" rel="noopener">联邦信息处理标准（英语：Federal Information Processing Standards，缩写FIPS）</a></li><li>VT: <a href="https://www.google.com/search?q=vt%E6%98%AF%E5%93%AA%E4%B8%AA%E5%B7%9E&amp;rlz=1C5CHFA_enUS783US785&amp;oq=VT&amp;aqs=chrome.0.69i59j69i57j0l4.1878j0j1&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">美国的一个州</a></li><li>M,F: 记录性别，M男，F女</li><li>race: 可不是速度或者竞赛，而是种族,参考分类如下，与数据里的可能不一样，<a href="https://www.zhihu.com/question/21007176" target="_blank" rel="noopener">了解更多</a><ol><li>American Indian or Alaska Native</li><li>Asian</li><li>Black or African American</li><li>Native Hawaiian or Other Pacific Islander</li><li>White</li></ol></li><li>violation：违章</li><li>NAN means the value is missing or irrelevant for that data row.</li></ul><h1 id="Know-the-data"><a href="#Know-the-data" class="headerlink" title="Know the data"></a>Know the data</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv() # 读取csv文件</span><br><span class="line">pd.head() # 查看表头</span><br><span class="line">pd.tail() # 查看表尾</span><br><span class="line">pd.dtypes # 查看列的数据类型</span><br><span class="line">pd.isnull().sum() # 查看null值数量</span><br></pre></td></tr></table></figure><p>Import the data and check the dtypes:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri = pd.read_csv(&quot;/Users/wittyfans/Desktop/pycon-2018-tutorial/police.csv&quot;)</span><br><span class="line">ri.dtypes</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stop_date                     object</span><br><span class="line">stop_time                     object</span><br><span class="line">driver_gender                 object</span><br><span class="line">driver_age_raw               float64</span><br><span class="line">driver_age                   float64</span><br><span class="line">driver_race                   object</span><br><span class="line">violation_raw                 object</span><br><span class="line">violation                     object</span><br><span class="line">search_conducted                bool</span><br><span class="line">search_type                   object</span><br><span class="line">stop_outcome                  object</span><br><span class="line">is_arrested                   object</span><br><span class="line">stop_duration                 object</span><br><span class="line">drugs_related_stop              bool</span><br><span class="line">frisk                         object</span><br><span class="line">stop_datetime         datetime64[ns]</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><blockquote><p>可以看到有多少列，以及这列的数据类型，对数据有一个基本的了解。</p></blockquote><h2 id="年龄占比"><a href="#年龄占比" class="headerlink" title="年龄占比"></a>年龄占比</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mE65e58kzSnXPoiQuv06EIsD_5IgkuxLDZSIWIq3z0080umibcEGypBMNRyxrh-_t8ZpO1tinR38oIAqNEUEN2jl_IJOSCncuaaA6zXZnzvANNfEC9K2OEYVaIvvSF4JQyz1iQdZTfP4mQK8eQeO-2lRc3o0piHzbEaHXgDRDUWRtA6Tt4plvHj9nR-QjmSuni-o7LuM7g9XPA6ylYKSGfQ/driver_ages.png?psid=1" alt="年龄分布图"></p><h2 id="种族占比"><a href="#种族占比" class="headerlink" title="种族占比"></a>种族占比</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mTDy70KXCAzr_TjjsNCfUXYf6PAbhCY35FIoI5RleZO2gXs7aWmd3iUvH0lYMbhQLQFxdPLvup9F6M8iSrO8CEMqArMCBoOas1iyxSVO1zs8BX1oFG9_dOse1qmYqQ6mrv5tKl0fIODR5-9HsX9eN2qXj78TYzLcMrnA5wCM_O2CpUE-lzzvrNfx2-dNke55sPxQqnrC1eDjIAGF9VLnagg/driver_race.png?psid=1" alt="种族占比"></p><h2 id="毒驾被查时段分布"><a href="#毒驾被查时段分布" class="headerlink" title="毒驾被查时段分布"></a>毒驾被查时段分布</h2><p><img src="https://bn1301files.storage.live.com/y4mhtaWz5NsXj-qGHm5oUrB8ZIP9v0natmwePTIE8zMXgp0lRdXf1cFDU3hqAbkwy3FjZ46xiStnPN5h_P8UswB0h7D2PIFObR082XLqchJMrav4GRzwW2OdACiP6t51_7GB1NsT_ECU5knU2WWhsWpkx4mBD2Ms10uF0wpqGJ4HOWPfFqWxBenEOaBVBAQGW8xBxfhfqtScK7C3g5U8U8xeg/drugs_rate_in_day.png?psid=1&amp;width=2250&amp;height=1050" alt="毒驾被查时段分布"></p><h2 id="男性违章类别前十"><a href="#男性违章类别前十" class="headerlink" title="男性违章类别前十"></a>男性违章类别前十</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mY4aDbWKRRPvQNtn3akzjE5rXGJIRn07EZm0ZuqciitsV8N71Y4wtmjeQ8u55C00-Kqz5fdaN6yqpTZdmQE_gHgP1fjruNCIceCrguCkYx3UB7LWHTGNLipTEOIzb3AXhmTStDhMQNetfL9YLF0GL2uqJsDtNYtjGmcXFZDFBotzhrxP2oj1ZFGZPgnFHtrHzzzCEc9t_UUA28kZTijswUg/MViolations.png?psid=1" alt=""></p><h2 id="女性违章类别前十"><a href="#女性违章类别前十" class="headerlink" title="女性违章类别前十"></a>女性违章类别前十</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4m3ncUi3FGe1kHKeAAd8dat0yoPSrMmDUOV5soHlnkyNMMeNzUoFDvTCO0X13bycvU9zApH8_kS_0Xj-HdgxkoFHKU9NDHcUJo6VW30C0RIyLjuWJY0c-BTR3f3zp3PHj4qWV74CMl9Z32CWzGIcAbvVyCZAMrdMhj_FuZfJBp2wDgDEWjcABDhMcOlDSml6OD1wweR1L0A3jMQbDfwUV3ng/ViolationsType.png?psid=1" alt=""></p><h2 id="男女违章类别对比"><a href="#男女违章类别对比" class="headerlink" title="男女违章类别对比"></a>男女违章类别对比</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mMawv_h-NxRbffdJTPb-DlD__xVYddWhBdsrLsu_uDHcfqxYkP7unET7ikEPG_9n0m6v6tu3lb1zARO5tqAjmgMf8eVTFEjRnMAqmTEe7txh0nqah4bSMuPBnIgxoar-iSrKHRWjzOX8hLFTElP2jZPgbXa0ppqcxdKTRZFiVLsVPT8O_aDvIqxAJoxs_Alw7evCxhCMLO9KwopZEYapExg/mf_violations.png?psid=1" alt="男女违章类别对比"></p><h2 id="查获违章数（按年）"><a href="#查获违章数（按年）" class="headerlink" title="查获违章数（按年）"></a>查获违章数（按年）</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mkfreK_7B57c_c1WH3mQ9Ay6BW04wDjZMWXCgVaAsQ0gn5VoZRKsQmuyjmEKlpBai246ELuuVY0dtZFdlqdKzVKEI9jcLe6vRquAbGFSP0BrXHQo94PkzDbc0ud71OoOtUTHFsEQ-8b89O5OForTQujea-C29DVa5p5zWnRQx7Cfai_V3Cf0dB9yUO7g5CCpB_KoH3mKZVc2roODe4oCP1Q/Violations_years.png?psid=1" alt="查获违章数"></p><h2 id="违章查获时间段与年份"><a href="#违章查获时间段与年份" class="headerlink" title="违章查获时间段与年份"></a>违章查获时间段与年份</h2><p><img src="https://mcx9ta.bn.files.1drv.com/y4mIUjvRHUmNWYiV_TJbVARksZpQtddC1eI5GVzcjf_AjzpxfD8BDofc68PsmYyYfrfTafDodrlRiaN2ylj7b9sqqShsimXbMbMlGOVwlggUnTZ1uLwOLgyxmKBVcUBmVXnv_jNMX8Iwv5-F0ViFnak1KtVFENNfP1GqMRjBwBqrFx03XwyiYzBaZaTSeF6xahq1N7k2L8TC1j8nO_CFrkVoA/Search_rate_in_years.png?psid=1" alt="违章查获时间段分布"></p><h1 id="Handle-the-data"><a href="#Handle-the-data" class="headerlink" title="Handle the data"></a>Handle the data</h1><h2 id="1-Remove-the-column-that-only-contains-missing-values"><a href="#1-Remove-the-column-that-only-contains-missing-values" class="headerlink" title="1. Remove the column that only contains missing values"></a>1. Remove the column that only contains missing values</h2><h3 id="Drop-column"><a href="#Drop-column" class="headerlink" title="Drop column"></a>Drop column</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ri.drop(&apos;value&apos;,aixs=&apos;columns&apos;,inplace=True)</span><br><span class="line"></span><br><span class="line"># aixs = &apos;columns&apos;即我们要进行的是列操作，有时候也用aixs = 1代替。</span><br><span class="line"># inplace = True,即处理完后替代原来的数据，相当于下面这种写法：</span><br><span class="line"></span><br><span class="line">ri = ri.drop(&apos;county_name&apos;,axis=1)</span><br></pre></td></tr></table></figure><p>There is another way to drop the columns, like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del ri[&apos;columns_name&apos;]</span><br></pre></td></tr></table></figure><p>you can do that as this, that’s fine, but it’s not the <em>Pandas way</em>.</p><p>Tips:</p><ul><li>Pay attention to default arguments</li><li>check your work</li><li>There is more than one way to do everything in pandas</li></ul><h2 id="2-Do-men-or-women-speed-more-often"><a href="#2-Do-men-or-women-speed-more-often" class="headerlink" title="2. Do men or women speed more often?"></a>2. Do men or women speed more often?</h2><h3 id="driver-gender-violaton"><a href="#driver-gender-violaton" class="headerlink" title="driver_gender,violaton"></a>driver_gender,violaton</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.violation == &quot;Speeding&quot;].driver_gender.value_counts()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M    32979</span><br><span class="line">F    15482</span><br><span class="line">Name: driver_gender, dtype: int64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.violation == &quot;Speeding&quot;].driver_gender.value_counts(normalize=True) # get the percent value, 如果一个人超速，那么多大几率是男性或女性</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M    0.680527</span><br><span class="line">F    0.319473</span><br><span class="line">Name: driver_gender, dtype: float64</span><br></pre></td></tr></table></figure><p>反过来看，女性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.driver_gender == &apos;F&apos;].violation.value_counts(normalize=True)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Speeding               0.658500</span><br><span class="line">Moving violation       0.136277</span><br><span class="line">Equipment              0.105780</span><br><span class="line">Registration/plates    0.043086</span><br><span class="line">Other                  0.029348</span><br><span class="line">Seat belt              0.027009</span><br><span class="line">Name: violation, dtype: float64</span><br></pre></td></tr></table></figure><p>男性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.driver_gender == &apos;M&apos;].violation.value_counts(normalize=True)</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Speeding               0.524350</span><br><span class="line">Moving violation       0.207012</span><br><span class="line">Equipment              0.135671</span><br><span class="line">Other                  0.057668</span><br><span class="line">Registration/plates    0.038461</span><br><span class="line">Seat belt              0.036839</span><br><span class="line">Name: violation, dtype: float64</span><br></pre></td></tr></table></figure></p><p>合并成一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby(&apos;driver_gender&apos;).violation.value_counts(normalize=True)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">driver_gender  violation          </span><br><span class="line">F              Speeding               0.658500</span><br><span class="line">               Moving violation       0.136277</span><br><span class="line">               Equipment              0.105780</span><br><span class="line">               Registration/plates    0.043086</span><br><span class="line">               Other                  0.029348</span><br><span class="line">               Seat belt              0.027009</span><br><span class="line">M              Speeding               0.524350</span><br><span class="line">               Moving violation       0.207012</span><br><span class="line">               Equipment              0.135671</span><br><span class="line">               Other                  0.057668</span><br><span class="line">               Registration/plates    0.038461</span><br><span class="line">               Seat belt              0.036839</span><br><span class="line">Name: violation, dtype: float64</span><br></pre></td></tr></table></figure><blockquote><p>when you wirte the groupby, just think for each value(in here is gender, man or women).</p></blockquote><ul><li>count(): 返回所有数据统计之和</li><li>value_counts(): 分别统计该数据分类下（如果有）的值</li><li>normalize = True: 该选项等于True，则会返回 <em>relative frequencies of the unique values.</em></li></ul><h2 id="3-Does-gender-affect-who-gets-searched-during-a-stop"><a href="#3-Does-gender-affect-who-gets-searched-during-a-stop" class="headerlink" title="3. Does gender affect who gets searched during a stop?"></a>3. Does gender affect who gets searched during a stop?</h2><h3 id="driver-gender-search-conducted"><a href="#driver-gender-search-conducted" class="headerlink" title="driver_gender,search_conducted"></a>driver_gender,search_conducted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.search_conducted.value_counts(normalize=True)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False    0.965163</span><br><span class="line">True     0.034837</span><br><span class="line">Name: search_conducted, dtype: float64</span><br></pre></td></tr></table></figure><p>Same results with above, how does that work?<br>If the serious value is bool type and you can always just get a sum to konw the number of ones, or a mean to get the percentage of ones, that will simplify you code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.search_conducted.mean()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.03483720473942948</span><br></pre></td></tr></table></figure><p>groupby gender:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby(&apos;driver_gender&apos;).search_conducted.mean()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver_gender</span><br><span class="line">F    0.020033</span><br><span class="line">M    0.043326</span><br><span class="line">Name: search_conducted, dtype: float64</span><br></pre></td></tr></table></figure><p>Does that prove any things? No, </p><ul><li>Causation is difficult to conclude, so focus on relationships.</li><li>Include all relevant factors when studying a relationship.</li></ul><p>Let’s see details:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby([&apos;driver_gender&apos;,&apos;violation&apos;]).search_conducted.mean()</span><br></pre></td></tr></table></figure></p><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">driver_gender  violation          </span><br><span class="line">F              Equipment              0.042622</span><br><span class="line">               Moving violation       0.036205</span><br><span class="line">               Other                  0.056522</span><br><span class="line">               Registration/plates    0.066140</span><br><span class="line">               Seat belt              0.012598</span><br><span class="line">               Speeding               0.008720</span><br><span class="line">M              Equipment              0.070081</span><br><span class="line">               Moving violation       0.059831</span><br><span class="line">               Other                  0.047146</span><br><span class="line">               Registration/plates    0.110376</span><br><span class="line">               Seat belt              0.037980</span><br><span class="line">               Speeding               0.024925</span><br><span class="line">Name: search_conducted, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="4-Why-is-search-type-missing-so-often"><a href="#4-Why-is-search-type-missing-so-often" class="headerlink" title="4. Why is search_type missing so often?"></a>4. Why is search_type missing so often?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.search_conducted.value_counts()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False    88545</span><br><span class="line">True      3196</span><br><span class="line">Name: search_conducted, dtype: int64</span><br></pre></td></tr></table></figure><p>search_conducted means a search performed, 即一个车主被警察查了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.search_type.count()</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Incident to Arrest                                          1219</span><br><span class="line">Probable Cause                                               891</span><br><span class="line">Inventory                                                    220</span><br><span class="line">Reasonable Suspicion                                         197</span><br><span class="line">Protective Frisk                                             161</span><br><span class="line">Incident to Arrest,Inventory                                 129</span><br><span class="line">Incident to Arrest,Probable Cause                            106</span><br><span class="line">Probable Cause,Reasonable Suspicion                           75</span><br><span class="line">Incident to Arrest,Inventory,Probable Cause                   34</span><br><span class="line">Probable Cause,Protective Frisk                               33</span><br><span class="line">Incident to Arrest,Protective Frisk                           33</span><br><span class="line">Inventory,Probable Cause                                      22</span><br><span class="line">Incident to Arrest,Reasonable Suspicion                       13</span><br><span class="line">Incident to Arrest,Inventory,Protective Frisk                 11</span><br><span class="line">Inventory,Protective Frisk                                    11</span><br><span class="line">Protective Frisk,Reasonable Suspicion                         11</span><br><span class="line">Incident to Arrest,Probable Cause,Protective Frisk            10</span><br><span class="line">Incident to Arrest,Probable Cause,Reasonable Suspicion         6</span><br><span class="line">Incident to Arrest,Inventory,Reasonable Suspicion              4</span><br><span class="line">Inventory,Reasonable Suspicion                                 4</span><br><span class="line">Inventory,Probable Cause,Reasonable Suspicion                  2</span><br><span class="line">Inventory,Probable Cause,Protective Frisk                      2</span><br><span class="line">Probable Cause,Protective Frisk,Reasonable Suspicion           1</span><br><span class="line">Incident to Arrest,Protective Frisk,Reasonable Suspicion       1</span><br><span class="line">Name: search_type, dtype: int64</span><br></pre></td></tr></table></figure></p><p>search_type, the reason for search performed, 即警察为什么要查这个车。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.search_conducted == False].search_type.value_counts()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Series([], Name: search_type, dtype: int64)</span><br></pre></td></tr></table></figure><p>return empty series, why? because there is no value to count, nan and null is not a value, if it’s not what you want,add dropna= False in the value_counts() method likt this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.search_conducted == False].search_type.value_counts(dropna=False)</span><br></pre></td></tr></table></figure><h2 id="5-During-a-search-how-often-is-the-driver-frisked"><a href="#5-During-a-search-how-often-is-the-driver-frisked" class="headerlink" title="5. During a search, how often is the driver frisked?"></a>5. During a search, how often is the driver frisked?</h2><blockquote><p>How to know is there a word in a string in Python? You may use ‘a’ in b, this is the pythoy way, we got pandas way like this:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ri.search_type.str.contains()</span><br></pre></td></tr></table></figure><p>针对每一行，判断是否有字符串在其中，有则返回True，无则False.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri[&apos;frisk&apos;] = ri.search_type.str.contains(&apos;Probable Cause&apos;)</span><br><span class="line">ri.frisk</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0          NaN</span><br><span class="line">1          NaN</span><br><span class="line">2          NaN</span><br><span class="line">3          NaN</span><br><span class="line">4          NaN</span><br><span class="line">5          NaN</span><br><span class="line">6          NaN</span><br><span class="line">7          NaN</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.frisk.value_counts(dropna=False)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NaN      88545</span><br><span class="line">False     2014</span><br><span class="line">True      1182</span><br><span class="line">Name: frisk, dtype: int64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ri.frisk.sum() -&gt; 1182</span><br><span class="line">ri.frisk.mean() -&gt; 0.36983729662077597</span><br><span class="line">1182/(1182+2014) -&gt; 0.36983729662077597</span><br></pre></td></tr></table></figure><p>the mean, is caculated by frisked / (frisked+unfrisked), and will <strong>excluded the missing values.</strong></p><h2 id="6-Which-year-had-the-least-number-of-stops"><a href="#6-Which-year-had-the-least-number-of-stops" class="headerlink" title="6. Which year had the least number of stops?"></a>6. Which year had the least number of stops?</h2><h3 id="Method-1-Use-the-str-slice"><a href="#Method-1-Use-the-str-slice" class="headerlink" title="Method 1: Use the str.slice"></a>Method 1: Use the str.slice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_date.str.slice(0,4).value_counts()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2012    10970</span><br><span class="line">2006    10639</span><br><span class="line">2007     9476</span><br><span class="line">2014     9228</span><br><span class="line">2008     8752</span><br><span class="line">2015     8599</span><br><span class="line">2011     8126</span><br><span class="line">2013     7924</span><br><span class="line">2009     7908</span><br><span class="line">2010     7561</span><br><span class="line">2005     2558</span><br></pre></td></tr></table></figure><p>The stop_date format is: 2005-01-02, so slice(0,4) will return 2005, then do a value_counts will get the number of stops in all years.</p><h3 id="Method-2-Use-the-datetime"><a href="#Method-2-Use-the-datetime" class="headerlink" title="Method 2: Use the datetime"></a>Method 2: Use the datetime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combined = ri.stop_date.str.cat(ri.stop_time,sep=&apos; &apos;)</span><br><span class="line">ri[&apos;stop_datetime&apos;] = pd.to_datetime(combined)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2012    10970</span><br><span class="line">2006    10639</span><br><span class="line">2007     9476</span><br><span class="line">2014     9228</span><br><span class="line">2008     8752</span><br><span class="line">2015     8599</span><br><span class="line">2011     8126</span><br><span class="line">2013     7924</span><br><span class="line">2009     7908</span><br><span class="line">2010     7561</span><br><span class="line">2005     2558</span><br></pre></td></tr></table></figure><p>Use the pd.to_datetime method to convert a concated string to a datatime type value, then add a new col in ri.<br>cat is a string method to concat two string, the sep arg is a string or char you want insert in center.</p><p>So, after that, how to get the year value?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_datetime.dt.year.value_counts()</span><br></pre></td></tr></table></figure><p>datetime has a method .dt, and you can .year, .day, etc.</p><h2 id="7-How-does-drug-activity-change-by-time-of-day"><a href="#7-How-does-drug-activity-change-by-time-of-day" class="headerlink" title="7. How does drug activity change by time of day?"></a>7. How does drug activity change by time of day?</h2><h3 id="stop-datetime-drugs-related-stop"><a href="#stop-datetime-drugs-related-stop" class="headerlink" title="stop_datetime,drugs_related_stop"></a>stop_datetime,drugs_related_stop</h3><p>Let’s specific, for every hour, what is the rate of the drugs_related_stop?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby(ri.stop_datetime.dt.hour).drugs_related_stop.mean()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">stop_datetime</span><br><span class="line">0     0.019728</span><br><span class="line">1     0.013507</span><br><span class="line">2     0.015462</span><br><span class="line">3     0.017065</span><br><span class="line">4     0.011811</span><br><span class="line">5     0.004762</span><br><span class="line">6     0.003040</span><br><span class="line">7     0.003281</span><br><span class="line">8     0.002687</span><br><span class="line">9     0.006288</span><br><span class="line">10    0.005714</span><br><span class="line">11    0.006976</span><br><span class="line">12    0.004467</span><br><span class="line">13    0.010326</span><br><span class="line">14    0.007810</span><br><span class="line">15    0.006416</span><br><span class="line">16    0.005723</span><br><span class="line">17    0.005517</span><br><span class="line">18    0.010148</span><br><span class="line">19    0.011596</span><br><span class="line">20    0.008084</span><br><span class="line">21    0.013342</span><br><span class="line">22    0.013533</span><br><span class="line">23    0.016344</span><br><span class="line">Name: drugs_related_stop, dtype: float64</span><br></pre></td></tr></table></figure><p>show it!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.groupby(ri.stop_datetime.dt.hour).drugs_related_stop.mean().plot()</span><br></pre></td></tr></table></figure><p>output:</p><p><img src="https://mcwywq.bn.files.1drv.com/y4mkRchu7eh5ClZ_5hMguC0V-k3KY7tnt0-KpbEoif1EgVMEXCdt5VIxstOsVv-urRgNOdK6ebfF1SfkOyqWmxjcfz1a6F9_uQQpW79nkbZmYiKGVvAr1M6vXbh9ly0DNOSCIkNgyrDwQkjpDXtfRMwtfsZkhyd7UqsZJeKMxSsGfClSDqucjlFGZ3A7xkFxLDzORpau6TMPGXIkjjDjMkXHw/drugs_related.png?psid=1" alt=""></p><p>if you want the notebook auto show the img, make sure you imported the packge.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>then when you type .plot() the img will show automatically.</p><p>Lesssons:</p><ul><li>Consider removing chunks of data that may be biased</li><li>Use the datetime data type for dates and times</li></ul><h2 id="8-Do-most-stops-occur-at-night"><a href="#8-Do-most-stops-occur-at-night" class="headerlink" title="8. Do most stops occur at night?"></a>8. Do most stops occur at night?</h2><p>Let do this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_datetime.dt.hour.value_counts().plot()</span><br></pre></td></tr></table></figure><p>you will get an error img, because the plot is generated by the value, not the index(in here is the hour),<br>so you need to sort with index first,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_datetime.dt.hour.value_counts().sort_index().plot()</span><br></pre></td></tr></table></figure><p>ouput:</p><p><img src="https://mcwywq.bn.files.1drv.com/y4mkRchu7eh5ClZ_5hMguC0V-k3KY7tnt0-KpbEoif1EgVMEXCdt5VIxstOsVv-urRgNOdK6ebfF1SfkOyqWmxjcfz1a6F9_uQQpW79nkbZmYiKGVvAr1M6vXbh9ly0DNOSCIkNgyrDwQkjpDXtfRMwtfsZkhyd7UqsZJeKMxSsGfClSDqucjlFGZ3A7xkFxLDzORpau6TMPGXIkjjDjMkXHw/drugs_related.png?psid=1" alt=""></p><p>and there is a details version:</p><p><img src="https://bn1301files.storage.live.com/y4mfDJ5BskfJi6Bl_KlVmBzKUzosUMz4c6sJtnFknHh-mKevDycVq5ghobnTWVfINyG-pQDAIfZK6UNCZOSpUP2IxLJJtgkpS4TN9lmc0VN0OcINS3bjH7EoGLkpNl0gsmiIlcTiyxb7K_qZyjTjmGu3-rCJ52mGcepghI8NxsInK-WUiy51tw0vQJGV-vKmdX78YOBeACPpGGemOYrpTmCcg/stop_hour_details.png?psid=1&amp;width=1278&amp;height=852" alt=""></p><p>bt, how to define the night, In my view 22-4 is night, I want to filter the hours:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ri[(ri.stop_datetime.dt.hour &gt; 4) &amp; (ri.stop_datetime.dt.hour &lt; 22)].shape</span><br></pre></td></tr></table></figure><p>if you have a category, want to apply the hours, you can define a method and map to the hours.</p><h2 id="9-Find-the-bad-data-in-the-stop-duration-column-and-fix-it"><a href="#9-Find-the-bad-data-in-the-stop-duration-column-and-fix-it" class="headerlink" title="9. Find the bad data in the stop_duration column and fix it"></a>9. Find the bad data in the stop_duration column and fix it</h2><p>Check this value counts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_duration.value_counts()</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0-15 Min     69543</span><br><span class="line">16-30 Min    13635</span><br><span class="line">30+ Min       3228</span><br><span class="line">2                1</span><br><span class="line">1                1</span><br><span class="line">Name: stop_duration, dtype: int64</span><br></pre></td></tr></table></figure><p>We want to turn the stop_duration value equals ‘1’ to ‘NAN’, how?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri[(ri.stop_duration == &apos;1&apos;) | (ri.stop_duration == &apos;2&apos;)].stop_duration == &apos;NAN&apos;</span><br></pre></td></tr></table></figure><p>that looks make sense,but check the value counts, it does’nt work.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0-15 Min     69543</span><br><span class="line">16-30 Min    13635</span><br><span class="line">30+ Min       3228</span><br><span class="line">2                1</span><br><span class="line">1                1</span><br><span class="line">Name: stop_duration, dtype: int64</span><br></pre></td></tr></table></figure><p>why? acturlly, you may get a warnning,</p><blockquote><p><em>A value is trying to be set on a copy of a slice from a DataFrame.</em></p></blockquote><p>You should use loc.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ri.loc[(ri.stop_duration == &apos;1&apos;) | (ri.stop_duration == &apos;2&apos;),&apos;stop_duration&apos;] = &apos;NAN&apos;</span><br></pre></td></tr></table></figure><p>check again:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0-15 Min     69543</span><br><span class="line">16-30 Min    13635</span><br><span class="line">30+ Min       3228</span><br><span class="line">NAN              2</span><br><span class="line">Name: stop_duration, dtype: int64</span><br></pre></td></tr></table></figure><p>注意比较一下这两者用法上的区别，如果想要了解更多loc的用法，可以关注该作者的另一个单独介绍的视频，<a href="https://www.youtube.com/watch?v=xvpNA7bC8cs" target="_blank" rel="noopener">油管链接</a>。</p><p>but you get two string format ‘NAN’, you want get a really NAN value, okay, let fix it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">ri.loc[ri.stop_duration == &apos;NAN&apos;,&apos;stop_duration&apos;] = np.nan</span><br></pre></td></tr></table></figure><p>there you go!</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 0-15 Min     69543</span><br><span class="line">16-30 Min    13635</span><br><span class="line">30+ Min       3228</span><br><span class="line">Name: stop_duration, dtype: int64</span><br></pre></td></tr></table></figure><h1 id="Ploting"><a href="#Ploting" class="headerlink" title="Ploting"></a>Ploting</h1><h2 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ri = pd.read_csv(&quot;C:/Users/Fan.ZhangFZ/Desktop/police.csv&quot;)</span><br><span class="line">ri.drop(&apos;county_name&apos;,axis=&apos;columns&apos;,inplace=True)</span><br><span class="line">ri.dtypes</span><br></pre></td></tr></table></figure><h2 id="年龄分布状况"><a href="#年龄分布状况" class="headerlink" title="年龄分布状况"></a>年龄分布状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ageinfo = ri.driver_age.value_counts()</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(12,8))</span><br><span class="line">ax = fig.add_subplot(1,1,1)</span><br><span class="line">ax.bar(ageinfo.index,ageinfo.values,color=&apos;g&apos;)</span><br><span class="line">ax.set_xlabel(&apos;Driver age&apos;)</span><br><span class="line">ax.set_ylabel(&apos;Number of driver&apos;)</span><br><span class="line">xticks = ax.set_xticks(np.arange(15,100,5))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="搜查时间"><a href="#搜查时间" class="headerlink" title="搜查时间"></a>搜查时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stoped_datetime = ri.stop_date.str.cat(ri.stop_time,sep=&apos; &apos;)</span><br><span class="line">ri[&apos;stoped_datetime&apos;] = pd.to_datetime(stoped_datetime)</span><br><span class="line">year_counts = ri.stoped_datetime.dt.year.value_counts().sort_index()</span><br><span class="line">hour_counts = ri.stoped_datetime.dt.hour.value_counts().sort_index()</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(12,14))</span><br><span class="line">ax1 = fig.add_subplot(2,1,1)</span><br><span class="line">ax1.plot(year_counts.index,year_counts.values,marker=&apos;o&apos;,color=&apos;y&apos;,linestyle=&apos;--&apos;)</span><br><span class="line">ax1.set_xlabel(&apos;Years&apos;)</span><br><span class="line">ax1.set_ylabel(&apos;Search Count&apos;)</span><br><span class="line">ax1.set_title(&quot;Search rate in diffrent years&quot;)</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(2,1,2)</span><br><span class="line">ax2.set_xlabel(&apos;Hours&apos;)</span><br><span class="line">ax2.set_ylabel(&apos;Search Count&apos;)</span><br><span class="line">ax2.plot(hour_counts.index,hour_counts.values,marker=&apos;o&apos;,color=&apos;b&apos;,linestyle=&apos;--&apos;)</span><br><span class="line">ax2.set_title(&quot;Search rate in diffrent hours&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="种族情况"><a href="#种族情况" class="headerlink" title="种族情况"></a>种族情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver_race = ri.driver_race.value_counts()</span><br><span class="line">fig = plt.figure(figsize=(12,8))</span><br><span class="line">ax = fig.add_subplot(1,1,1)</span><br><span class="line">ax.bar(driver_race.index,driver_race.values)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="男女超速的比例"><a href="#男女超速的比例" class="headerlink" title="男女超速的比例"></a>男女超速的比例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.violation == &quot;Speeding&quot;].driver_gender.value_counts().plot.pie(figsize=(8, 8),labels=[&apos;Men&apos;, &apos;Female&apos;],autopct=&apos;%.2f&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="男性违章类型占比"><a href="#男性违章类型占比" class="headerlink" title="男性违章类型占比"></a>男性违章类型占比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ri[ri.driver_gender == &apos;M&apos;].violation.value_counts(normalize=True).plot.pie(figsize=(8, 8),autopct=&apos;%.2f&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="女性违章占比"><a href="#女性违章占比" class="headerlink" title="女性违章占比"></a>女性违章占比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri[ri.driver_gender == &apos;F&apos;].violation.value_counts(normalize=True).plot.pie(figsize=(8, 8),autopct=&apos;%.2f&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="合并展示"><a href="#合并展示" class="headerlink" title="合并展示"></a>合并展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = ri.groupby([&apos;driver_gender&apos;]).violation.value_counts(normalize=True)*100</span><br><span class="line">fig, ax = plt.subplots(figsize=(15,7))</span><br><span class="line"># use unstack()</span><br><span class="line">data.unstack().plot.bar(ax=ax,stacked=True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="被搜查人员为男、女的概率"><a href="#被搜查人员为男、女的概率" class="headerlink" title="被搜查人员为男、女的概率"></a>被搜查人员为男、女的概率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = ri.groupby(&apos;driver_gender&apos;).search_conducted.mean()</span><br><span class="line">fig,ax = plt.subplots(figsize=(5,7))</span><br><span class="line">data.plot.pie(ax=ax,autopct=&apos;%.2f&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="违章类型占比"><a href="#违章类型占比" class="headerlink" title="违章类型占比"></a>违章类型占比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search_type = ri.search_type.value_counts()</span><br><span class="line">fig,ax = plt.subplots(figsize=(6,10))</span><br><span class="line">search_type.plot.barh(color=&apos;r&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="哪一年违章最多"><a href="#哪一年违章最多" class="headerlink" title="哪一年违章最多"></a>哪一年违章最多</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ri.stop_date.str.slice(0,4).value_counts().sort_index().plot.barh(figsize=(12,8),color=&apos;y&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="一天中什么时候毒驾率最高？"><a href="#一天中什么时候毒驾率最高？" class="headerlink" title="一天中什么时候毒驾率最高？"></a>一天中什么时候毒驾率最高？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drug_hour_rate = ri.groupby(ri.stoped_datetime.dt.hour).drugs_related_stop.mean() * 100</span><br><span class="line">fig,ax = plt.subplots(figsize=(15,7))</span><br><span class="line">xticks = ax.set_xticks(np.arange(0,24,1))</span><br><span class="line">ax.set_title(&apos;Rate for drugs related stop in a day&apos;)</span><br><span class="line">ax.set_ylabel(&apos;Rate,%&apos;)</span><br><span class="line">ax.set_xlabel(&apos;Hours&apos;)</span><br><span class="line">drug_hour_rate.plot(ax=ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h1><ul><li>search：这里应该理解为警察的搜查</li><li>hypothetical: 假设</li><li>slick way,精明的小技巧</li><li>registration searched: 车牌造假违章</li><li>conducted: 处理、行为</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一次偶然的机会看到&lt;a href=&quot;&quot;&gt;王树义&lt;/a&gt;老师的推荐YouTube上的这个pandas视频教程，于是花了点时间学习了一下，也就有了这篇笔记，因为课程是英文的，也没有提供&lt;br&gt;中文字幕，所以我的笔记也就懒得再用中文写了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="Data Science" scheme="http://wittyfans.com/tags/Data-Science/"/>
    
      <category term="Pandas" scheme="http://wittyfans.com/tags/Pandas/"/>
    
      <category term="Big Data" scheme="http://wittyfans.com/tags/Big-Data/"/>
    
  </entry>
  
</feed>
