<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wittyfans</title>
  
  <subtitle>学则不固,知则不惑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wittyfans.com/"/>
  <updated>2018-03-15T17:46:16.952Z</updated>
  <id>http://wittyfans.com/</id>
  
  <author>
    <name>wittyfans</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爱默生文集摘录</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E6%96%87%E9%9B%86%E6%91%98%E5%BD%95%E4%B8%80.html"/>
    <id>http://wittyfans.com/reading/爱默生文集摘录一.html</id>
    <published>2017-11-18T14:16:10.000Z</published>
    <updated>2018-03-15T17:46:16.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。</p></blockquote><a id="more"></a><h1 id="人的行为方式"><a href="#人的行为方式" class="headerlink" title="人的行为方式"></a>人的行为方式</h1><ul><li>无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。</li><li>当一个诗人不写诗时，他们就把诗融进自己的形体和行为方式。</li><li>当一个人已经充分表达了他的思想时，他所拥有的精神财富却没有丝毫损失。</li><li>当有人在生活中产生某种体验和感受禁不住要说出来的时候，我们的原则是：帮助他，让他说出来。当一个人向别人阐述他的思想时，他也就是在阐述他这个人本身；但是，当人企图把完整的思想拆开来逐一向人们解说时，他就使其讹用而变得不够准确了。</li></ul><h1 id="别人的价值观"><a href="#别人的价值观" class="headerlink" title="别人的价值观"></a>别人的价值观</h1><ul><li>现在的小说千篇一律，千人一面，类同相似，并且语言往往也是极为粗俗的。他通过描绘少男少女的浪漫生活将我们引入到一种对自私的利益和价值的追求。</li><li>小说也可以像《圣经》一样发挥巨大的积极的社会作用，只要他们展示给人们的是最好的社会生活侧面,解读的是善良、正直、真诚的人际关系。这是对友谊概念的一种法国式的阐释， 一种积极的理解。只有真诚才能在我们之间建立起最紧密的关系。这也正是所有好的小说的魅力所在，这实际上是历史事件的魅力。 </li></ul><h1 id="交际与交往"><a href="#交际与交往" class="headerlink" title="交际与交往"></a>交际与交往</h1><ul><li>我无需经常与他见面、交谈或写信，一切均在默契之中；我们也无需刻意去加深他对我们的印 象，或是寄去引起他回忆的纪念品；我信任他就如同信任自己；如果他也如此这般地做,我知道那是完全正常的。 </li><li>我不愿祈求美人的爱情，也不愿祈求朋友的友谊。</li><li>有些人不知不觉中伤害我们，剥夺我们的思想，关押和囚禁我们的精神。如果能心心相印，只需要一个聪敏的朋友便已足矣。</li><li>一个恶毒又好强的傻瓜常常会伤及很多人的理智，精神反常的人顽固的坚持错误，甚至连最优秀的人都有可能被激怒，十足的傻瓜相信唯有自己正确，连万有引力都是错的，如果谁要抨击，傻瓜会勃然大怒，与他交往密切的人，很快也会变得反常。</li><li>怎样和并不相宜的伙伴一同生活呢？生活中最美好的经历，就是同富有智慧的人们开诚布公的交往，这种交往会使我们相信，有一种精神力量正在召唤着我们，比称之为哲学或文学的东西更为灵验，更值得我们欢欣鼓舞。</li></ul><h1 id="需要反省的都市生活"><a href="#需要反省的都市生活" class="headerlink" title="需要反省的都市生活"></a>需要反省的都市生活</h1><ul><li>繁华都市里，市民们唯利是图、既无道德约束，又缺乏友情和热心。他们很难称之为人，而是些行尸走肉受欲望驱动着的物体。毫无生活目标，得过且过。</li><li>他们不相信知识分子，也不相信道德说教。仅仅相信化学工业、制酒食品业、机器制造业、蒸汽机、直流电、渦轮、缝细机和舆论，而不相信神圣的事业。</li></ul><h1 id="意志的力量"><a href="#意志的力量" class="headerlink" title="意志的力量"></a>意志的力量</h1><ul><li>人只有在自己先站起来之后，这个世界才有可能属于他。</li><li>意识薄弱者总是相信运气，相信他人的施舍。意识坚定则相信事物的因果关系，细加分析，毫无运气可言，完全是自然运行的事件和现象。</li><li>我绝不会失败，除非自己打败自己。</li><li>一个人在知己知彼客观分析之后，如果仍看不出差距，那么他将很容易被敌人打败。</li><li>我不能低估自己，去受环境的支配。</li><li>为了让你的知识更有价值，你就必须学会如何快乐，由衷的享乐人生就得到了滋养，因为精神喜悦就意味着力量。所有健康的个体，其心境都是舒畅的。天才在娱乐中工作，也就拥有了精神的力量，他就不会意志沮丧，相反会变得生龙活虎，雄心勃勃，但凡心灰意懒，就必然精神不振。</li><li>举止随和言语亲切能使人顺应任何环境。</li></ul><h1 id="美"><a href="#美" class="headerlink" title="美"></a>美</h1><ul><li>鲜花美丽、源于根基。</li><li>他越能够真正的适应自己，他就越美。</li><li>外在的修饰只是一种伪装，如果一切的行为的目的只是让人观看，那么这行为难免就显得下贱。</li><li>道德决定着健康的程度，假如你有一种永恒的追求，你的才智、行动必回体现，那将是一种崇高的美，任何人都望尘莫及。</li><li>任何呆滞刻板的或束缚于有限之中的东西都不会令人产生美，惟有那种与生命一道流滴，努力超越极限的东西才能令我们兴趣蔬然。</li><li>宫殿或圣殿之所以美，是因为一种秩序输入石头之中，它们就好像能够说话，能够用几何图形来表达；因而它们能够随着这种表达而变得温柔或崇高。</li><li>任何凝滞、堆砌或者过分注重的某一特征，一一例如长长的鼻子，尖尖的下巴，驼起的背，都是对美的反叛，因而是崎形的。</li><li>虽说匀称的形态都是美，然而如果那形态可以流动，我们就可以求得一种更为卓越的动态美。平衡的打破促使人们渴求着恢复，并且观察着它重获平衡的每一个步骤。这就是流水的魅力， 海浪的魅力，鸟儿的魅力和动物的魅力。</li><li>舞蹈的理论，就是在不断的变化中凭借着灵活的动作——而不是凭借着碎的和生硬的动作——去恢复失去的平衡。</li><li>用最简单的语言说明最伟大的道理，这正是美的最高境界。</li><li>美是恒古不变的，越是美，它也就越是保留的长久。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无论如何要认识到你自己，要认识到你所经历的生活，这通常具有重大的价值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="摘录" scheme="http://wittyfans.com/tags/%E6%91%98%E5%BD%95/"/>
    
      <category term="读书笔记" scheme="http://wittyfans.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>玩转PowerShell</title>
    <link href="http://wittyfans.com/coding/%E7%8E%A9%E8%BD%ACPowerShell.html"/>
    <id>http://wittyfans.com/coding/玩转PowerShell.html</id>
    <published>2017-11-14T15:14:08.000Z</published>
    <updated>2018-03-15T14:39:30.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Power shell 作为一门windows平台下的脚本语言，对于系统管理员来说，可以极大的减少我们的工作，作为一流的系统管理员（逃～），不可不学！</p></blockquote><a id="more"></a> <h1 id="Why-Power-Shell"><a href="#Why-Power-Shell" class="headerlink" title="Why Power Shell"></a>Why Power Shell</h1><ul><li>Working in windows</li><li>Support Object </li><li>.NET Support</li><li>Power ! ! ! </li></ul><h1 id="Over-View"><a href="#Over-View" class="headerlink" title="Over View"></a>Over View</h1><p>Power shell 作为一门windows平台下的脚本语言，可以极大的减少我们的工作，它的好处自然不用多说，用过的都知道，下面简单的看一下语法概览。</p><ul><li>查命令的使用：Get-Help</li><li>查对象的方法和属性:Get-Member</li><li><p>查命令历史记录:Get-History</p><ul><li>命令导出为ps1 : xxx | Foreach-Object {$_.CommandLine} &gt; C:\temp\script.ps1</li></ul></li><li><p>查找命令:Get-Command</p></li><li>上一条命令是否成功:$lastExitCode</li><li>一个命令要多久: Measure-Command{ scripts}</li></ul><h3 id="where-object"><a href="#where-object" class="headerlink" title="where-object"></a>where-object</h3><p>使用这个命令可以从列表或者输出中过滤信息，格式为where-object{  } ,where-object回遍历它之前的属性，在{}中，可以使用$_来代表当前遍历的元素，所以，在where-object中，可以进行大量的操作。</p><h3 id="Foreach-Object"><a href="#Foreach-Object" class="headerlink" title="Foreach-Object"></a>Foreach-Object</h3><p>这个命令和where-object差不多，可以用来处理列表中的项，同样可以在其中使用$_命令</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>Get-Content 可以读取csv或者txt文件，读取完成之后可以通过数组的形式访问.</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>使用重定向符和out-file命令的不同，重定向符&gt;&gt;可以达到强大的控制，out-file可以轻松处理内容的宽度和编码方式，而且重定向输出的文本是按照命令行窗口的宽度来定的。</li></ul><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="数据导出到CSV文件"><a href="#数据导出到CSV文件" class="headerlink" title="数据导出到CSV文件"></a>数据导出到CSV文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Output info to CSV file</span></span><br><span class="line"><span class="variable">$data</span> = @()</span><br><span class="line"><span class="variable">$row</span> = <span class="built_in">New-Object</span> PSObject</span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"Username"</span> -Value <span class="variable">$username</span></span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"ComputerName"</span> -Value <span class="variable">$ComputerName</span></span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"Domain"</span> -Value <span class="variable">$domainName</span></span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"monitorSN"</span> -Value <span class="variable">$monitorSN</span></span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"ComputerSN"</span> -Value <span class="variable">$info</span>.SerialNumber</span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"LastTimeLoginUser"</span> -Value <span class="variable">$loginInfo</span>.Name</span><br><span class="line"><span class="variable">$row</span> | <span class="built_in">Add-Member</span> -MemberType NoteProperty -Name <span class="string">"LoginCounts"</span> -Value <span class="variable">$loginInfo</span>.count</span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> += <span class="variable">$row</span></span><br><span class="line"><span class="variable">$data</span> | <span class="built_in">Export-CSV</span> \\<span class="number">10.65</span>.<span class="number">64.219</span>\soft\Information\infoList.csv -noTypeInformation -Append</span><br></pre></td></tr></table></figure><h2 id="PowerShell与excel文件交互"><a href="#PowerShell与excel文件交互" class="headerlink" title="PowerShell与excel文件交互"></a>PowerShell与excel文件交互</h2><ul><li><a href="http://www.lazywinadmin.com/2014/03/powershell-read-excel-file-using-com.html?m=1" target="_blank" rel="noopener">Read an Excel file using COM Interface</a></li></ul><h1 id="PowerSheel-学习资源"><a href="#PowerSheel-学习资源" class="headerlink" title="PowerSheel 学习资源"></a>PowerSheel 学习资源</h1><ul><li><a href="http://www.pstips.net" target="_blank" rel="noopener">PSTips</a></li><li><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/powershell-scripting?view=powershell-5.1" target="_blank" rel="noopener">微软PowerSheel官方文档</a></li></ul><h1 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h1><ul><li>《Windows PowerShell 应用手册》——Lee Holmes著</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Power shell 作为一门windows平台下的脚本语言，对于系统管理员来说，可以极大的减少我们的工作，作为一流的系统管理员（逃～），不可不学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="Windows" scheme="http://wittyfans.com/tags/Windows/"/>
    
      <category term="HelpDesk" scheme="http://wittyfans.com/tags/HelpDesk/"/>
    
      <category term="技术支持" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    
      <category term="PowerShell" scheme="http://wittyfans.com/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>爱默生谈读书</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E8%B0%88%E8%AF%BB%E4%B9%A6.html"/>
    <id>http://wittyfans.com/reading/爱默生谈读书.html</id>
    <published>2017-11-10T14:15:51.000Z</published>
    <updated>2018-03-15T14:40:32.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。</p></blockquote><a id="more"></a><h1 id="读书的必要"><a href="#读书的必要" class="headerlink" title="读书的必要"></a>读书的必要</h1><ul><li>一本好书足以如良药般医治人们思想上的疾病，令人信服、思想进步</li><li>和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。</li><li>没有读过相关方面的著作，就没有资格在这方面发表什么言论。<!--more--></li></ul><h1 id="读书的原则"><a href="#读书的原则" class="headerlink" title="读书的原则"></a>读书的原则</h1><h2 id="顺其自然"><a href="#顺其自然" class="headerlink" title="顺其自然"></a>顺其自然</h2><p>顺其自然的重要性就在于，学生可以根据自己的兴趣来读，满足自己的求知欲，而不是机械地翻来翻去，强迫自己浪费时间</p><h2 id="兴趣优先"><a href="#兴趣优先" class="headerlink" title="兴趣优先"></a>兴趣优先</h2><p>要读适合自己的书，不要在质量不佳的庸书上浪费精力，例如哈菲兹是波斯人中的天才、孔子是中国的圣人、塞万提斯是法国人心中的智者</p><h2 id="精心挑选"><a href="#精心挑选" class="headerlink" title="精心挑选"></a>精心挑选</h2><p>远离浅薄无益的书，回避新闻界面中那些琐碎的闲谈和小道消息，优秀的名著中从头到尾都是深刻精辟的思想和生动翔实的例证，最好的环境中肯定有最好的信息。</p><h1 id="读书法则"><a href="#读书法则" class="headerlink" title="读书法则"></a>读书法则</h1><ul><li>不读当年出版的书</li><li>不读名不见经传的书</li><li>不读自己并不喜欢的书</li></ul><h1 id="作者推荐"><a href="#作者推荐" class="headerlink" title="作者推荐"></a>作者推荐</h1><ul><li>荷马</li><li>罗多德</li><li>埃斯切拉斯</li><li>柏拉图</li></ul><h1 id="书籍推荐（爱默生）"><a href="#书籍推荐（爱默生）" class="headerlink" title="书籍推荐（爱默生）"></a>书籍推荐（爱默生）</h1><ul><li>范都</li><li>普罗塔高勒斯</li><li>范德拉斯</li><li>理想国</li><li>苏格拉底对话录</li><li>普卢塔克</li><li>吉本《自传》《日记摘录》《读书摘要》</li></ul><hr><p>关于书籍推荐，个人推荐之前的博文《如何阅读一本书》结尾附送的青年必读书手册。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;和平凡的人在一起，你就会相信生活就是这样平平淡淡、普普通通，同样的，阅读希腊历史学家普鲁塔克的书，你便会觉得这个世界是个令人骄傲的地方，到处都是善良的人们。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="学习" scheme="http://wittyfans.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="读书" scheme="http://wittyfans.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>爱默生谈财富</title>
    <link href="http://wittyfans.com/reading/%E7%88%B1%E9%BB%98%E7%94%9F%E8%B0%88%E8%B4%A2%E5%AF%8C.html"/>
    <id>http://wittyfans.com/reading/爱默生谈财富.html</id>
    <published>2017-11-09T05:25:10.000Z</published>
    <updated>2018-03-15T14:43:05.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>财富的秘诀在于对自己拥有的事物的使用</p></blockquote><a id="more"></a><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>财富的秘诀在于对自己拥有的事物的使用</li><li>辛勤劳作是必须的，也是安身立命的基础</li><li>更重要的是精心计划、果断行动</li><li>看准某种趋势，可能一夜暴富</li><li>经济问题与人的道德紧密相关，直接决定一个人是否能独立自处</li><li>如果暴富会损坏一个人的道德，那么贫穷也会使人堕落。</li><li>对一个百万富翁来说，他会恪守诺言，讲究信誉，但对一个一贫如洗的人，你很难指望他的道德良知。<!--more--> </li><li>如果这样的人希望拥有健康的生活和完整的人格，他必须自己压制自己的欲望，自行决定自己的命运，按照社会的准则行事，一切只能控制在自己力所能及的范围之内。</li><li>真正的男子汉，是那些勇于拼搏的人，一切都尽力而为，也能够做到量力而行</li><li>坚贞不屈，勇往直前的人是自傲的，他也完全有资格自傲，他知道他的拼搏会得到回报，每个人在这个时候都会重拾生活的信心，别人只能敬佩有加</li><li>现在有一种通病，似乎个人的财富是社交界的通行证，似乎财富是一个人的面具，对于理性的人来说，财富是一种手段，而不是目的，它应该为我们服务，让我们更有实力。</li><li>一个理想主义者，只想着自己的设想，要求别人也这么做的时候，他就变得十分霸道，必然引起别人的反感。</li><li>对于有修养的人来说，财富具有感染力，可以让人更优雅，就像音乐一样，对于有鉴赏力的人来说，音乐的魅力是无穷的。</li><li>商业的艺术或者说经营的艺术很微妙，不是人人都可以投身其中的，一个注重实际的人只相信自己的亲身经历和亲眼所见。</li><li>实际的人只相信利润、游戏规则，不是把赚钱建立在运气上。</li><li>生意人的品格是诚实和务实，应该实事求是的看待收益和风险。</li><li>金钱可以看出一个人的风格与本性，随着人们才能和道德的进步，金钱的价值也将不断增加，在教育上增加一块钱，总比在罪犯上花一块钱管用</li></ul><h1 id="个人理财的建议"><a href="#个人理财的建议" class="headerlink" title="个人理财的建议"></a>个人理财的建议</h1><ol><li>我们应该量入而出，根据自己的赚钱能力来决定消费的多少，如果有足够的能力挣钱，投资也能稳赚不赔，那么即使有一些大手大脚也无所谓，做事情要保证质量也要保证速度，不能马虎了事，花钱要注重创造价值，该花花，该省省，我们不应该只关注表面现象，而应该用理性思维看待一切。节俭应当得到社会的尊重，谦虚是一种美得，但过分的谦卑只会让人难受，这样的情况下适度骄傲反而是一种好的品质，凭借自己的劳动生活的人与周围的人谈心也不卑不亢，而爱慕虚荣的人则艰难的多。</li><li>我们应该有一个系统的财经计划，根据自己的才能花钱。生活中单靠节俭和节制是解决不了任何问题的，但即使收入巨大也不能没有节制，成功理财的关键不是财富的多少，多节俭，而是摆正收入和支出的关系，协调好两者的比例。生活的实践是不断变化的，每一个行当都需要一个大师的任务去把握这种规律</li><li>必须在实践中小心为之，而不可随意执行自己拟定的计划。万物有他的规律，你不懂种地植树，时令懂；你不懂建筑造房，自有人懂，听从他们即可，我们只需要观察和倾听就好了，自行其是只会收到大自然的惩罚。自然，每个家庭都有适合自己的生活方式，如果丈夫在某本书中了解到一种新的生活方式想实行一下，好吧，让他试试看，准会以失败而告终。</li><li>我们不要异想天开，以为会有什么奇迹发生，而应该尽力获取自己熟悉的东西。对商人来说，诸如“最好的花钱方式是及时还债”、“生意是做出来的”，“时间就是金钱”、“机不可失”、“正确的投资是最好的赚钱方式”，等等口号，并不能反映深刻的道理，这都需要宽泛的解释，才能作为生活的准则。</li></ol><hr><p>真正的理财不单单是节俭，而是满足生活需要后，进行不断的投资，进一步创造财富，并不只是花在物质享受，而是花在精神满足和思想创造上，通过自身力量的增强，感受到成长和成熟的快乐，体验到那样的生命的活力和愉悦，这样我们才不只是一个守财奴。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;财富的秘诀在于对自己拥有的事物的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="爱默生" scheme="http://wittyfans.com/tags/%E7%88%B1%E9%BB%98%E7%94%9F/"/>
    
      <category term="生活" scheme="http://wittyfans.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="理财" scheme="http://wittyfans.com/tags/%E7%90%86%E8%B4%A2/"/>
    
      <category term="财富" scheme="http://wittyfans.com/tags/%E8%B4%A2%E5%AF%8C/"/>
    
  </entry>
  
  <entry>
    <title>Angualar使用笔记</title>
    <link href="http://wittyfans.com/coding/Angualar%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/coding/Angualar使用笔记.html</id>
    <published>2017-08-25T15:11:50.000Z</published>
    <updated>2018-03-15T14:45:54.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一套框架，多种平台</p></blockquote><a id="more"></a> <p>Angular学习笔记</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="我们需要什么样的开发环境？"><a href="#我们需要什么样的开发环境？" class="headerlink" title="我们需要什么样的开发环境？"></a>我们需要什么样的开发环境？</h2><ul><li>代码编辑</li><li>断点调试</li><li>版本管理</li><li>代码合并和混淆</li><li>依赖管理</li><li>单元测试</li><li>集成测试</li></ul><h2 id="常用工具介绍"><a href="#常用工具介绍" class="headerlink" title="常用工具介绍"></a>常用工具介绍</h2><ul><li>代码编辑<ul><li>Sublime</li><li>Webstom</li></ul></li><li>断点调试<ul><li>Chrom+Batarang浏览器插件</li></ul></li><li>版本管理<ul><li>Git</li><li>Tortoisegit</li></ul></li><li>代码合并和混淆<ul><li>Node.js+npm</li><li>Grunt</li></ul></li><li>依赖管理<ul><li>Bower(少用)</li><li>Http-server<ul><li>模拟测试数据</li></ul></li></ul></li><li>单元测试<ul><li>Karma（仅仅是容器）</li><li>Jasmine（编写测试用例工具）</li><li>Protractor（专为angularJS定制）</li></ul></li></ul><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC只是手段，终极目标是模块化和复用<br>Angular 的MVS全部借助于$scope实现，即利用作用域实现</p><h2 id="前端MVC的困难"><a href="#前端MVC的困难" class="headerlink" title="前端MVC的困难"></a>前端MVC的困难</h2><ul><li>操作DOM必须等待整个页面加载完成</li><li>多个js文件如果互相依赖，必须程序员自己解决</li><li>jd的原型继承也给前端编程带来很多困难</li></ul><h2 id="AngularJS中的Controller"><a href="#AngularJS中的Controller" class="headerlink" title="AngularJS中的Controller"></a>AngularJS中的Controller</h2><h3 id="Controller的实现方式"><a href="#Controller的实现方式" class="headerlink" title="Controller的实现方式"></a>Controller的实现方式</h3><ul><li>同一个数据模型，一个控制器控制多个视图<ul><li>如果多个视图之间没有关系，控制器的角色就很尴尬</li><li>控制器变成大杂烩</li><li>适合小项目</li></ul></li><li>同一个数据模型，每个视图对应一个视图<ul><li>两个控制器里的方法一样怎么办？利用继承通用控制器的方法可以解决但是这样不推荐（</li><li>利用Servers</li></ul></li></ul><h3 id="HTML中的代码"><a href="#HTML中的代码" class="headerlink" title="HTML中的代码"></a>HTML中的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div ng-controller = &quot;HelloAngular&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&#123;% raw %&#125;&#123;&#123; greeting.text &#125;&#125; &#123;% endraw %&#125;,Angular&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">//通过指令ng-controller= 实现控制器</span><br></pre></td></tr></table></figure><h3 id="Controller使用注意点"><a href="#Controller使用注意点" class="headerlink" title="Controller使用注意点"></a>Controller使用注意点</h3><ul><li>不要试图去复用Controller，一个控制器只负责一个小视图</li><li>不要再Controlller操作Dom，这不是控制器的职责</li><li>不要在Controller中做数据格式化，ng有很好的表单控件</li><li>不要再controller中做数据过滤操作，ng有$filter服务</li><li>controller是不需要互相调用的，一般会通过事件</li></ul><h2 id="AngularJS中的Model"><a href="#AngularJS中的Model" class="headerlink" title="AngularJS中的Model"></a>AngularJS中的Model</h2><p>Model大致运行过程</p><ul><li>AngularJS代码加载，完成后去寻找ng-app</li><li>ng-app所在标签内部的所有内容就归它所管</li><li>寻找所有属于ng的指令，进行编译操作</li><li>找到ng-model后生成数据模型，并给它取名为””中的值,挂载在Root Scope上，给所有子标签使用</li></ul><h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ul><li>不需要手动创建model</li><li>使用的时候利用$scope取值就好</li></ul><h2 id="AngularJS中的View"><a href="#AngularJS中的View" class="headerlink" title="AngularJS中的View"></a>AngularJS中的View</h2><h3 id="AngularJS和MVC都基于-Scope"><a href="#AngularJS和MVC都基于-Scope" class="headerlink" title="AngularJS和MVC都基于$Scope"></a>AngularJS和MVC都基于$Scope</h3><ul><li>$Scope是一个Polo</li><li>$Scope提供了一些工具方法</li><li>$Scope是表达式的执行环境</li><li>$Scope是一个树形结构，与DOM标签平行</li><li>$Scope对象会继承父$Scope上的属性和方法</li><li>每一个Angular应用只有一个根$Scope对象，一般位于ng-app</li><li>$Scope可以传播事件，类似DOM事件，可以向上也可以向下</li><li>$Scope不仅是MVC的基础，也是后面实现双向数据绑定的基础</li><li>可以用Angular.element($0).scope()进行调试</li></ul><h3 id="Scope的生命周期"><a href="#Scope的生命周期" class="headerlink" title="$Scope的生命周期"></a>$Scope的生命周期</h3><p>Creation（创建）-&gt;Watcher registration（观察监测）-&gt;Model mutation(模型变化)-&gt;Mutation observation（模型脏了？）-&gt;Scope destruction(销毁)</p><h3 id="模块化与依赖注入"><a href="#模块化与依赖注入" class="headerlink" title="模块化与依赖注入"></a>模块化与依赖注入</h3><p>AngularJS的模块化实现<br>把一个函数定义到全局空间，会污染全局空间,最好的方式是利用angular.module定义modle,再在model中定义控制器。模块是什么？模块是集合，集合了控制器，视图，过滤器，等等</p><h3 id="一个完整的项目结构是什么样的"><a href="#一个完整的项目结构是什么样的" class="headerlink" title="一个完整的项目结构是什么样的"></a>一个完整的项目结构是什么样的</h3><ul><li>app</li><li>css</li><li>JS</li><li>app.js <ul><li>controllers.js</li><li>drictives.js</li><li>filters.js</li><li>services.js</li></ul></li><li>Imgs</li><li>tpls（模版）<ul><li>index.html</li></ul></li><li>node-modules</li><li>framework（bootstrap等UI控件）</li><li>package.json</li></ul><h3 id="使用ngRoute进行视图之间的路由"><a href="#使用ngRoute进行视图之间的路由" class="headerlink" title="使用ngRoute进行视图之间的路由"></a>使用ngRoute进行视图之间的路由</h3><pre><code>应用规模很大，不可能只有一个View，这些View需要切换，AngularJS是根据URL来切换的，它有一个工具叫routeProvider。一切都是从模块开始的。如果控制器太多，需要把控制器分类成不同功能的模块，分给不同的开发者开发，利用grunt进行代码合并</code></pre><p>模块之间的依应该怎么做？–依赖注入，app.js作为入口，肯定需要依赖其他的模块,例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var book = angular.module(&apos;module1&apos;,&apos;module2&apos;)</span><br></pre></td></tr></table></figure></p><h1 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;% raw %&#125;&#123;&#123; greeting.text &#125;&#125; &#123;% endraw %&#125; ,Angular&lt;/p&gt;</span><br></pre></td></tr></table></figure>{{  }} ,数据绑定，分单双向 ,问题：会因为刷新、网络的问题，在网页中显示代码<br><br>## 取值表达式与ng-bind指令<br>解决方案：使用ng-bind，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span ng-bind=&quot;greeting.text&quot;&gt;&lt;/span&gt;,Angular&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="双向数据绑定典型场景——表单"><a href="#双向数据绑定典型场景——表单" class="headerlink" title="双向数据绑定典型场景——表单"></a>双向数据绑定典型场景——表单</h3><p>建立、html中、应用场景之更改css文件</p><h3 id="动态切换标签样式"><a href="#动态切换标签样式" class="headerlink" title="动态切换标签样式"></a>动态切换标签样式</h3><p>ng-show和ng-hide、ng-class，ng-clas可以接受表达式，例如在修改CSS样式的例子中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-class = &apos;&#123;error:isError, warning:isWarning&#125;&apos;&gt;&#123;% raw %&#125;&#123;&#123; messageText &#125;&#125; &#123;% endraw %&#125; &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>意思是，如果isError的值为True，则会用eror的样式ngAnimate</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令的运行机制。</p><ol><li>加载、加载angular.js，找到ng-app，确定应用边界</li><li>编译、遍历DOM，找到所有指令、根据指令代码中的template、replace、transclue转换dom结构、如果存在compile函数则调用</li><li>链接、对每一条指令运行link函数、link函数一般用来操作dom、绑定事件监听器</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>指令的形式，指令的外部为<name></name>,即它的使用形式</li><li>声明与定义，指令声明于控制器当中，控制器存在于模块当中，控制器需要在<div>中声明，在js文件中定义，指令也一样</div></li><li>指令的定义方式为，在定义控制器之后，使用控制器的directive方法定义,形式如下：</li></ol><p>1). 定义模块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var module = angular.module(&quot;module&quot;,[]);</span><br></pre></td></tr></table></figure></p><p>2). 定义控制器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.controller(&apos;myctrl&apos;,[&apos;$scope&apos;,function($scope)&#123;</span><br><span class="line">$scope.loadData = function()&#123;</span><br><span class="line">//code</span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p><p>3). 定义指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;</span><br><span class="line">link:function(scope,element,attr,*)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="使用与绑定事件"><a href="#使用与绑定事件" class="headerlink" title="使用与绑定事件"></a>使用与绑定事件</h2><p>link可用来绑定该指令的鼠标事件，该函数共有4个参数</p><ul><li>scope</li><li>element</li><li>attr</li><li>*(后面再介绍)</li></ul><h3 id="如何绑定鼠标事件？在link中"><a href="#如何绑定鼠标事件？在link中" class="headerlink" title="如何绑定鼠标事件？在link中"></a>如何绑定鼠标事件？在link中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.bind(&apos;event&apos;,function()&#123;</span><br><span class="line">scope.loadData();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope.$apply(&quot;loadData()&quot;);</span><br></pre></td></tr></table></figure><h3 id="指令要在另一个控制器中使用呢"><a href="#指令要在另一个控制器中使用呢" class="headerlink" title="指令要在另一个控制器中使用呢"></a>指令要在另一个控制器中使用呢</h3><p>定义另一个控制器,给指令定义属性，比如加载指令loader定义howtoload属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;</span><br><span class="line">link:function(scope,element,attr,*)&#123;</span><br><span class="line"></span><br><span class="line">scope.$apply(attr.howtoload());//必须小写</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="指令内部的分工"><a href="#指令内部的分工" class="headerlink" title="指令内部的分工"></a>指令内部的分工</h3><p>link中处理指令内部事件，绑定数据.etc,如果想要指令暴露出一些方法给外部用，那就写在控制器中require,表示依赖关系，.</p><h3 id="独立scope"><a href="#独立scope" class="headerlink" title="独立scope"></a>独立scope</h3><p> 效果：让数据与视图的数据独立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> module.directive(&apos;name&apos;,function()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">restrict:&apos;AE&apos;,</span><br><span class="line">scope:&#123;&#125;,</span><br><span class="line">link:function(scope,element,attr,*)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="scope绑定策略"><a href="#scope绑定策略" class="headerlink" title="scope绑定策略"></a>scope绑定策略</h3><ul><li>@，以字符串的形式绑定</li><li>=，与父scope中的属性进行双向绑定</li><li>&amp;，传递一个来自父scope的函数，稍后调用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一套框架，多种平台&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="web" scheme="http://wittyfans.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离商城开发记录</title>
    <link href="http://wittyfans.com/coding/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95.html"/>
    <id>http://wittyfans.com/coding/前后端分离商城开发记录.html</id>
    <published>2017-08-16T12:09:31.000Z</published>
    <updated>2018-03-15T14:44:23.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个前后端完全分离的商城，把系统分为逻辑层、数据层、工具层三大层级，具有不错的可扩展性和可维护性，同时进行模块化拆分，通过组件的拼装达到业务的实现，提高开发效率。</p></blockquote><a id="more"></a> <h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>NodeJS（4.4.7）</li><li>Git</li><li>npm</li><li>Sublime</li><li>Chrome</li><li>Charles</li></ul><h1 id="Sublime技巧"><a href="#Sublime技巧" class="headerlink" title="Sublime技巧"></a>Sublime技巧</h1><h2 id="Sublime快捷键"><a href="#Sublime快捷键" class="headerlink" title="Sublime快捷键"></a>Sublime快捷键</h2><ul><li>cmd+shift+d 复制行</li><li>cmd+shift+k 删除行</li><li>cmd+； 注释</li><li>cmd+d 查找并选择</li><li>Ctrl + J：把当前选中区域合并为一行</li><li>Ctrl + M：在起始括号和结尾括号间切换</li><li>Ctrl + Shift + M：快速选择括号间的内容</li><li>Ctrl + Shift + J：快速选择同缩进的内容</li><li>Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容</li></ul><h2 id="Sublime插件"><a href="#Sublime插件" class="headerlink" title="Sublime插件"></a>Sublime插件</h2><p>command+shift+p sublime安装插件</p><ul><li>fileheader 文件头部添加时间，作者说明，快捷键comand+option+a</li></ul><h1 id="常用终端命令"><a href="#常用终端命令" class="headerlink" title="常用终端命令"></a>常用终端命令</h1><ul><li>ls -al 查看所有文件</li><li>rm -rf name 删除文件夹</li></ul><h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><pre><code>- git config —global user.name “name” - git config -global user.email “email”</code></pre><ul><li>查看ssh:cd~/.ssh</li><li>生成ssh key： ssh-keygen -t rsa -C “emakl”,回车</li><li>名称：id_rsa 私钥、id_rsa.pub公钥</li><li>复制id_rsa.pub,去git配置</li></ul><h2 id="本地目录关联远程目录"><a href="#本地目录关联远程目录" class="headerlink" title="本地目录关联远程目录"></a>本地目录关联远程目录</h2><ul><li>初始化：git init </li><li>对应当前文件夹与远程仓库:git remote add origin url</li><li>pull代码：git pull origin master</li><li>检查状态：git status</li><li>添加到缓存区：git add.</li><li>提交全部并添加注释:git commit -am “”</li></ul><h2 id="ignore配置"><a href="#ignore配置" class="headerlink" title="ignore配置"></a>ignore配置</h2><ul><li>新建ignore文件： vim .ignore</li><li>直接加入文件名，例如:.DS_Store、/node_modules/、/dist/</li></ul><h2 id="分之开发"><a href="#分之开发" class="headerlink" title="分之开发"></a>分之开发</h2><ul><li>git checkout -b branch-name，新建并切换到branch-name分之</li><li>git branch：查看现在的分支</li></ul><h2 id="克隆历史版本的git代码"><a href="#克隆历史版本的git代码" class="headerlink" title="克隆历史版本的git代码"></a>克隆历史版本的git代码</h2><p>在分之中，切换成历史分之即可</p><h1 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h1><h2 id="src原始文件"><a href="#src原始文件" class="headerlink" title="src原始文件"></a>src原始文件</h2><ul><li>逻辑层：page+view（页面，脚本与样式）</li><li>数据层：service</li><li>工具层：util</li><li>图片：image</li></ul><h2 id="Dist打包文件"><a href="#Dist打包文件" class="headerlink" title="Dist打包文件"></a>Dist打包文件</h2><ul><li>View</li><li>JS</li><li>Css</li><li>resource</li></ul><h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><ul><li>npm init：初始化</li><li>npm install <a href="mailto:xxx@v.v.v" target="_blank" rel="noopener">xxx@v.v.v</a> 安装依赖包</li><li>npm uninstall <a href="mailto:xxx@v.v.v" target="_blank" rel="noopener">xxx@v.v.v</a> 卸载依赖包</li><li>-g ：全局安装</li><li><ul><li>-registry = <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> ：使用国内淘宝源</li></ul></li></ul><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="安装与参考"><a href="#安装与参考" class="headerlink" title="安装与参考"></a>安装与参考</h2><ul><li>npm install webpack -g ：全局安装</li><li>npm install <a href="mailto:webpack@v.v.v" target="_blank" rel="noopener">webpack@v.v.v</a> –save-dev ： 项目中安装<ul><li>–save-dev，会把信息记录到packge.json中，不会打包到业务</li><li>–save，会打包到业务代码中</li></ul></li><li>webpack -v ：查看版本号</li></ul><h2 id="webpack-config-js-配置文件"><a href="#webpack-config-js-配置文件" class="headerlink" title="webpack.config.js 配置文件"></a>webpack.config.js 配置文件</h2><ul><li>etry：入口文件，源文件中js的路径</li><li>externals：外部依赖的声明，一些外部的内容可以用它来转化成commonJs和可引用的模块,比如jquery</li><li>output：目标文件</li><li>resolve：配置别名</li><li>module：各种文件、各种loader</li><li>plugins：加载webpack的插件</li></ul><h2 id="webpack-Loaders"><a href="#webpack-Loaders" class="headerlink" title="webpack Loaders"></a>webpack Loaders</h2><ul><li>html：html-webpack-plugin/html-loader</li><li>js:babel-loader+babel-preset-es2015</li><li>css:stle-loader+css-loader</li><li>image+font:url-loader</li></ul><h2 id="webpack对html模版的处理"><a href="#webpack对html模版的处理" class="headerlink" title="webpack对html模版的处理"></a>webpack对html模版的处理</h2><ol><li>对引入的CSS文件，需要加上版本号</li><li>html文件src文件中，并不在dist文件夹中如何处理？如果直接把html文件放到dist文件夹中，会面临dist删除的情况导致html文件丢失</li><li>方案：src中的html打包到dist（html-webpack-plugin）</li><li>每个页面的html都需要new一个plugin，这样很占用资源，可以定义一个函数来处理</li></ol><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>前端服务器，文件改变的时候，自动刷新浏览器</p><ul><li>安装：npm install webpack-dev-server –save-dev</li><li>配置：wepack-dev-server/client?http//localhost:8088</li><li>使用: wepack-dev-server —port 8088 –inline,inline 的意思是把server的client直接用脚本的方式插入页面</li></ul><h2 id="webpack常用命令"><a href="#webpack常用命令" class="headerlink" title="webpack常用命令"></a>webpack常用命令</h2><ul><li>webpack A B 把A打包到B（单文件打包）</li><li>webpack -p 最小化压缩的打包，发布的时候用</li><li>webpack –watch 监听文件的改变自动编译</li></ul><h2 id="安装Loader"><a href="#安装Loader" class="headerlink" title="安装Loader"></a>安装Loader</h2><h2 id="使用Plugin"><a href="#使用Plugin" class="headerlink" title="使用Plugin"></a>使用Plugin</h2><h2 id="对脚本和样式的处理"><a href="#对脚本和样式的处理" class="headerlink" title="对脚本和样式的处理"></a>对脚本和样式的处理</h2><h3 id="处理JS"><a href="#处理JS" class="headerlink" title="处理JS"></a>处理JS</h3><ul><li>JS用什么加载？ ：选用自带的js加载器</li><li><p>entry只有一个js，多个js文件怎么办？：entry变成对象，键值对（’’：[‘’]）来指定不同的js文件，注意多个entry需要指定多个output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry : &#123;</span><br><span class="line">&apos;index&apos;:[&apos;./src/page/index/index.js&apos;],</span><br><span class="line">&apos;login&apos;:[&apos;./src/page/login/login&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>output要分文件夹存放目标文件，怎么设置输出文件？：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output : &#123;</span><br><span class="line">path:&apos;./dist&apos;,</span><br><span class="line">filename: [name].js</span><br><span class="line">&#125;</span><br><span class="line">//[name]会使用源文件的名字</span><br><span class="line">//filename支持路径，如果改成js/[name].js,会建立js文件夹</span><br></pre></td></tr></table></figure></li><li><p>jquery引入方法？1.在页面中直接用脚本引入，<a href="http://www.bootcdn.cn" target="_blank" rel="noopener">特定版本</a>获取网址,2.模块化引入,在webpack config文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals : &#123;</span><br><span class="line">&apos;jquery&apos; : &apos;window.jQuery&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我想提取公共模块，怎么处理？使用<a href="">CommonsChunkPlugin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在plugins里new一个对象，在参数(对象)中配置如何提取公共模块</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">plugins : [</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">name : &apos;common&apos;,</span><br><span class="line">filename : &apos;js/base.js &apos;//</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>输出name的名字,路径前缀为output中的path</li><li>只有commons中的通用文件才会抽离到base.js中</li><li>在entry中也定义一个common入口，当webpack.optimize.CommonsChunkPlugin中的name也为commom的时候，common.js中引用的js文件中的通用部分就会打包进base.js</li></ul></li></ul><h3 id="处理CSS"><a href="#处理CSS" class="headerlink" title="处理CSS"></a>处理CSS</h3><ul><li>用什么loader加载？<br>style-loader!css-loader,执行顺序是由右往左，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module : &#123;</span><br><span class="line">loaders : [</span><br><span class="line">&#123;test:/\.css$/,loader:&quot;style-loader!css-loader&quot;&#125;</span><br><span class="line">//探测到以css结尾的文件，就使用style-loader!css-loader</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>使用之前，需要先安装：</p><pre><code>- npm install style-loader css-loader --save-dev </code></pre><ul><li>webpack把样式打包成了js模块，但我需要单独的css文件，不想在js运行完了才开始加载？<br>需要用到webpack css单独打包的插件，即<a href="">extrct-text-webpack-plugin</a>，<br>然后在webpack的配置文件中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ExtractTextPlugin = require (&quot;extract-text-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">//配置插件</span><br><span class="line">plugins: &#123;</span><br><span class="line">new ExtractTextPlugin(&quot;css/[name].css&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//注意Loader也需要配置</span><br><span class="line">module: &#123;</span><br><span class="line">loaders: [</span><br><span class="line">&#123; test:/\.css$/,loader:ExtractTextPlugin(&quot;css/[name].css&quot;) &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="对HTML的处理"><a href="#对HTML的处理" class="headerlink" title="对HTML的处理"></a>对HTML的处理</h2><h3 id="html-wepack-plugin"><a href="#html-wepack-plugin" class="headerlink" title="html-wepack-plugin"></a>html-wepack-plugin</h3><p>使用的方式和CSS插件一致，例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require (&quot;html-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">//配置HTML模版</span><br><span class="line">plugins: &#123;</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">template: &apos;./src/view/&apos; + name + &apos;.html&apos;,</span><br><span class="line">        filename: &apos;view/&apos; + name + &apos;.html&apos;,</span><br><span class="line">        title: title,</span><br><span class="line">        inject: true,</span><br><span class="line">        hash: true,</span><br><span class="line">        chunks: [&apos;common&apos;, name]</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>template:html原始的页面模版</li><li>filename：目标文件的位置，以output的path作为父目录</li><li>inject：注入方式，自动注入js和css</li><li>hash：会在引入的css、js文件加hash版本号</li><li>chunks：需要打包的模块</li></ul><hr><p>To be continued </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个前后端完全分离的商城，把系统分为逻辑层、数据层、工具层三大层级，具有不错的可扩展性和可维护性，同时进行模块化拆分，通过组件的拼装达到业务的实现，提高开发效率。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="编程" scheme="http://wittyfans.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="实战" scheme="http://wittyfans.com/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SASS学习记录</title>
    <link href="http://wittyfans.com/coding/SASS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
    <id>http://wittyfans.com/coding/SASS学习记录.html</id>
    <published>2017-07-20T07:24:05.000Z</published>
    <updated>2018-03-15T14:44:39.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SASS算是对CSS的优化，想想我们写CSS的经历，每次访问嵌套结构比较深的元素，都要写很多重复的代码，SASS对CSS增加了类似编程语言中的变量、<strike>函数</strike>混合宏、流程控制、继承等功能，让CSS的使用效率大大提升，让你的代码更容易复用，编写效率更高。</p></blockquote><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>我的系统是Mac OS，系统已经安装了Ruby（SASS依赖Ruby环境），如果你使用的是 Windows， 就需要先安装 Ruby。可以参考<a href="http://sass.bootcss.com/docs/sass-reference/#han-shu" target="_blank" rel="noopener">SASS中文网</a>。你可以检查一下自己的系统是否预装了Ruby，打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p><p>即可。之后，我们需要利用Ruby的包管理工具gem来下载SASS，使用之前，同样可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem -v</span><br></pre></td></tr></table></figure></p><p>来检查是否拥有gem。如果检测都成功，会显示相应的version版本号。随后就很简单了，一段代码搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install sass</span><br></pre></td></tr></table></figure></p><h1 id="SASS代码转化成CSS"><a href="#SASS代码转化成CSS" class="headerlink" title="SASS代码转化成CSS"></a>SASS代码转化成CSS</h1><p>安装完成后，我们就可以编写SASS代码了，但编写SASS代码，最终还是要转化成CSS的，我们可以让系统自动监视（watch）我们的文件。一旦有改动，就马上转换成CSS文件，这样我们只要在html中正确引用了CSS文件，就可以实时看到效果。（实时的效果可能需要用到<a href="https://www.npmjs.com/package/live-server" target="_blank" rel="noopener">LiveServer</a>）<br>如何监视呢，一条代码就可以了，在终端进入你的项目css文件所在文件夹,创建后缀名为scss的文件，以你的scss文件名为style为例,终端中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass — —watch style.scss:style.css</span><br></pre></td></tr></table></figure></p><p>style.scss为监视的对象，style.css为输出对象，html代码中需要引用css文件。监视成功后，SASS在当前文件夹中会创建一些必要的文件，以后每次改动，终端都会有记录。</p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p>SASS可以给CSS中的任何数值定义为变量，比如颜色、宽度、百分值等等。SASS使用$作为变量的前缀,以下定义了一个名为blue的颜色值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$blue:#708c87;</span><br></pre></td></tr></table></figure></p><p>也可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$cream:#F2EFEB;</span><br><span class="line">$pmargin:5%;</span><br><span class="line">$ppadding:20px;</span><br><span class="line">$hpadding:20px;</span><br></pre></td></tr></table></figure></p><h1 id="嵌套处理"><a href="#嵌套处理" class="headerlink" title="嵌套处理"></a>嵌套处理</h1><p>CSS中，为了要取得一个元素，你需要这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body a b c</span><br></pre></td></tr></table></figure></p><p>如果你的子元素非常多，会让你的代码看起来毫无层级结构，如果是SASS代码，那么看起来会是这样子的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: #262626; font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">    </span><br><span class="line">h1 &#123;</span><br><span class="line">        </span><br><span class="line">        color:$cream;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding-top: $hpadding;</span><br><span class="line">    &#125;</span><br><span class="line">p &#123;</span><br><span class="line">        margin: 20px $pmargin ;</span><br><span class="line">        padding: $ppadding $ppadding $ppadding $ppadding;</span><br><span class="line">        background-color: $cream;</span><br><span class="line">        color:$blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>html中是什么样的层级结构，你就可以在SASS中用什么样的层级结构去写，是不是一部了然？</p><h1 id="函数混合宏"><a href="#函数混合宏" class="headerlink" title="函数混合宏"></a><strike>函数</strike>混合宏</h1><p>如果你有一个固定的样式需要经常用到怎么办？在SASS中，你可以定义一个<strike>函数</strike>混合宏，然后在需要更改样式的地方，在相应的层级关系中插入这个<strike>函数</strike>混合宏就可以了，这样就可以做到一次定义，多次复用了，看如下的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin border-radius($radius: 20px)&#123;</span><br><span class="line">    border:2px solid;</span><br><span class="line">    border-radius:$radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个border-radius<strike>函数</strike>混合宏，@mixin是定义<strike>函数</strike>混合宏的关键字，相当于JS中的function,$radius:20px的意思是这个<strike>函数</strike>混合宏期待传入一个radius值，如果没有传入，它就会使用默认值20px.这个<strike>函数</strike>混合宏的意思是，让调用的环境拥有一个圆角效果。<br>好了，<strike>函数</strike>混合宏定义好了，如何使用呢？我们还是以上面的代码为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: #262626; font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">    h1 &#123;    </span><br><span class="line">        color:$cream;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding-top: $hpadding;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">        margin: 20px $pmargin ;</span><br><span class="line">        padding: $ppadding $ppadding $ppadding $ppadding;</span><br><span class="line">        background-color: $cream;</span><br><span class="line">        @include border-radius(10px);</span><br><span class="line">        color:$blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strike>函数</strike>混合宏使用的时候，只需要在<strike>函数</strike>混合宏名之前使用关键字@include、把相应的值传入即可。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承同样很简单，在需要被应用的元素中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@extend element；</span><br></pre></td></tr></table></figure></p><p>即可，element是要被应用的元素，继承后，该元素的样式会跟被继承的元素一样。继承的同时也可以给元素应用新的样式,在后面加入新的样式即可。</p><h1 id="导入其他文件"><a href="#导入其他文件" class="headerlink" title="导入其他文件"></a>导入其他文件</h1><p>有时候为了让项目文件更有条理，我们会把一些CSS文件分离开，但有时候又需要用到，这时候可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import</span><br></pre></td></tr></table></figure></p><p>导入其他的文件。所有引入的 SCSS 和 Sass 文件都会被<em>合并并输出一个单一的 CSS 文件**。 另外，被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。</em>但是如果你有一个 SCSS 或 Sass 文件<strong>需要引入， 但是你又不希望它被编译</strong>为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><p>*例如，你有一个文件叫做 _colors.scss。 这样就不会生成 _colors.css 文件了， 而且你还可以这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;colors&quot;;</span><br></pre></td></tr></table></figure></p><p>,来引入 _colors.scss 文件。</p><h1 id="父级引用"><a href="#父级引用" class="headerlink" title="父级引用"></a>父级引用</h1><p>有时候在我们的语句中，需要引用当前的环境，比如当你在<a>标签当中，你想要设置它的hover效果，你可能没办法直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hover&#123;…&#125;</span><br></pre></td></tr></table></figure></a></p><p>这样设置，但你可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，&amp;即代表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;</span><br></pre></td></tr></table></figure></p><p>&amp; 在编译时将被替换为父选择符，输出到 CSS 中。 也就是说，如果你有一个深层嵌套的规则，父选择符也会在 &amp; 被替换之前被完整的解析。</p><h1 id="使用List和-each"><a href="#使用List和-each" class="headerlink" title="使用List和@each"></a>使用List和@each</h1><p>假设有这个一个情况，你需要在网页中显示一组社交网络的图片，比如微信、微博、QQ之类的，那么在SASS下，如何写会比较省事呢？其实就是一个for循环就搞定了，List相当于一个容器，each相当于for循环，看例子：</p><p><strong>html代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class = &quot;social-links&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;weibo&quot; href=&quot;#&quot;&gt;weibo&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;wechat&quot; href=&quot;#&quot;&gt;wechat&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a class = &quot;qq&quot; href=&quot;#&quot;&gt;qq&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><strong>SASS代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义List</span><br><span class="line">$icons:&#123;weibo,wechat,qq&#125;;</span><br><span class="line"></span><br><span class="line">//循环赋值</span><br><span class="line">@each $social in $icons &#123;</span><br><span class="line">.#&#123;$social&#125; &#123;background:url(&apos;../img/#&#123;soicial&#125;.png&apos;)no-repeat;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$social 为新创建的对象，每次循环，它的值都会为icons这个List中的一个新值</li><li>在CSS语句后面写变量，通常需要加{},例如.#{$social},这段后面的花括号则是设置CSS的背景图片</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SASS算是对CSS的优化，想想我们写CSS的经历，每次访问嵌套结构比较深的元素，都要写很多重复的代码，SASS对CSS增加了类似编程语言中的变量、&lt;strike&gt;函数&lt;/strike&gt;混合宏、流程控制、继承等功能，让CSS的使用效率大大提升，让你的代码更容易复用，编写效率更高。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://wittyfans.com/tags/CSS/"/>
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://wittyfans.com/coding/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://wittyfans.com/coding/Linux常用命令.html</id>
    <published>2017-07-13T12:24:21.000Z</published>
    <updated>2018-03-15T14:45:19.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux常用参考手册，定期更新～</p></blockquote><a id="more"></a><h1 id="服务器连接与配置"><a href="#服务器连接与配置" class="headerlink" title="服务器连接与配置"></a>服务器连接与配置</h1><h2 id="修改alias（别名），简化命令操作"><a href="#修改alias（别名），简化命令操作" class="headerlink" title="修改alias（别名），简化命令操作"></a>修改alias（别名），简化命令操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">alias testhost=&apos;ssh root@8.8.8.8 -p 22&apos;</span><br></pre></td></tr></table></figure><h2 id="修改ssh配置，简化ssh命令"><a href="#修改ssh配置，简化ssh命令" class="headerlink" title="修改ssh配置，简化ssh命令"></a>修改ssh配置，简化ssh命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.ssh/config</span><br><span class="line">#输入：</span><br><span class="line"></span><br><span class="line">Host testhost</span><br><span class="line">  HostName 8.8.8.8</span><br><span class="line">  Port 2222</span><br><span class="line">  User foo</span><br><span class="line"></span><br><span class="line">#保存后，可使用 ssh testhost 登陆服务器</span><br></pre></td></tr></table></figure><h2 id="Mac使用秘钥无密码登陆"><a href="#Mac使用秘钥无密码登陆" class="headerlink" title="Mac使用秘钥无密码登陆"></a>Mac使用秘钥无密码登陆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#生成本地秘钥，一路回车即可</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">#上传生成的秘钥到服务器</span><br><span class="line">scp ~/.ssh/id_rsa.pub testhost:~/.ssh/</span><br><span class="line">#使用以下命令将 id_rsa.pub 更名为 authorized_keys</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br><span class="line">#修改权限</span><br><span class="line">chmod 700 ~/.ssh/</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><ul><li>df -hl ：查看硬盘使用情况，以M显示</li><li>free -m :查看内存使用情况</li><li>top 查看CPU的使用情况</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.laozuo.org/1345.html" target="_blank" rel="noopener">硬盘</a></li><li><a href="http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html" target="_blank" rel="noopener">内存</a></li><li><a href="http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html" target="_blank" rel="noopener">CPU</a></li></ul><hr><p>持续更新</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux常用参考手册，定期更新～&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux之scp命令使用</title>
    <link href="http://wittyfans.com/coding/Linux%E4%B9%8Bscp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>http://wittyfans.com/coding/Linux之scp命令的使用.html</id>
    <published>2017-07-13T12:19:50.000Z</published>
    <updated>2018-03-15T14:35:35.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。</p></blockquote><a id="more"></a><h1 id="使用SCP命令在远程VPS和本地之间进行文件传输"><a href="#使用SCP命令在远程VPS和本地之间进行文件传输" class="headerlink" title="使用SCP命令在远程VPS和本地之间进行文件传输"></a>使用SCP命令在远程VPS和本地之间进行文件传输</h1><p>假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。</p><h2 id="1-什么是scp"><a href="#1-什么是scp" class="headerlink" title="1 什么是scp"></a>1 什么是scp</h2><p>scp就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证。scp在需要进行验证时会要求你输入密码或口令。</p><h2 id="2-实际操作"><a href="#2-实际操作" class="headerlink" title="2 实际操作"></a>2 实际操作</h2><p>2.1 下载VPS的文件(目录)到本地</p><p>假设需要将VPS上的一个文件下载到本地，文件路径是/root/test.log，VPS的IP地址是12.34.56.78，VPS的账户名是root，SSH端口是6666，我们将这个文件下载到本地的/Users/admin/root/test.log，那么我们需要执行的scp命令是</p><p>scp －P 6666 <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root/test.log /Users/admin/root/test.log<br>scp支持对整个目录进行操作，例如将上述root目录下载到本地</p><p>scp －P 6666 <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root /Users/admin/root<br>执行scp命令后需要输入VPS上对应账户的密码</p><p>2.2 上传本地的文件(目录)到VPS</p><p>假设需要将本地的一个文件上传到VPS，本地文件的路径是/Users/admin/root/test.log，VPS的IP地址是12.34.56.78，VPS的账户名是root，SSH端口是6666，我们将这个文件上传到VPS的/root/test.log，那么我们需要执行的scp命令是</p><p>scp -r －P 6666 /Users/admin/root/test.log <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root/test.log<br>同理，也能上传整个目录</p><p>scp -r －P 6666 /Users/admin/root <a href="mailto:root@12.34.56.78" target="_blank" rel="noopener">root@12.34.56.78</a>:/root</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://celerysoft.github.io/2016-07-07.html" target="_blank" rel="noopener">月下之光 - 攸溟</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;假设你的VPS的功能很单纯，没有Nginx或者Web Server，那么要如何在VPS和本地之间、或者两台VPS之间进行文件传输呢？答案就是scp命令。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
  </entry>
  
  <entry>
    <title>Screen指南</title>
    <link href="http://wittyfans.com/coding/Screen%E6%8C%87%E5%8D%97.html"/>
    <id>http://wittyfans.com/coding/Screen指南.html</id>
    <published>2017-07-13T12:18:32.000Z</published>
    <updated>2018-03-15T14:45:44.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p></blockquote><a id="more"></a><h1 id="Screen指南"><a href="#Screen指南" class="headerlink" title="Screen指南"></a>Screen指南</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在screen中创建一个新的窗口有这样几种方式：<br>1．直接在命令行键入screen命令<br>[root@tivf06 ~]# screen<br>Screen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。<br>2．Screen命令后跟你要执行的程序。<br>[root@tivf06 ~]# screen vi test.c<br>Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。<br>3．以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入C-a c，即Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。<br>screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/abc文件：<br>[root@tivf06 ~]# screen vi /tmp/abc<br>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，Screen会给出detached提示：</p><p>半个小时之后回来了，找到该screen会话：<br>[root@tivf06 ~]# screen -ls<br>There is a screen on:<br>        16582.pts-1.tivf06      (Detached)<br>1 Socket in /tmp/screens/S-root.<br>重新连接会话：<br>[root@tivf06 ~]# screen -r 16582<br>看看出现什么了，太棒了，一切都在。继续干吧。</p><p>你可能注意到给screen发送命令使用了特殊的键组合C-a。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。<br>可以通过C-a ?来查看所有的键绑定，常用的键绑定有：</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>C-a ?    显示所有键绑定信息</li><li>C-a w    显示所有窗口列表</li><li>C-a C-a    切换到之前显示的窗口</li><li>C-a c    创建一个新的运行shell的窗口并切换到该窗口</li><li>C-a n    切换到下一个窗口</li><li>C-a p    切换到前一个窗口(与C-a n相对)</li><li>C-a 0..9    切换到窗口0..9</li><li>C-a a    发送 C-a到当前窗口</li><li>C-a d    暂时断开screen会话</li><li>C-a k    杀掉当前窗口</li><li>C-a [    进入拷贝/回滚模式</li><li>其他常用的命令选项有：<br>-c file    使用配置文件file，而不使用默认的$HOME/.screenrc<br>-d|-D [pid.tty.host]    不开启新的screen会话，而是断开其他正在运行的screen会话<br>-h num    指定历史回滚缓冲区大小为num行<br>-list|-ls    列出现有screen会话，格式为pid.tty.host<br>-d -m    启动一个开始就处于断开模式的会话<br>-r sessionowner/ [pid.tty.host]    重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限<br>-S sessionname    创建screen会话时为会话指定一个名字<br>-v    显示screen版本信息<br>-wipe [match]    同-list，但删掉那些无法连接的会话</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>在终端中</strong></p><ul><li>screen -S name :新建名字为name的screen窗口</li><li>screen -ls : 查看所有后台窗口</li><li>screen -r name -&gt; 回到name这个session<br><strong>Screen中</strong></li><li>C-a k :杀掉当前screen</li><li>C-a d :暂时断开screen的连接</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">IBM</a></li><li><a href="http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html" target="_blank" rel="noopener">David Camp - CNBlog</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>主机名由localhost变成bogon的解决办法</title>
    <link href="http://wittyfans.com/coding/%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%94%B1localhost%E5%8F%98%E6%88%90bogon%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"/>
    <id>http://wittyfans.com/coding/主机名由localhost变成bogon的解决办法.html</id>
    <published>2017-07-13T12:15:34.000Z</published>
    <updated>2018-03-15T14:46:09.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如题。</p></blockquote><a id="more"></a><h1 id="主机名由localhost变成bogon的解决办法"><a href="#主机名由localhost变成bogon的解决办法" class="headerlink" title="主机名由localhost变成bogon的解决办法"></a>主机名由localhost变成bogon的解决办法</h1><ul><li>修改你的 DNS 为公共 DNS，例如 114.114.114.114 或者谷歌的 8.8.8.8（我切换DNS便解决了问题）</li><li>编辑主机名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo hostname your-desired-host-name</span><br><span class="line"></span><br><span class="line">sudo scutil --set LocalHostName $(hostname)</span><br><span class="line"></span><br><span class="line">sudo scutil --set HostName $(hostname)</span><br></pre></td></tr></table></figure></li></ul><h1 id="为什么会出现这个问题"><a href="#为什么会出现这个问题" class="headerlink" title="为什么会出现这个问题"></a>为什么会出现这个问题</h1><p>终端在初始化时，需要确定主机的名字，此时终端会向 DNS 服务器反向查询本机 IP 地址，然后把得到的名字作为自己的主机名。如果没有反向解析的结果，就会显示本机设置的主机名。那么 bogon 是什么意思呢？一个 DNS 反向解析名为 bogon 的 IP 地址不会显示在 traceroute 中。我猜题主可能在一个路由器组织的局域网环境中，并且你的 DNS 地址是你路由器的地址，这样终端反向查询你本机 IP 地址得到的结果是 bogon，于是你在终端里显示的主机名就变成了 bogon。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.zhihu.com/question/25849047" target="_blank" rel="noopener">知乎</a></li><li><a href="https://air20.com/archives/486.html" target="_blank" rel="noopener">Air20</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="系统" scheme="http://wittyfans.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="http://wittyfans.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://wittyfans.com/coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://wittyfans.com/coding/正则表达式学习.html</id>
    <published>2017-07-13T12:11:09.000Z</published>
    <updated>2018-03-15T14:46:24.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式学习与快速参考</p></blockquote><a id="more"></a><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><ul><li>.    匹配除换行符以外的任意字符</li><li>\w    匹配字母或数字或下划线或汉字</li><li>\s    匹配任意的空白符</li><li>\d    匹配数字</li><li>\b    匹配单词的开始或结束</li><li>^    匹配字符串的开始</li><li>$    匹配字符串的结束</li></ul><h1 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h1><p>使用\来取消元字符特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。</p><h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><ul><li>重复零次或更多次</li><li>重复一次或更多次</li><li>?    重复零次或一次</li><li>{n}    重复n次</li><li>{n,}    重复n次或更多次</li><li>{n,m}    重复n到m次</li></ul><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>用括号括起来指定子表达式，然后还可以指定分组的重复次数、进行其他的操作。例如如下的ip地址的例子<br>(\d{1,3}.){3}\d{1,3}</p><p><strong>下面是一些使用重复的例子：</strong></p><ul><li>Windows\d+匹配Windows后面跟1个或更多数字</li><li>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</li></ul><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p>用来指定一个范围，比如像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><h1 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h1><p>其实就是“或”的意思，如果满足了语句|两边任意一个条件，都会进行匹配</p><h1 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h1><p>通常是把字母变成大写，也有用中括号括起来的时候</p><ul><li>\W    匹配任意不是字母，数字，下划线，汉字的字符</li><li>\S    匹配任意不是空白符的字符</li><li>\D    匹配任意非数字的字符</li><li>\B    匹配不是单词开头或结束的位置</li><li>[^x]    匹配除了x以外的任意字符</li><li>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</li></ul><h1 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h1><p>用小括号指定的子表达式，匹配了这个表达式的文本，可以在另一个语句中进一步处理。<br>系统会对表达式中的语句进行分组，通常是按照单个子表达式分割线\或者小括号来分组，分组用数字来表示，也可以给指定分组起名字。</p><ul><li>可以用\加数字的方式引用分组，\0表示整个表达式，\1表示第一个，以此类推；</li><li>指定表达式的组名的语法:(?&lt;名字&gt;表达式)或者(?’名字’表达式)</li></ul><h1 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h1><p>断言的意思其实就是位置，关于位置，我们前面学过一些比如\b，^,$，他们通常都代表着文本中的某个位置，零宽断言也类似。<br>共有四种零宽断言</p><h1 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h1><p>如果在一个文本中，符合条件的匹配有很多，即会有一定数量的重复，那么匹配任务的原则会分两种情况</p><ol><li>尽可能匹配多的文本，比如atbtttttttb中匹配atbtttttttb</li><li>尽可能匹配少的文本,比如atbtttttttb中匹配atb</li></ol><ul><li>*?    重复任意次，但尽可能少重复</li><li>+?    重复1次或更多次，但尽可能少重复</li><li>??    重复0次或1次，但尽可能少重复</li><li>{n,m}?    重复n到m次，但尽可能少重复</li><li>{n,}?    重复n次以上，但尽可能少重复</li></ul><h1 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h1><ul><li>\    将下一个字符标记为一个特殊字符(File Format Escape)、或一个原义字符（Identity Escape)、或一个向后引用(backreferences)、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</li><li>^    匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</li><li>$    匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</li><li>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</li><li>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</li><li>?    匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</li><li>{n}    n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</li><li>{n,}    n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</li><li>{n,m}    m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</li><li>?    非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</li><li>.    匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。</li><li>(pattern)    匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</li><li>(?:pattern)    匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</li><li>(?=pattern)    正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</li><li>(?!pattern)    正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</li><li>(?&lt;=pattern)    反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</li><li>(?&lt;!pattern)    反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</li><li>x|y    匹配x或y。例如，“z|food”能匹配“z”或“food”。“(?:z|f)ood”则匹配“zood”或“food”。</li><li>[xyz]    字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</li><li>[^xyz]    排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</li><li>[a-z]    字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</li><li>[^a-z]    排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</li><li>[:name:]    增加命名字符类（named character class）[注 1]中的字符到表达式。只能用于方括号表达式。</li><li>[=elt=]    增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用于方括号表达式。</li><li>[.elt.]    增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语， “CH”作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。</li><li>\b    匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</li><li>\B    匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</li><li>\cx    匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</li><li>\d    匹配一个数字字符。等价于[0-9]。</li><li>\D    匹配一个非数字字符。等价于[^0-9]。</li><li>\f    匹配一个换页符。等价于\x0c和\cL。</li><li>\n    匹配一个换行符。等价于\x0a和\cJ。</li><li>\r    匹配一个回车符。等价于\x0d和\cM。</li><li>\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</li><li>\S    匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</li><li>\t    匹配一个制表符。等价于\x09和\cI。</li><li>\v    匹配一个垂直制表符。等价于\x0b和\cK。</li><li>\w    匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</li><li>\W    匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</li><li>\ck    匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法。</li><li>\xnn    十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.</li><li>\num    向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符。</li><li>\n    标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</li><li>\nm    3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</li><li>\nml    如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</li><li>\un    Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/正则表达式" target="_blank" rel="noopener">正则表达式WIKI</a></li><li><a href="https://deerchao.net/tutorials/regex/regex.htm#repeat" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正则表达式学习与快速参考&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="正则" scheme="http://wittyfans.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>2017前端学习路线与资料</title>
    <link href="http://wittyfans.com/coding/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%862017%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99.html"/>
    <id>http://wittyfans.com/coding/个人整理2017前端学习路线与资料.html</id>
    <published>2017-06-07T09:42:23.000Z</published>
    <updated>2018-03-15T14:32:00.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习路漫漫，得找对方向。</p></blockquote><a id="more"></a><h1 id="概览OverView"><a href="#概览OverView" class="headerlink" title="概览OverView"></a>概览OverView</h1><p>国外大神整理的Web开发路线图，共四张图覆盖了不同的方向。<br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/1.PNG" alt="2017 Web Learning map1"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/3.PNG" alt="2017 Web Learning map2"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/4.PNG" alt="2017 Web Learning map3"><br><img src="https://raw.githubusercontent.com/wittyfans/source/master/webLearn/5.PNG" alt="2017 Web Learning map4"></p><h1 id="资源Resource"><a href="#资源Resource" class="headerlink" title="资源Resource"></a>资源Resource</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰Git教程</a></li></ul><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><a href="https://www.youtube.com/watch?v=DbPDraCYju8" target="_blank" rel="noopener">SSH Tutorial - Basic server administration with SSH</a></p><ul><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用</a></li></ul><h2 id="HTML-CSS-JS"><a href="#HTML-CSS-JS" class="headerlink" title="HTML/CSS/JS"></a>HTML/CSS/JS</h2><ul><li><a href="http://w3school.com.cn" target="_blank" rel="noopener">W3C</a></li><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">廖雪峰JavaScript</a></li></ul><h3 id="CSS-FrameWork"><a href="#CSS-FrameWork" class="headerlink" title="CSS FrameWork"></a>CSS FrameWork</h3><ul><li><a href="http://v3.bootcss.com" target="_blank" rel="noopener">BootStrap</a><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2></li><li><a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">ES6</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习路漫漫，得找对方向。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="个人提高" scheme="http://wittyfans.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="技术" scheme="http://wittyfans.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="学习" scheme="http://wittyfans.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Web" scheme="http://wittyfans.com/tags/Web/"/>
    
      <category term="Learning" scheme="http://wittyfans.com/tags/Learning/"/>
    
      <category term="Improve yourself" scheme="http://wittyfans.com/tags/Improve-yourself/"/>
    
  </entry>
  
  <entry>
    <title>产品经理的数字工具们 👨🏻‍💻</title>
    <link href="http://wittyfans.com/coding/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E6%95%B0%E5%AD%97%E5%B7%A5%E5%85%B7%E4%BB%AC.html"/>
    <id>http://wittyfans.com/coding/产品经理的数字工具们.html</id>
    <published>2017-05-28T02:04:49.000Z</published>
    <updated>2018-03-15T14:46:32.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>干货大放送。</p></blockquote><a id="more"></a><h1 id="第一部分：日常创作-灵感收集-思维导图"><a href="#第一部分：日常创作-灵感收集-思维导图" class="headerlink" title="第一部分：日常创作+灵感收集+思维导图"></a>第一部分：日常创作+灵感收集+思维导图</h1><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">https://daringfireball.net/projects/markdown/</a></li><li>Markdown 语法说明（简体中文版）</li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></li><li>献给写作者的 Markdown 新手指南 - 简书</li><li><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">http://www.jianshu.com/p/q81RER</a></li></ul><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><ul><li>Bear (macOS / iOS)</li><li><a href="http://www.bear-writer.com/" target="_blank" rel="noopener">http://www.bear-writer.com/</a></li><li>Ulysses (macOS / iOS)</li><li><a href="https://www.ulyssesapp.com/" target="_blank" rel="noopener">https://www.ulyssesapp.com/</a></li><li>Day One (macOS / iOS)</li><li><a href="http://dayoneapp.com/" target="_blank" rel="noopener">http://dayoneapp.com/</a></li><li>Mou (macOS)</li><li><a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></li><li>MarkdownPad (Windows)</li><li><a href="http://markdownpad.com/" target="_blank" rel="noopener">http://markdownpad.com/</a></li><li>为知笔记（macOS / Windows / Linux / iOS / Android）</li><li><a href="http://www.wiz.cn/" target="_blank" rel="noopener">http://www.wiz.cn/</a></li></ul><h3 id="使用-Markdown-来写博客："><a href="#使用-Markdown-来写博客：" class="headerlink" title="使用 Markdown 来写博客："></a>使用 Markdown 来写博客：</h3><ul><li>Jekyll</li><li><a href="https://jekyllrb.com/" target="_blank" rel="noopener">https://jekyllrb.com/</a></li><li>Hexo</li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li><li>GitHub Pages</li><li><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></li><li>Coding Pages</li><li><a href="https://coding.net/help/doc/pages/" target="_blank" rel="noopener">https://coding.net/help/doc/pages/</a></li></ul><h3 id="一些好用的-Markdown-插件或周边产品："><a href="#一些好用的-Markdown-插件或周边产品：" class="headerlink" title="一些好用的 Markdown 插件或周边产品："></a>一些好用的 Markdown 插件或周边产品：</h3><p>专为印象笔记（Evernote）打造的 Markdown 编辑器：马克飞象<br><a href="https://maxiang.io/" target="_blank" rel="noopener">https://maxiang.io/</a><br>在浏览器上使用随处可用的 Markdown 插件：Markdown Here (Chrome)<br><a href="http://markdown-here.com/" target="_blank" rel="noopener">http://markdown-here.com/</a><br>基于 Markdown 的高颜值的微信公众号图文消息排版工具<br><a href="https://github.com/ufologist/wechat-mp-article" target="_blank" rel="noopener">https://github.com/ufologist/wechat-mp-article</a></p><h1 id="第二部分：原型设计-交互设计-需求文档"><a href="#第二部分：原型设计-交互设计-需求文档" class="headerlink" title="第二部分：原型设计+交互设计+需求文档"></a>第二部分：原型设计+交互设计+需求文档</h1><h2 id="抛弃-Axure-RP-的解决方案："><a href="#抛弃-Axure-RP-的解决方案：" class="headerlink" title="抛弃 Axure RP 的解决方案："></a>抛弃 Axure RP 的解决方案：</h2><ul><li>原型设计：Sketch</li><li>动效设计：Keynote / Flinto</li><li>需求文档：GitBook / GitHub Wiki / Dropbox Paper</li></ul><h2 id="用-Sketch-进行原型设计的一些资源："><a href="#用-Sketch-进行原型设计的一些资源：" class="headerlink" title="用 Sketch 进行原型设计的一些资源："></a>用 Sketch 进行原型设计的一些资源：</h2><ul><li>Sketch App Resources</li><li><a href="https://www.sketchappsources.com/category/wireframe.html" target="_blank" rel="noopener">https://www.sketchappsources.com/category/wireframe.html</a></li><li>Beforweb 的 iOS WireframeKit for Sketch（付费）</li><li><a href="http://mp.weixin.qq.com/s/ZdBcHzWDU4hP7uMgXlUkSw" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/ZdBcHzWDU4hP7uMgXlUkSw</a></li></ul><h2 id="动效设计："><a href="#动效设计：" class="headerlink" title="动效设计："></a>动效设计：</h2><ul><li>Keynote (macOS / iOS / iCloud)</li><li><a href="https://www.apple.com/keynote/" target="_blank" rel="noopener">https://www.apple.com/keynote/</a></li><li>Flinto (macOS)</li><li><a href="https://www.flinto.com/" target="_blank" rel="noopener">https://www.flinto.com/</a></li></ul><h2 id="小众神器GitBook"><a href="#小众神器GitBook" class="headerlink" title="小众神器GitBook"></a>小众神器GitBook</h2><ul><li><a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a></li><li><a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">https://github.com/GitbookIO/gitbook</a></li><li>GitHub Wiki</li><li><a href="https://help.github.com/articles/about-github-wikis/" target="_blank" rel="noopener">https://help.github.com/articles/about-github-wikis/</a></li><li>案例<ul><li><a href="https://nodejs.xiangfa.org/" target="_blank" rel="noopener">Node.js API 中文文档</a></li><li><a href="https://mubu.com/asset/html/book/" target="_blank" rel="noopener">幕布用户使用手册</a></li><li><a href="https://doctorkowj.gitbooks.io/kppolicy/" target="_blank" rel="noopener">柯 P 新政 · 市政白皮书 by 柯文哲</a></li></ul></li></ul><h2 id="小众神器推荐：Dropbox-Paper"><a href="#小众神器推荐：Dropbox-Paper" class="headerlink" title="小众神器推荐：Dropbox Paper"></a>小众神器推荐：Dropbox Paper</h2><ul><li><a href="https://www.dropbox.com/paper" target="_blank" rel="noopener">Dropbox Paper</a></li></ul><h2 id="小众神器推荐：Lingo"><a href="#小众神器推荐：Lingo" class="headerlink" title="小众神器推荐：Lingo"></a>小众神器推荐：Lingo</h2><ul><li><p><a href="https://www.lingoapp.com/" target="_blank" rel="noopener">Lingo</a></p><h3 id="使用-Lingo-必备的图标库："><a href="#使用-Lingo-必备的图标库：" class="headerlink" title="使用 Lingo 必备的图标库："></a>使用 Lingo 必备的图标库：</h3></li><li><p><a href="https://material.io/icons/" target="_blank" rel="noopener">Material Icons by Google</a></p></li><li><a href="https://www.lingoapp.com/store/resource/material_icons/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/material_icons/</a></li><li><a href="https://thenounproject.com/" target="_blank" rel="noopener">Noun Project</a></li><li><a href="https://www.lingoapp.com/store/resource/nounproject/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/nounproject/</a></li><li><a href="https://github.com/twitter/twemoji" target="_blank" rel="noopener">Twemoji</a></li><li><a href="https://www.lingoapp.com/store/resource/twemoji/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/twemoji/</a></li><li><a href="http://facebook.design/devices.html" target="_blank" rel="noopener">Facebook Devices</a></li><li><a href="https://www.lingoapp.com/store/resource/devices/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/devices/</a></li><li><a href="https://www.mapbox.com/maki-icons/" target="_blank" rel="noopener">Maki Map Icons by Mapbox</a></li><li><a href="https://www.lingoapp.com/store/resource/maki_map_icons/" target="_blank" rel="noopener">https://www.lingoapp.com/store/resource/maki_map_icons/</a></li></ul><h3 id="Noun-Project-网页版"><a href="#Noun-Project-网页版" class="headerlink" title="Noun Project 网页版"></a>Noun Project 网页版</h3><p><a href="https://thenounproject.com/" target="_blank" rel="noopener">https://thenounproject.com/</a><br>Noun Project App (macOS / Windows)<br><a href="https://thenounproject.com/for-mac/" target="_blank" rel="noopener">https://thenounproject.com/for-mac/</a><br><a href="https://thenounproject.com/for-windows/" target="_blank" rel="noopener">https://thenounproject.com/for-windows/</a><br>Icons8 网页版<br><a href="https://icons8.com/" target="_blank" rel="noopener">https://icons8.com/</a><br><a href="https://icons8.com/web-app/new-icons/all" target="_blank" rel="noopener">https://icons8.com/web-app/new-icons/all</a><br>Icons8 App (macOS / Windows)<br><a href="https://icons8.com/app" target="_blank" rel="noopener">https://icons8.com/app</a><br>Nucleo<br><a href="https://nucleoapp.com/" target="_blank" rel="noopener">https://nucleoapp.com/</a></p><h3 id="其他支持搜索的在线图标库："><a href="#其他支持搜索的在线图标库：" class="headerlink" title="其他支持搜索的在线图标库："></a>其他支持搜索的在线图标库：</h3><p>阿里巴巴矢量图标库<br><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a><br>Iconfinder<br><a href="https://www.iconfinder.com/" target="_blank" rel="noopener">https://www.iconfinder.com/</a><br>Easyicon<br><a href="http://www.easyicon.net/" target="_blank" rel="noopener">http://www.easyicon.net/</a></p><h1 id="第三部分：需求管理-团队沟通-协奏平台"><a href="#第三部分：需求管理-团队沟通-协奏平台" class="headerlink" title="第三部分：需求管理+团队沟通+协奏平台"></a>第三部分：需求管理+团队沟通+协奏平台</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Teambition (Web / macOS / Windows / iOS / Android)</li><li><a href="https://www.teambition.com/" target="_blank" rel="noopener">https://www.teambition.com/</a></li><li>Worktile (Web / macOS / Windows / iOS / Android)</li><li><a href="https://worktile.com/" target="_blank" rel="noopener">https://worktile.com/</a></li><li>伙伴云表格 (Web)</li><li><a href="https://www.huoban.com/" target="_blank" rel="noopener">https://www.huoban.com/</a><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2></li><li>Slack (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://slack.com/" target="_blank" rel="noopener">https://slack.com/</a></li><li>倍洽 BearyChat (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://bearychat.com/" target="_blank" rel="noopener">https://bearychat.com/</a></li><li>简聊 (Web / macOS / Windows / Linux / iOS / Android)</li><li><a href="https://jianliao.com/" target="_blank" rel="noopener">https://jianliao.com/</a></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li>《The New Methodology》- Martin Fowler</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;干货大放送。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="个人提高" scheme="http://wittyfans.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
      <category term="互联网" scheme="http://wittyfans.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>产品经理的五种工具 🔨</title>
    <link href="http://wittyfans.com/coding/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B7%A5%E5%85%B7.html"/>
    <id>http://wittyfans.com/coding/产品经理的五种工具.html</id>
    <published>2017-05-27T15:33:12.000Z</published>
    <updated>2018-03-15T14:33:07.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知乎Live《产品汪的五种武器：记录、实现、架构、数据、整理》记录。</p></blockquote><a id="more"></a><h1 id="使用纸记录"><a href="#使用纸记录" class="headerlink" title="使用纸记录"></a>使用纸记录</h1><ul><li><p>为何记录</p><ul><li>没有记录，就没有改进的目标</li><li>没有总结，就没有认真思考</li></ul></li><li><p>为何选择这个载体</p><ul><li>选择手写的：Read it later = Read it Never</li><li>选择昂贵的：减少喜新厌旧</li><li>安排日程思考离开手机</li><li>大事记</li></ul></li><li><p>重点</p><ul><li>定期温故知新、翻看以前的笔记</li></ul></li><li><p>资料</p><ul><li><a href="https://sspai.com/post/39340" target="_blank" rel="noopener">子弹笔记</a></li></ul></li></ul><h1 id="快速实现"><a href="#快速实现" class="headerlink" title="快速实现"></a>快速实现</h1><ul><li><p>用速写本之前，应该用什么</p><ul><li>我在给谁设计，迭代、仔细找出目标客户</li><li>行业利益如何流动，行业谁有钱、谁没钱、谁为什么找你</li><li>平台规范是什么，苹果、Google，微信</li></ul></li><li><p>用软件的弊端</p><ul><li>容易分心，被字体、排版、输入法等分心</li></ul></li><li><p>使用便利贴与速写本</p><ul><li>便利贴做整个生命周期的场景</li><li>每个界面的大致形态</li></ul></li></ul><h1 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h1><ul><li><p>类型</p><ul><li>树形结构，例如墨迹天气</li><li>网状结构，例如知乎</li><li>线性结构，</li><li>混合结构</li></ul></li><li><p>工具</p><ul><li>利用OmniGraffle画架构图</li></ul></li></ul><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><ul><li><p>要点</p><ul><li>每个人都需要学一点SQL</li><li>Excel足够完成80%的基础分析</li><li>洞悉数据之前，先洞悉业务和用户，否则用户会被任意解读</li><li>注意样品偏差，当你分析数据的时候，是不是有比较偏差</li></ul></li><li><p>相关资料</p><ul><li><a href="http://www.stats.gov.cn/tjsj/ndsj/2016/indexch.htm" target="_blank" rel="noopener">1</a></li><li><a href="http://data.worldbank.org.cn/" target="_blank" rel="noopener">2</a></li><li><a href="https://www.statista.com/" target="_blank" rel="noopener">3</a></li></ul></li><li><p>例：Sublime与Excel的简单数据分析</p><ul><li>数据分类：分析豆瓣图书有多少数据、进行分类</li><li>数据获取：Curl抓去豆瓣图书的评分、数量、分类</li><li>数据处理：Sbulime的暴力处理法</li><li>做出预期：实用性工具书、OR理论工具书</li><li>数据处理：Excel数据透视表</li><li>数据解读：和预期一致、并从中总结用户的看法</li></ul></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li>《Web信息架构》</li><li>《成功，目标与动机》</li><li>《精要主义》</li><li>《随意搜寻》</li><li>《信息架构：超越Web设计》</li><li>《精益数据分析》</li><li>《统计数字会说谎》</li><li>《正念禅修》</li><li>《This is service design thinking》</li><li>《iOS human interface guidelines》</li><li>《Material design guidelines》</li><li><a href="https://www.douban.com/doulist/1346840/" target="_blank" rel="noopener">更多完整书单</a></li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="刘老师，我是2-5年的电商pm。在数据方面接触的比较少，请问如何入门数据这块（或者渠道），以便方便公司产品的迭代或运营有更准确的支撑？"><a href="#刘老师，我是2-5年的电商pm。在数据方面接触的比较少，请问如何入门数据这块（或者渠道），以便方便公司产品的迭代或运营有更准确的支撑？" class="headerlink" title="刘老师，我是2.5年的电商pm。在数据方面接触的比较少，请问如何入门数据这块（或者渠道），以便方便公司产品的迭代或运营有更准确的支撑？"></a>刘老师，我是2.5年的电商pm。在数据方面接触的比较少，请问如何入门数据这块（或者渠道），以便方便公司产品的迭代或运营有更准确的支撑？</h2><p>推荐看一本书《精益数据分析》会有一个比较全局的概念</p><h2 id="请问少楠老师，对于一个全新的行业，做为一个PM，应该首先从何入手呢"><a href="#请问少楠老师，对于一个全新的行业，做为一个PM，应该首先从何入手呢" class="headerlink" title="请问少楠老师，对于一个全新的行业，做为一个PM，应该首先从何入手呢"></a>请问少楠老师，对于一个全新的行业，做为一个PM，应该首先从何入手呢</h2><p>全新的行业，我现在更多的会先去找内行的人给我讲这个行业的利益是如何分配的，比如餐饮行业有钱的其实是连锁店，看似小而美的咖啡馆什么的并不挣钱，但是小的奶茶店却又非常暴利。理解完这些才能去设计产品，毕竟我们在的公司最重要的一件事情就是 —— 挣钱</p><h2 id="刘老师，说个大的问题，你觉得产品经理的未来在哪里？五年后，十年后的发展方向是怎么样😁"><a href="#刘老师，说个大的问题，你觉得产品经理的未来在哪里？五年后，十年后的发展方向是怎么样😁" class="headerlink" title="刘老师，说个大的问题，你觉得产品经理的未来在哪里？五年后，十年后的发展方向是怎么样😁"></a>刘老师，说个大的问题，你觉得产品经理的未来在哪里？五年后，十年后的发展方向是怎么样😁</h2><p>好问题，我也在思考。我很喜欢贝佐斯的「想想十年后什么不变」的思考方式，所以我现在大量的时间都在阅读心理学，经济行为学，统计学相关的书籍，因为这些是经历了时间考验的内容，并且是和人息息相关的，十年之内不会有巨大的改变的</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知乎Live《产品汪的五种武器：记录、实现、架构、数据、整理》记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="个人提高" scheme="http://wittyfans.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
      <category term="互联网" scheme="http://wittyfans.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="产品" scheme="http://wittyfans.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>《失控：机器、社会系统与经济世界的新生物学》读书笔记（更新中）</title>
    <link href="http://wittyfans.com/reading/%E3%80%8A%E5%A4%B1%E6%8E%A7%EF%BC%9A%E6%9C%BA%E5%99%A8%E3%80%81%E7%A4%BE%E4%BC%9A%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BB%8F%E6%B5%8E%E4%B8%96%E7%95%8C%E7%9A%84%E6%96%B0%E7%94%9F%E7%89%A9%E5%AD%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://wittyfans.com/reading/《失控：机器、社会系统与经济世界的新生物学》读书笔记.html</id>
    <published>2017-05-24T10:07:04.000Z</published>
    <updated>2018-03-15T14:29:25.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人与自然，多么美妙！</p></blockquote><a id="more"></a><h1 id="第一章-人造与天生"><a href="#第一章-人造与天生" class="headerlink" title="第一章-人造与天生"></a>第一章-人造与天生</h1><p>作者设想了一个美好的场景，即他生活在一个机器与生物融为一体的时代。<em>机器，正在生物化；而生物，正在工程化</em>，当人类的技术不断的发展的时候，趋势就是人造与自然的结合形成的新生物文明。人造需要自然的指引，这近一步要求我们保护现有的环境，以便更好的从中吸取养分改造现有技术。但当我们把人造与自然结合的时候，机器也获得了野性，我们将不完全拥有我们创造的东西。</p><h1 id="第二章-蜂群思维"><a href="#第二章-蜂群思维" class="headerlink" title="第二章-蜂群思维"></a>第二章-蜂群思维</h1><p>蜂群思维是一种集体思维，简单来说：每一个个体都会在某个程度上影响集体，当所有个体加在一起的时候，便会出现一个整体效果（例如三个音符在一起会让你听到旋律，不仅仅是三个音符），作者说明：<em>这种行为在科学层面上来说，不仅仅是一个事物，一个概念，而是一种持续的波涌或进程</em>。</p><p>在人类身上，同样具有这样的集体思维效果，但值得注意的是集体思维尽管非常神奇，并不适用于所有情况（例如飞机紧急迫降），遵循着简单的规则，利用计算机我们可以模拟出集体思维并应用，比如在电影中制造蝙蝠飞过的景象，只要保证：1.每个蝙蝠不要撞到其他的蝙蝠；2.跟上自己旁边的蝙蝠；3.离队伍不要太远，在屏幕上运行的时候就跟真的蝙蝠一样。</p><p>蜂群思维的神秘之处还在于，量变引起质变，<em>要想从单个虫子的集体过度到集群机制，只需要增加虫子的数量即可</em><br>作者对蜂群思维产生了极大的兴趣，并猜测其中肯定酝酿着某种最出人意料的东西。从我们人类认知和记忆的角度来看：</p><ul><li><em>记忆好比由储存在脑中的许多离散的、非记忆似的碎片汇总起来而从中涌现出来的事件。这些半意识的碎片没有固定的位置，它们分散在大脑中。其储存方式在不同的意识之间有本质的不同</em></li><li><em>我们的意识是通过许多散布在记忆中的线索创造了现在，如果他创造了过去一样</em></li><li><em>记忆，是高度重建的。在记忆中进行搜取，需要从数目庞大的事件中挑选出什么是重要的，什么是不重要的，强调重要的东西，忽略不重要的东西。”这种选择的过程实际上就是感知。</em></li></ul><p>因此，我们可以模仿这种记忆存贮的方式，用计算机去存取数据，对比数据，于是就有了卡内尔瓦算法，也被称为稀疏分布记忆，这种算法在计算机中实现后，可以根据存在计算中的图像去对比更低清晰度的图像并判断其相似度，也就是说。也就是说，对于你祖母的照片，计算机不仅可以辨识出在不同光线下的你的祖母，而且在不同光线下也可以辨认。</p><p>由此我们归纳出分布式系统的特点、好处、缺点：<br><strong>特点</strong></p><ul><li>没有强制性的中心控制</li><li>次级单位具有自治的特质</li><li>次级单位之间彼此高度连接</li><li>点对点间的影响通过网络形成了非线性因果关系</li></ul><p><strong>好处</strong></p><ul><li>可适应——人们可以建造一个类似钟表装置的系统来对预设的激励信号进行响应。但是，如果想对未曾出现过的激励信号做出响应，或是能够在一个很宽的范围内对变化做出调整，则需要一个群——一个蜂群思维。只有包含了许多构件的整体才能够在其部分构件失效的情况下仍然继续生存或适应新的激励信号。</li><li>可进化——只有群系统才可能将局部构件历经时间演变而获得的适应性从一个构件传递到另一个构件（从身体到基因，从个体到群体）。非群体系统不能实现（类似于生物的）进化。</li><li>弹性——由于群系统是建立在众多并行关系之上的，所以存在冗余。个体行为无足轻重。小故障犹如河流中转瞬即逝的一朵小浪花。就算是大的故障，在更高的层级中也只相当于一个小故障，因而得以被抑制。</li><li>无限性——对传统的简单线性系统来说，正反馈回路是一种极端现象，比如扩声话筒无序的回啸。而在群系统中，正反馈却能导致秩序的递增。通过逐步扩展超越其初始状态范围的新结构，群可以搭建自己的脚手架借以构建更加复杂的结构。自发的秩序有助于创造更多的秩序——生命能够繁殖出更多的生命，财富能够创造出更多的财富，信息能够孕育更多的信息，这一切都突破了原始的局限，而且永无止境。</li><li>新颖性——群系统之所以能产生新颖性有三个原因：<ol><li>它们对“初始条件很敏感”——这句学术短语的潜台词是说，后果与原因不成比例——因而，群系统可以将小土丘变成令人惊讶的大山。</li><li>系统中彼此关联的个体所形成的组合呈指数增长，其中蕴藏了无数新颖的可能性。</li><li>它们并不强调个体，因而也允许个体有差异和缺陷。在具有遗传可能性的群系统中，个体的变异和缺陷能够导致恒新，这个过程我们也称之为进化。</li></ol></li></ul><p><strong>缺点</strong></p><ul><li>非最优——因为冗余，又没有中央控制，群系统的效率是低下的。其资源分配高度混乱，重复的努力比比皆是。青蛙一次产出成千上万只卵，只为了少数几个子代成蛙，这是多么大的浪费！假如群系统有应急控制的话——例如自由市场经济中的价格体系，那么就可以在一定程度上抑制效率低下，但绝不可能像线性系统那样彻底消除它。</li><li>不可控——没有一个绝对的权威。引领群系统犹如羊倌放羊：要在关键部位使力，要扭转系统的自然倾向，使之转向新的目标（利用羊怕狼的天性，用爱撵羊的狗来将它们集拢）。经济不可由外部控制，只能从内部一点点地调整。人们无法阻止梦境的产生，只能在它现身时去揭示它。无论在哪里，只要有“涌现”的字眼出现，人类的控制就消失了。</li><li>不可预测——群系统的复杂性以不可预见的方式影响着系统的发展。“生物的历史充满了出乎意料。”研究员克里斯·朗顿￼如是说。他目前正在开发群的数学模型。“涌现”一词有其阴暗面。视频游戏中涌现出的新颖性带给人无穷乐趣；而空中交通控制系统中如果出现涌现的新情况，就可能导致进入全国紧急状态。</li><li>不可知——我们目前所知的因果关系就像钟表系统。我们能理解顺序的钟表系统，而非线性网络系统却是道地的难解之谜。后者淹没在它们自制的困思逻辑之中。A导致B，B导致A。群系统就是一个交叉逻辑的海洋：A间接影响其他一切，而其他一切间接影响A。我把这称为横向因果关系。真正的起因（或者更确切地说，由一些要素混合而成的真正起因），将在网络中横向传播开来，最终，触发某一特定事件的原因将无从获知。那就听其自然吧。我们不需要确切地知道西红柿细胞是如何工作的，也能够种植、食用、甚至改良西红柿。我们不需要确切地知道一个大规模群体计算系统是如何工作的，也能够建造、使用它，并使之变得更加完美。不过，无论我们是否了解一个系统，都要对它负责，因此了解它肯定是有帮助的。</li><li>非即刻——点起火，就能产生热量；打开开关，线性系统就能运转。它们准备好了为你服务。如果系统熄了火，重新启动就可以了。简单的群系统可以用简单方法唤醒；但层次丰富的复杂群系统就需要花些时间才能启动。系统越是复杂，需要的预热时间就越长。每一个层面都必须安定下来；横向起因必须充分传播；上百万自治成员必须熟悉自己的环境。我认为，这将是人类所要学的最难的一课：有机的复杂性将需要有机的时间。</li></ul><p><strong>群（分布式思维）是一种自然之美，科学可以帮助它解决简单的任务，但它还需要面临生命的杂乱。</strong></p><p>21世纪的网络就是分布式思维的一种，它没有开始、没有结束、也没有中心，或者反之，到处都是开始、到处都是结束、到处都是中心。</p><p>网络不可控，低效率，随时孕育着小的故障以此来避免大的故障，到处都是边界。分布式的、去中心化的网络是一个过程，经济学家们认为，只有把产品当作服务来做，才能取得最佳的效果。你卖给顾客什么并不重要，重要的是你为顾客做了些什么。这个东西是什么并不重要，重要的是它与什么相关联，它做了什么。流程重于资源。行为最有发言权。</p><p>蜂箱里的蜜蜂感觉不到自己的群体，我们也一样，在现在我们无时无刻都能联网的时代，会涌现出许多东西，而我们仅仅作为身处网络中的神经元，是意料不到、无法理解、和控制不了网络的，甚至都感觉不到它，任何涌现的蜂群思维都会让你付出这样的代价。</p><h1 id="第三章-有心智的机器"><a href="#第三章-有心智的机器" class="headerlink" title="第三章-有心智的机器"></a>第三章-有心智的机器</h1><p>有心智的机器，不一定要用心智去管理机器的所有活动，例如走路。最新的技术表明，走路这种简单的行为模式可以通过分布式思维去解决，即每条腿只需要管好自己的工作即可。每条腿都有权做一些简单的动作，没条腿也都能独立判断不同环境该如何行事，当这个机器有能力走路的时候，就可以在此基础上增加它其他的能力，这是基于叠加的能力，而不是去修改底层的能力。<br>这种架构被称为包容架构，如果把国家比做包容架构，你可以这么建造：</p><p><em>你从乡镇开始。先解决乡镇的后勤：基本工作包括整修街道、敷设水电管道、提供照明，还要制定律法。当你有了一些运转良好的乡镇，就可以设立郡县。在保证乡镇正常运作的基础上，你在郡县的范围内设立法院、监狱和学校，在乡镇的层级之上增加了一层复杂度。就算郡县的机构消失了，也不会影响乡镇照常运转。郡县数量多了，就可以添加州的层级。州负责收税，同时允许郡县继续行使其绝大部分的职权。没有州，乡镇也能维持下去，虽然可能不再那么有效率或那么复杂。当州的数量多了，就可以添加联邦政府。通过对州的行为做出限制并承载其层面之上的组织工作，联邦层级包容了州的一些活动。即使联邦政府消失了，千百个乡镇仍会继续做自己的地方工作——整修街道、敷设水电管道、提供照明。但是当乡镇工作被州所包容，并最终被联邦所包容时，这些乡镇工作就会显示出更强大的功效。也就是说，以这种包容架构所组织起来的乡镇，在开展建设、实施教育、执行管理、繁荣经济方面，都可以做得比独自运作时好许多。美国政府的联邦结构就是一个包容架构。</em></p><p>这种行为模式可以推导出一套分布式控制方法，这种分布式控制方法是自下而上的：</p><ul><li>先做简单的事。</li><li>学会准确无误地做简单的事。</li><li>在简单任务的成果之上添加新的活动层级。</li><li>不要改变简单事物。</li><li>让新层级像简单层级那样准确无误地工作。</li><li>重复以上步骤，无限类推</li></ul><p>机器在这种工作模式下，它们一方面是各忙各的，一方面又组成了一个新的整体，形成层级结构，需要注意的是，层级结构有两种，一种是自上而下分布的，另一种是自下而上分布的。自上而下的比如地位层级，自下而上的比如分布式系统，虽然自上而下的层级结构会趋于消亡，但离开了自上而下的层级结构，后者也无法生存。因为同层的个体相互影响的时候，它们的力量变大了，但也变动行动迟缓了。但底层的工作必须保持事物的局部性和直接性，即底层的决策者必须只关注它自己关注的区域，避免了伴随硬件通讯过程而产生的复杂度爆炸问题，而且上层也不用担心信息丢失，因为底层的决策者会一直重复的回报他发现的事情。</p><p>复杂度爆炸问题在计算机中非常普遍，计算机的中枢系统必须清楚的知道外界是什么情况。可如果碰到眼睛告诉你东西正接近，耳朵却告诉你东西正离去，该怎么处理？应该是尽力去找出真相，于是控制中心调节纠纷并重新修正信号，使之一致。在非包容结构的机器人中，中枢系统永远在做协调工作，但永远都无法协调好所有的事情，因为总是一事无成。</p><p><strong>在包容控制的系统中，一个行为是通过抑制、延迟、激活的方式被筛选出来的。</strong>，这种思维启发了人们设计了移动式机器人的，并总结了五条经验：</p><ul><li>增式构建——让复杂性自我生成发展，而非生硬植入</li><li>传感器和执行器的紧密耦合——要低级反射，不要高级思考</li><li>与模块无关的层级——把系统拆分为自行发展的子单元</li><li>分散控制——不搞中央集权计划</li><li>稀疏通讯——观察外部世界的结果，而非依赖导线来传递讯息</li></ul><p>知道计算机的中枢不必事事亲力亲为之后，我们再把注意力转移到人脑上来，我们说心智的发展离不开意识，那意识是什么呢？它在我们大脑中是怎么存在的呢？是否可以把这些意识转移到计算机中去呢？作者并不支持意识转移的理论，它认为，意识存在于躯体，不管是对我们生命楷还是机器。<br><em>不管结果如何，在现实中，我们不以头脑为中心，也不以意识为中心。即便真的如此，我们的意识也没有中心，没有“我”。我们的身体也没有向心性。身体和意识跨越了彼此间的假想边界，模糊了彼此间的差别。它们都是由大量的亚层次物质组成的。</em></p><p>意识存在于躯体，离不开躯体，也受躯体约束。<em>身体是意识乃至生命停泊的港湾，是阻止意识被自酿的风暴吞噬的机器。神经线路天生就有玩火自焚的倾向。如果放任不管，不让它直接连接“外部世界”，聪明的网络就会把自己的构想当作现实。意识不可能超出其所能度量或计算的范畴。没有身体，意识便只能顾及自己</em> 如果意识脱离躯体，就会变得无所顾忌，出于天赐的好奇心，即便是最简单的头脑也会在面对挑战时，殚精竭虑以求一解。然而，如果意识直面的大都是自身内部的线路和逻辑问题，那它就只能终日沉迷于自己所创造出的奇思异想。<br>**</p><hr><p>阅读中…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人与自然，多么美妙！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://wittyfans.com/categories/reading/"/>
    
    
      <category term="互联网" scheme="http://wittyfans.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="阅读" scheme="http://wittyfans.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——函数与对象</title>
    <link href="http://wittyfans.com/coding/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://wittyfans.com/coding/JavaScript学习笔记——函数与对象.html</id>
    <published>2017-05-22T08:45:54.000Z</published>
    <updated>2018-03-15T14:46:41.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JS的函数与对象。</p></blockquote><a id="more"></a><h1 id="函数-🔂"><a href="#函数-🔂" class="headerlink" title="函数 🔂"></a>函数 🔂</h1><p><strong>函数是带有名称(named)和参数的代码段,可以一次定义多次调用</strong></p><ul><li>如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法，当通过这个对象来调用函数时，该对象就是此次调用的上下文，也就是该函数的this值</li><li>JS中，函数即对象，所以甚至可以给函数赋予属性</li><li>函数可以在函数中定义，此时它可以访问父函数中的任何变量，这意味着形成了一个闭包</li><li>一条函数声明语句，实际上创建了函数并赋予给了变量</li><li>函数的名字是函数内部的一个局部变量</li><li>以表达式定义的函数在定义前无法调用</li><li>一个方法无非是存在一个对象中的JS函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function plus(x)&#123;</span><br><span class="line">return x+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square = function(x)&#123;</span><br><span class="line">return x*x;</span><br><span class="line">&#125;</span><br><span class="line">//函数是一种值，可以赋值给变量</span><br><span class="line"></span><br><span class="line">square(plus(1));</span><br><span class="line">// =&gt;4 在一个表达式中调用两个函数</span><br></pre></td></tr></table></figure><ul><li>定义了一个名为plus的函数，参数是x，用的时候把要处理的数据传给x就好</li><li>函数处理完的数据由return返回</li><li>函数是一种值，可以赋值给变量</li></ul><p><strong>当函数和对象写在一起的时候，函数就变成了方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a = []; //定义空的数组</span><br><span class="line">a.push(1,2,3); //给数组增加三个元素</span><br><span class="line">a.reverse(); //另一个方法，数组元素次序反转</span><br><span class="line"></span><br><span class="line">points.dist = function()&#123; </span><br><span class="line">var p1 = this[0];</span><br><span class="line">var p2 = this[1];</span><br><span class="line"></span><br><span class="line">var a = p2.x - p1.x;</span><br><span class="line">var b = p2.y - p1,y;</span><br><span class="line"></span><br><span class="line">return Math.sqrt(a * a + b * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">points.dist();</span><br></pre></td></tr></table></figure></p><ul><li>dist是对象的方法，没有参数，运算的数据来源于对象本身</li></ul><h2 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h2><ul><li>当方法的返回值是对象，这个对象还可以再调用其它的方法</li><li>不要将调用方法的链式调用与构造函数的链式调用混淆</li><li>this是关键字，不是属性、变量</li></ul><h2 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h2><ul><li>在方法调用之前使用了new关键字，就构成了构造函数调用</li><li>构造函数调用和普通的调用在实参处理、调用上下文、返回值方面有所不同</li><li>没有形参的构造函数调用可以省略圆括号，比如var o = new object;和var o = new object();是等价的</li><li>构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，并将这个这个对象用作其上下文</li><li>在new o.m()中，调用上下文并不是o</li></ul><h2 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h2><ul><li>JS中函数也是对象，所以函数也可以使用方法</li><li>函数有两个方法可以用来间接的调用函数，Call(),Apply()，参数是调用所需的this值</li></ul><h2 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a>实参与形参</h2><ul><li>JS的函数定义并没有指定函数形参的类型，调用也不会对实参做任何类型检查</li><li>JS函数调用也不检查传入形参的个数，当传入的参数比需要的少，剩下的会被设置为undefined</li><li>可以做到显式测试函数实参的类型，例如在函数体内，使用if判断语句，a = a || [];，这里的意思是，如果传入的数组是空的，那就创建一个新的（a要提前声明）</li><li>如果使用这种方式，建议吧可选的实参放到函数参数列表之后</li></ul><h2 id="实参对象（ES5中被移除）"><a href="#实参对象（ES5中被移除）" class="headerlink" title="实参对象（ES5中被移除）"></a>实参对象（ES5中被移除）</h2><ul><li>当调用函数的时候，传进来的参数个数太多怎么办？</li><li>函数体内有一个实参对象，它可以通过arguments标识符访问，里面存储了函数的实参值，可以通过数组下标的形式访问传入的实参值</li><li>和真正的数组一样，arguments也有length属性</li><li>实参对象在很多地方都很有用，就是让函数可以操作任意数量的实参</li><li>注意arguments不是真的数字，而是实参对象，即类数组对象</li><li>callee和caller属性（非严格模式下才可以使用）</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>JS会处理实参类型与所需类型不一致的情况，一般会利用tostring方法将其转化为字符串中</li></ul><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><ul><li>函数不仅是一种语法，也是一种值，也就是说，可以把函数赋值给变量，储存在对象的属性或数组的元素中，作为参数传入另外一个函数等</li><li><p>来看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123;return x*x&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个新的函数对象，赋值给square</li><li>函数名字实际上是看不见的，square仅仅是变量的名字</li></ul></li></ul><h2 id="自定义函数属性"><a href="#自定义函数属性" class="headerlink" title="自定义函数属性"></a>自定义函数属性</h2><ul><li><p>JS中函数并不是原始值，而是一种特殊的对象，也就是说函数可以拥有属性，而且因为函数的声明被提前，可以在函数声明之前给它的成员赋值，看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniqueInteger.counter = 0;</span><br><span class="line">function uniqueInteger()&#123;</span><br><span class="line">return uniqueInteger.counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个函数使用了一个自身的属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值</p><h2 id="作为命名空间的函数"><a href="#作为命名空间的函数" class="headerlink" title="作为命名空间的函数"></a>作为命名空间的函数</h2></li><li>常常可以定义一个简单的函数用作临时的命名空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一种模式</span><br><span class="line">function mymodule()&#123;</span><br><span class="line">//模块代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//匿名函数模式</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">//模块代码</span><br><span class="line">&#125;()); //结束函数定义后马上调用</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>JS函数对象的内部状态不仅包括函数的代码逻辑，还必须引用当前的作用域链</li><li>函数对象可以通过作用域链相互关联起来，函数内部的变量都可以保存在函数的作用域内</li><li>从技术的角度来讲，所有的JS函数都是闭包：它们都是对象、它们都关联到作用域链、</li><li>调用函数时闭包所指向的作用域链和定义函数时闭包所指向的作用域链可能不同</li><li>有时候一个函数嵌套了另一个函数，外部函数将嵌套的函数作为对象返回</li><li><p>举例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checscope()&#123;</span><br><span class="line">var scope = &quot;local scope&quot;;</span><br><span class="line">function f() &#123;return scope;&#125;</span><br><span class="line">return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope()</span><br></pre></td></tr></table></figure></li><li><p>举例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checscope()&#123;</span><br><span class="line">var scope = &quot;local scope&quot;;</span><br><span class="line">function f() &#123;return scope;&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()()</span><br></pre></td></tr></table></figure></li><li><p>效果是一样的，函数定义时的作用域链到函数执行时依然有效</p></li><li>外部函数中定义的局部变量在函数返回后就不存在了吗？非也，这要看具体情况，如果函数定义的局部变量在CPU的栈总，那么函数返回时它们的确就不存在了，但作用域链是一个对象列表，不是绑定的栈，当定义了嵌套函数的时候，会有一个外部引用指向这个嵌套函数，它就不会被销毁</li><li><p>上面的uniqueInteger（）函数有一个bug，即别人可以修改计数器，导致不一定能产生正确的值，但闭包也可以捕捉单个函数调用的局部变量，而且这些变量会变称私有状态，我们可以利用闭包来重写这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var uniqueInteger = (function()&#123;</span><br><span class="line">var counter = 0;</span><br><span class="line">return function() &#123; return counter++;&#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li><li><p>你需要仔细查看这段代码才能知道它的意思，粗看你会以为这是把一个函数赋值给uniqueInterger，但其实这是把一个立即执行的函数的返回值赋值给了uniqueInterger</p></li><li>在被返回的函数中，它还是可以访问counter变量的</li><li><p>从技术的角度来看，可以把闭包合并为属性存器方法getter和setter，看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function counter(n)&#123;</span><br><span class="line">return &#123;</span><br><span class="line">get count()&#123;return n++&#125;,</span><br><span class="line">set count(m)&#123;</span><br><span class="line">if (m&gt;=n) n = m;</span><br><span class="line">else throw(&quot;count can onyl be set to a larger value&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = count(1000);</span><br><span class="line">c.count // =&gt; 1000</span><br><span class="line">c.count // =&gt; 1001</span><br><span class="line">c.count = 2000; // =&gt;</span><br><span class="line">c.count // =&gt; 2000</span><br><span class="line">c.count = 2000 // =&gt; Error!</span><br></pre></td></tr></table></figure></li><li><p><strong>闭包中访问外部函数的arguments和this值，需要做特殊处理</strong></p></li></ul><h2 id="函数属性、方法和构造函数"><a href="#函数属性、方法和构造函数" class="headerlink" title="函数属性、方法和构造函数"></a>函数属性、方法和构造函数</h2><blockquote><p>因为函数也是对象，所以它们也可以拥有属性和方法，就像普通的对象也可以拥有属性和方法一样。甚至可以用Function()构造函数来创建新的函数对象。</p></blockquote><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>arguments.length表示传入函数的实参的个数。而函数本身的length不一样，它是只读的，代表函数实参的数量，也就是函数在定义时给出的实参个数。function check(args){},args.length表示实参的真实个数，args.callee.lengt表示期望的实参个数</p><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><p>每个函数都有一个prototype属性，这个属性指向一个对象的引用，这个对象叫做原型对象。每一个函数都包含不同的原型对象，当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p><h3 id="✅-call-方法和apply-方法"><a href="#✅-call-方法和apply-方法" class="headerlink" title="✅ call()方法和apply()方法"></a>✅ call()方法和apply()方法</h3><p>以对象O的方法来调用函数f(),f.call(o);即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f; //将f临时存储为o的临时方法</span><br><span class="line">o.m() //调用它，不传入参数</span><br><span class="line">delete o.m; //将临时方法删除</span><br></pre></td></tr></table></figure></p><h3 id="✅-bind-方法"><a href="#✅-bind-方法" class="headerlink" title="✅ bind()方法"></a>✅ bind()方法</h3><p>将函数绑定至某个对象，当在函数f()上调用bind()方法并传入一个对象o做为参数，这个方法将返回一个新的函数，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(y) &#123;return this.x+y;&#125;</span><br><span class="line">var o = &#123;x : 1&#125;;</span><br><span class="line">var g = f.bind(o);</span><br><span class="line">g(2) =&gt; 3 //通过g(x)来调用o.f(x)</span><br></pre></td></tr></table></figure></p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul><li>返回字符串，相关语句，或者源码、”[native code]”字符串</li></ul><h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function()构造函数"></a>Function()构造函数</h3><p>可以通过Function()构造函数来定义函数，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y&quot;);</span><br><span class="line">//等价于👇</span><br><span class="line">var f = function(x,y) &#123;return x*y&#125;</span><br></pre></td></tr></table></figure></p><ul><li>可以传入任意数量的实参，最后一个字符串为函数体</li><li>可以用这个构造函数动态的修改、编译函数</li><li>每次调用构造函数都会解析函数体，并创建新的函数对象，在循环语句下会影响效率</li><li>这样创建的函数并不是使用词法作用域，相反，函数体代码的编译总是在顶层函数执行，正如下面代码所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope = “global”;</span><br><span class="line">function construcFunction() &#123;</span><br><span class="line">var scope = “local”;</span><br><span class="line">return new Function(“return scope”);//无法获取local的值</span><br><span class="line">&#125;</span><br><span class="line">construFunction()(); =&gt; “global”</span><br></pre></td></tr></table></figure></li></ul><h3 id="✅-可调用对象"><a href="#✅-可调用对象" class="headerlink" title="✅ 可调用对象"></a>✅ 可调用对象</h3><ul><li>可调用对象是一个对象，可以在函数调用表达式中调用这个对象。</li><li>所有的函数都是可以调用的，但不一定可调用对象都是函数。</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote><p>JS可以像操作对象一样操控函数</p></blockquote><h3 id="使用函数处理数组"><a href="#使用函数处理数组" class="headerlink" title="使用函数处理数组"></a>使用函数处理数组</h3><p>参考实战环节的map、Reduce方法的使用</p><h3 id="✅-高阶函数"><a href="#✅-高阶函数" class="headerlink" title="✅ 高阶函数"></a>✅ 高阶函数</h3><h3 id="✅-不完全函数"><a href="#✅-不完全函数" class="headerlink" title="✅ 不完全函数"></a>✅ 不完全函数</h3><h3 id="✅-记忆"><a href="#✅-记忆" class="headerlink" title="✅ 记忆"></a>✅ 记忆</h3><h1 id="对象📦"><a href="#对象📦" class="headerlink" title="对象📦"></a>对象📦</h1><blockquote><p>对象是一种复合的值，通常是名+值的组合，可以通过名来访问相应的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//对象是 名：值 对的集合，或 字符串到值 映射的集合</span><br><span class="line">var book = &#123; </span><br><span class="line">topic: &quot;JavaScript&quot;,</span><br><span class="line">fat: true</span><br><span class="line">&#125;;</span><br><span class="line">//三种创建对象的方式</span><br><span class="line">&#123;&#125;;</span><br><span class="line">var x = new object();</span><br><span class="line">var a = Object.create(&#123;x:1,y:2&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>对象是动态的，可以随时新增、删除属性（名+值）；</li><li>我们通过引用去操作对象，引用类似于C语言中的指针，如果x是指向一个对象的引用，那么执行var y = x; 变量y也是指向同一个对象，而非副本。通过y修改这个对象，也会对x造成影响。</li><li>对象常见的用法，创建(create)，设置（set）查找(query)，删除(delete)，检测(test)，枚举(enumerate),将在之后介绍。</li><li>属性（名：值）中属性的名可以是任何字符串，包括空字符串，但不能同名，值可以是任何js值，也可以是getter、setter函数</li><li>属性还有一个值用来控制它本身是否可写、可枚举、可配置</li><li>对象本身还有三个相关的对象特性来控制、标记对象的功能<ul><li>对象的原型：指向另外一个对象</li><li>对象的类：表示对象类型的字符串</li><li>对象的扩展标记：是否可以添加新属性</li></ul></li><li>三类对象类型<ul><li>内置对象</li><li>宿主对象</li><li>自定义对象</li></ul></li><li>两类属性<ul><li>自有属性</li><li>继承属性</li></ul></li></ul><h2 id="三个属性"><a href="#三个属性" class="headerlink" title="三个属性"></a>三个属性</h2><p>原型属性：用来继承的属性，可以用对象的getprototype()方法查询该属性</p><ul><li>用Object.create()方法创建的对象会有一个costrutor属性，它指向Object()的构造函数</li><li>如果想要检查某个属性是否属于某个对象，可以使用isPrototypeOf()方法</li></ul><p>类属性：是一个字符串，用来表示对象的一些信息</p><ul><li>用tostring方法可以得到对象的类属性，如果toString方法被重写了，可以使用classOf()方法</li><li>需要注意的是，有了对象以后才能使用toString()方法</li><li>不可以通过<a href="">直接量</a>来调用toString()方法,直接量，即表达式 ？</li><li>关于ClassOf()方法，如果自定义了classOf方法，它返回的值会是Object</li></ul><p>可拓属性：决定了该对象是否可以拓展属性</p><ul><li>宿主对象的可拓展性由JavaScript引擎决定</li><li>可以使用Object.esExtendible（）方法来判断该对象是否可以增加新的属性</li><li>Object.PreventExtensions()可以转换对象的拓展属性，即让不可拓展的对象变成可拓展的，</li><li>Freeze()方法可以让对象的属性变成冻结的状态，不可配置</li></ul><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><ul><li>对象的序列化即将对象变成字符串，或者是反过来。一般是对象=&gt;Jason</li><li>函数，Regexp，Error对象和Undefined值不可以序列或还原</li><li>Stringify()只可以序列枚举对象</li><li>序列函数都有第二个参数，是可选的</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul><li>对象直接量:<ul><li>{x:0};</li><li>对象直接量是一个表达式，如果在for循环内使用，会创建出很多新对象，并且每次创建的对象的属性值也可能不同</li></ul></li><li>关键字new<ul><li>var x = new Object();</li><li>new后面的函数叫做构造函数，像数组、日期类构造函数是默认的，当然也可以自定义</li></ul></li><li>object.create()函数<ul><li>var a = Object.create({x:1,y:2}); a继承了x和y,<a href="">什么是继承？</a></li><li>create（）提供了两个参数，第一个参数是这个对象的原型，第二个是一个可选参数，用来对对象的属性进行进一步描述，之后会详细讲述第二个参数</li><li>如果第一个参数传入null，那这个对象不会继承任何东西，甚至不包括基础方法，都不能和运算符一起工作</li><li>如果需要创建一个空对象，需要传入Object.prototype</li><li>可以通过任意原型创建新对象，换句话说可以让任意对象可继承</li><li>inherit()函数，返回一个新对象，这个新对象继承了参数对象的属性</li></ul></li></ul><h2 id="属性的使用与设置"><a href="#属性的使用与设置" class="headerlink" title="属性的使用与设置"></a>属性的使用与设置</h2><ul><li>标识符：.之后为标识符，是静态的，必须写死在程序中作为索引</li><li>字符串值：[]，中括号中为字符值，程序运行的时候可以修改它们，因此可以有这种代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var addr = &quot;;</span><br><span class="line">for (i = 0;i&lt;4;i++)&#123;</span><br><span class="line">addr+= customer[&quot;address&quot;+i] + &apos;\n&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码读取customer对象的address0、address1、address2和address3的值，并将它们连接起来。</p><h2 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a>属性的继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;</span><br><span class="line">o.x = 1;</span><br><span class="line"></span><br><span class="line">var p = inherit(o)</span><br><span class="line">p.y = 2;</span><br><span class="line"></span><br><span class="line">var q = inherit(p)</span><br><span class="line">q.z = 3;</span><br><span class="line"></span><br><span class="line">var s = q.tostring();</span><br><span class="line">q.x+q.y // =&gt; 3</span><br></pre></td></tr></table></figure><ul><li>p继承o、q继承p，底层的拥有上层的属性，如果属性同名，底层优先使用自己的值</li><li>一般在查询属性的时候才能体会到继承的存在，设置属性的时候则和继承无关</li></ul><h2 id="属性访问出错了"><a href="#属性访问出错了" class="headerlink" title="属性访问出错了"></a>属性访问出错了</h2><ul><li>查询一个不存在的属性不会报错，查询不存在的对象会报错</li><li>给只读属性赋值会报错</li><li>如果o是不可扩展的，也没使用setter方法，那么o不可定义新属性</li></ul><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete book.author;</span><br><span class="line">delete book[&quot;main title&quot;];</span><br></pre></td></tr></table></figure><ul><li>delete 只是断开断开属性和对象的联系，而不会操作这些属性中的属性</li><li><p>例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;p:&#123;x:1&#125;&#125;;</span><br><span class="line">b = a.p;</span><br><span class="line">delete a.p; //只是断开a与p的联系，但b与p还是有联系，不严谨的代码容易导致内存泄露</span><br></pre></td></tr></table></figure></li><li><p>delete 返回ture或false，delete不能删除那些可配置性为false 的属性</p></li><li>在严格模式下，需要用this指定对象以及属性，才能删除全局对象的属性</li></ul><h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><blockquote><p>我们经常会检测集合中成员的关系，判断某个属性是否在某个对象单中，可以通过for-in运算符，hasOwnpreperty()和propertyIsEnumerable()来完成这个工作</p></blockquote><ul><li>in运算符：左侧是属性，右侧是对象，如果存在返回true</li><li>hasOwnpreperty()方法：检测给定的名字是否是对象的自有属性，对于继承的属性会返回false</li><li>propertyIsEnumerable()：hasOwnpreperty()的增强版，是自有属性且这个属性可枚举才返回True</li></ul><hr><p>✅ ：Todo 的部分</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JS的函数与对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="编程" scheme="http://wittyfans.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JS" scheme="http://wittyfans.com/tags/JS/"/>
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——错误集</title>
    <link href="http://wittyfans.com/coding/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E9%9B%86.html"/>
    <id>http://wittyfans.com/coding/JavaScript学习笔记——错误集.html</id>
    <published>2017-05-22T08:41:37.000Z</published>
    <updated>2018-03-15T14:46:48.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人JS学习的错题本</p></blockquote><a id="more"></a> <h1 id="错误集-📈"><a href="#错误集-📈" class="headerlink" title="错误集 📈"></a>错误集 📈</h1><h2 id="如果for循环内都没有返回值，那么就在for循环外返回for循环没找到的情况下需要返回的值"><a href="#如果for循环内都没有返回值，那么就在for循环外返回for循环没找到的情况下需要返回的值" class="headerlink" title="如果for循环内都没有返回值，那么就在for循环外返回for循环没找到的情况下需要返回的值"></a>如果for循环内都没有返回值，那么就在for循环外返回for循环没找到的情况下需要返回的值</h2><h2 id="这行代码在做什么？"><a href="#这行代码在做什么？" class="headerlink" title="这行代码在做什么？"></a>这行代码在做什么？</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random() * (max - min + 1)) + min</span><br></pre></td></tr></table></figure>- **解释**    - 最大值减去最小值后 = a    - 最小值 + （1*a）= 最大值    - 把1换成ramdom函数，因为ramdom永远不会大于1    - 所以整个函数的值不会超过指定的范围    - **为什么要+1？**</code></pre><h2 id="这行代码是什么意思？"><a href="#这行代码是什么意思？" class="headerlink" title="这行代码是什么意思？"></a>这行代码是什么意思？</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$($(&quot;.slot&quot;)[0]).html(slotOne);</span><br></pre></td></tr></table></figure></code></pre><h2 id="闭包的常见错误"><a href="#闭包的常见错误" class="headerlink" title="闭包的常见错误"></a>闭包的常见错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这个函数是一个总是返回V的函数</span><br><span class="line">function constfun(v)&#123; return function() &#123;return v;&#125;&#125;</span><br><span class="line">// 创建一个数组用来存储常数函数</span><br><span class="line">var funcs = [];</span><br><span class="line">for(var i = 0; i&lt; 10; i++) funcs[i] = constfunc(i);</span><br><span class="line">//在第五个位置的元素所表示的函数返回值为5</span><br><span class="line">funcs[5]() // =&gt;5</span><br></pre></td></tr></table></figure><ul><li><p>这段代码利用循环创建了很多个闭包，当写类似这样的代码的时候往往会犯一个错误，那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//返回一个函数组成的数组，它们的返回值是0-9</span><br><span class="line">function constfuncs() &#123;</span><br><span class="line"></span><br><span class="line">var funcs = [];</span><br><span class="line">for (var i = i; i &lt; 10; i++)&#123;</span><br><span class="line">funcs[i] = function()&#123;return i;&#125;;</span><br><span class="line">return funcs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = constfuncs();</span><br><span class="line">funcs[5]() // 返回的是什么？</span><br></pre></td></tr></table></figure></li><li><p>☑ 嵌套的函数不会讲作用域内的私有成员复制一份，也不会对绑定的变量生存静态快照</p></li></ul><hr><h2 id="数组访问错误"><a href="#数组访问错误" class="headerlink" title="数组访问错误"></a>数组访问错误</h2><ul><li><p>arr[i].sort() ，错在哪里？<br>完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function largestOfFour(arr) &#123;</span><br><span class="line">  // You can do this!</span><br><span class="line">  var largest = 0;</span><br><span class="line">  for(var i = 0; i&lt;=arr.length; i++)&#123;</span><br><span class="line">    arr[i].sort();</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把i&lt;=arr.length改成i&lt;arr.length后，问题解决</p></li></ul><p><em>更新中 🚸</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;个人JS学习的错题本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="编程" scheme="http://wittyfans.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JS" scheme="http://wittyfans.com/tags/JS/"/>
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记——实战</title>
    <link href="http://wittyfans.com/coding/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98.html"/>
    <id>http://wittyfans.com/coding/JavaScript学习笔记——实战.html</id>
    <published>2017-05-22T08:41:21.000Z</published>
    <updated>2018-03-15T14:46:44.803Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人JS学习的实战记录</p></blockquote><a id="more"></a><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="🔑-实战翻转字符串"><a href="#🔑-实战翻转字符串" class="headerlink" title="🔑 实战翻转字符串"></a>🔑 实战翻转字符串</h2><blockquote><p>先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。你的结果必须得是一个字符串.当你完成不了挑战的时候，记得开大招’Read-Search-Ask’。这是一些对你有帮助的资源:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function reverseString(str) &#123;</span><br><span class="line">  var allStr = str.split(&apos;&apos;);</span><br><span class="line">  allStr = allStr.reverse();</span><br><span class="line">  allStr = allStr.join(&apos;&apos;);</span><br><span class="line">  </span><br><span class="line">  return allStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseString(&quot;Greetings from Earth&quot;);</span><br></pre></td></tr></table></figure><ul><li>split方法中，如果不写’’，那么数组中的“,”也会被转化成字符</li></ul><h2 id="🔑-实战计算一个整数的阶乘"><a href="#🔑-实战计算一个整数的阶乘" class="headerlink" title="🔑 实战计算一个整数的阶乘"></a>🔑 实战计算一个整数的阶乘</h2><blockquote><p>参考：一个正整数的阶乘（英语：factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function factorialize(num) &#123;</span><br><span class="line">  if(num === 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(var i = num-1;i &gt;0;i--)&#123;</span><br><span class="line">    num = num * i;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorialize(5);</span><br></pre></td></tr></table></figure><h2 id="🔑-实战去除字符串中的标点符号与空格"><a href="#🔑-实战去除字符串中的标点符号与空格" class="headerlink" title="🔑 实战去除字符串中的标点符号与空格"></a>🔑 实战去除字符串中的标点符号与空格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function palindrome(str) &#123;</span><br><span class="line">  // Good luck!</span><br><span class="line">  var str1 = str.toLowerCase();</span><br><span class="line">  str1 = str1.replace(/\W|_/g,&apos;&apos;);</span><br><span class="line">  arrIndex = str1.length-1;</span><br><span class="line">  </span><br><span class="line">  for(var i = 0;i&lt;=arrIndex/2;i++)&#123;</span><br><span class="line">    if(str1[i] != str1[arrIndex-i])&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">palindrome(&quot;A man, a plan, a canal. Panama&quot;);</span><br></pre></td></tr></table></figure><ul><li>replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串.即前面匹配到的内容，用后边的替换。<ul><li>补充：查阅MOZILLA文档心得，replace方法MOZILLA官网用法介绍为str.replace(regexpl|substr,newSubstr|function),中间的|意思是这个参数可以是A|，也可以是|B.</li><li>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">Replace()用法</a></li></ul></li><li>正则/\W|_/g,’’的意思：参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则语法</a>,/\W的意识是匹配所有非字母，如果是小写的w，那就是所有字母A-Z，a-z.</li><li>从两端对比数组的值，如何设计if语句？<ul><li>思路：假设数组长度为21，那么需要对比的值为1:21,2:20,3:19,</li><li>即 i:数组长度-i，for循环的次数为(21-1)/2</li></ul></li></ul><h2 id="🔑-找到提供的句子中最长的单词，并计算它的长度"><a href="#🔑-找到提供的句子中最长的单词，并计算它的长度" class="headerlink" title="🔑 找到提供的句子中最长的单词，并计算它的长度"></a>🔑 找到提供的句子中最长的单词，并计算它的长度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function findLongestWord(str) &#123;</span><br><span class="line">  var words=str.split(&apos; &apos;);</span><br><span class="line">  var maxLength=0;</span><br><span class="line">  for(var i=0;i&lt;words.length;i++)&#123;</span><br><span class="line">    if(maxLength&lt;words[i].length)&#123;</span><br><span class="line">      maxLength=words[i].length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;);</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3cplus.com/javascript/find-the-longest-word-solution.html" target="_blank" rel="noopener">参考</a></li></ul><h2 id="🔑-确保字符串的每个单词首字母都大写，其余部分小写。"><a href="#🔑-确保字符串的每个单词首字母都大写，其余部分小写。" class="headerlink" title="🔑 确保字符串的每个单词首字母都大写，其余部分小写。"></a>🔑 确保字符串的每个单词首字母都大写，其余部分小写。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function titleCase(str) &#123;</span><br><span class="line">  return str.toLowerCase().split(&apos; &apos;).map(function(word)&#123;</span><br><span class="line">    </span><br><span class="line">    return word.charAt(0).toUpperCase() + word.slice(1);</span><br><span class="line">  &#125;).join(&apos; &apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleCase(&quot;I&apos;m a little tea pot&quot;);</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3cplus.com/javascript/title-case-a-sentence-in-javascript.html" target="_blank" rel="noopener">参考</a></li></ul><h2 id="🔑-下面的大数组中包含了4个小数组，分别找到每个小数组的最大值，然后把它们串联起来，形成一个新数组。"><a href="#🔑-下面的大数组中包含了4个小数组，分别找到每个小数组的最大值，然后把它们串联起来，形成一个新数组。" class="headerlink" title="🔑 下面的大数组中包含了4个小数组，分别找到每个小数组的最大值，然后把它们串联起来，形成一个新数组。"></a>🔑 下面的大数组中包含了4个小数组，分别找到每个小数组的最大值，然后把它们串联起来，形成一个新数组。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function largestOfFour(arr) &#123;</span><br><span class="line">  // You can do this!</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);</span><br></pre></td></tr></table></figure><ul><li>思路<ul><li>循环访问数组，在第二层循环中，碰到大的记录下来给longest</li><li>第二层循环结束的时候，把longest Push 到数组，longest变为0</li></ul></li><li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function largestOfFour(arr) &#123;</span><br><span class="line">  // You can do this!</span><br><span class="line">  var largest = 0;</span><br><span class="line">  var result = [];</span><br><span class="line">  for(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    </span><br><span class="line">    for(var j = 0; j&lt;=arr[i].length;j++)&#123;</span><br><span class="line">      if (largest &lt; arr[i][j])&#123;</span><br><span class="line">        largest = arr[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(largest);</span><br><span class="line">    largest = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="🔑-检查一个字符串-str-是否以指定的字符串-target-结尾。"><a href="#🔑-检查一个字符串-str-是否以指定的字符串-target-结尾。" class="headerlink" title="🔑 检查一个字符串(str)是否以指定的字符串(target)结尾。"></a>🔑 检查一个字符串(str)是否以指定的字符串(target)结尾。</h2><ul><li><p>提示</p><ul><li>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="noopener">String.substr()</a>,substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。</li></ul></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function confirmEnding(str, target) &#123;</span><br><span class="line">  // &quot;Never give up and good luck will find you.&quot;</span><br><span class="line">  // -- Falcor</span><br><span class="line">  var targetLength = target.length;</span><br><span class="line">  var strEnd = str.substr(-targetLength);</span><br><span class="line">  if(strEnd === target)&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">confirmEnding(&quot;Bastian&quot;, &quot;n&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="🔑-Repeat-a-string-repeat-a-string"><a href="#🔑-Repeat-a-string-repeat-a-string" class="headerlink" title="🔑 Repeat a string repeat a string"></a>🔑 Repeat a string repeat a string</h2><ul><li><p>提示</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String#Methods" target="_blank" rel="noopener">String</a></li></ul></li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function repeat(str, num) &#123;</span><br><span class="line">  // repeat after me</span><br><span class="line">  if (num&lt;0)&#123;</span><br><span class="line">    return &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return str.repeat(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeat(&quot;abc&quot;, 3);</span><br></pre></td></tr></table></figure></li></ul><h2 id="🔑-如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。"><a href="#🔑-如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。" class="headerlink" title="🔑 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。"></a>🔑 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。</h2><ul><li><p>提示</p><ul><li>beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度 (例如， 如果beginSlice 是 -3 则看作是: sourceLength - 3)</li><li>endSlice可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice会一直提取到字符串末尾。如果该参数为负数，则被看作是 sourceLength + endSlice，这里的 sourceLength 就是字符串的长度(例如，如果 endSlice 是 -3，则是, sourceLength - 3)。</li><li>slice() 提取的新字符串包括beginSlice但不包括 endSlice。</li></ul></li><li><p>代码(如果一直找不到思路，不妨停下来休息一下，过一会儿讲注意力重新转移过来的时候就会发现有了新的想法💡)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function largestOfFour(arr) &#123;</span><br><span class="line">  // You can do this!</span><br><span class="line">  var largest = 0;</span><br><span class="line">  var result = [];</span><br><span class="line">  for(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    </span><br><span class="line">    for(var j = 0; j&lt;=arr[i].length;j++)&#123;</span><br><span class="line">      if (largest &lt; arr[i][j])&#123;</span><br><span class="line">        largest = arr[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(largest);</span><br><span class="line">    largest = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);</span><br></pre></td></tr></table></figure><h2 id="✅🔑-Chunky-Monkey：把一个数组arr按照指定的数组大小size分割成若干个数组块。"><a href="#✅🔑-Chunky-Monkey：把一个数组arr按照指定的数组大小size分割成若干个数组块。" class="headerlink" title="## ✅🔑 Chunky Monkey：把一个数组arr按照指定的数组大小size分割成若干个数组块。"></a>## ✅🔑 Chunky Monkey：把一个数组arr按照指定的数组大小size分割成若干个数组块。</h2><ul><li>提示<ul><li>Array.push()：</li><li>Array.slice():方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil" target="_blank" rel="noopener">Math.ceil</a>： 返回大于或等于一个给定数字的最小整数。</li></ul></li><li>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function chunk(arr, size) &#123; </span><br><span class="line">  </span><br><span class="line">  var newArrLength=Math.ceil(arr.length/size);  </span><br><span class="line">  var innerArr=[];  </span><br><span class="line">  for (var i=0; i&lt;newArrLength; i++)&#123; </span><br><span class="line">    </span><br><span class="line">    innerArr.push(arr.splice(0,size)); </span><br><span class="line">  &#125;  </span><br><span class="line">  return innerArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🔑-Slasher-Flick：返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。"><a href="#🔑-Slasher-Flick：返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。" class="headerlink" title="🔑 Slasher Flick：返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。"></a>🔑 Slasher Flick：返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。</h2><ul><li>代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function slasher(arr, howMany) &#123;</span><br><span class="line">  // it doesn&apos;t always pay to be first</span><br><span class="line">  var arrLength = arr.length;</span><br><span class="line">  if(howMany &lt; arrLength)&#123;</span><br><span class="line">  arr = arr.slice(howMany);</span><br><span class="line">  return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  return [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slasher([1, 2, 3], 2);</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><h2 id="🔑-如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。"><a href="#🔑-如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。" class="headerlink" title="🔑 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。"></a>🔑 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function mutation(arr) &#123;</span><br><span class="line">  var arrz = arr[0].toLowerCase();</span><br><span class="line">  var arro = arr[1].toLowerCase();</span><br><span class="line">  for(var i = 0; i &lt; arro.length; i++)&#123;</span><br><span class="line">    if(arrz.indexOf(arro.charAt(i)) == -1)&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">mutation([&quot;hello&quot;, &quot;hey&quot;]);</span><br></pre></td></tr></table></figure><h2 id="✅-删除数组中的所有假值。"><a href="#✅-删除数组中的所有假值。" class="headerlink" title="✅ 删除数组中的所有假值。"></a>✅ 删除数组中的所有假值。</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean" target="_blank" rel="noopener">Boolean</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">Filter</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function bouncer(arr) &#123;</span><br><span class="line">  // Don&apos;t show a false ID to this bouncer.</span><br><span class="line">  var result = [];</span><br><span class="line">  for(var i = 0; i &lt;= arr.length;i++)&#123;</span><br><span class="line">     if(Boolean(arr[i]))&#123;</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="✅-实现一个摧毁-destroyer-函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。"><a href="#✅-实现一个摧毁-destroyer-函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。" class="headerlink" title="✅ 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。"></a>✅ 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">arguments</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">Filter</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function destroyer(arr) &#123;</span><br><span class="line">  // Remove all the values</span><br><span class="line">  var args=[];</span><br><span class="line">  for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class="line">    args.push(arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var temp=arr.filter(function(element,index,array)&#123;</span><br><span class="line">    return args.indexOf(element)&lt;0;</span><br><span class="line">  &#125;);</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="✅-先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。"><a href="#✅-先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。" class="headerlink" title="✅ 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。"></a>✅ 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">Sort</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function where(arr, num) &#123;</span><br><span class="line">  arr.push(num);//插入</span><br><span class="line">  arr.sort(function(a,b)&#123;</span><br><span class="line">    return a-b;//排序</span><br><span class="line">  &#125;);</span><br><span class="line">  return arr.indexOf(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="✅-写一个ROT13函数，实现输入加密字符串，输出解密字符串"><a href="#✅-写一个ROT13函数，实现输入加密字符串，输出解密字符串" class="headerlink" title="✅ 写一个ROT13函数，实现输入加密字符串，输出解密字符串"></a>✅ 写一个ROT13函数，实现输入加密字符串，输出解密字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function rot13(str) &#123; // LBH QVQ VG!</span><br><span class="line">  var arr=str.toUpperCase().split(&quot; &quot;);</span><br><span class="line">  var str1=[];</span><br><span class="line"></span><br><span class="line">  for(var i=0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    var arr1=arr[i].split(&quot;&quot;);</span><br><span class="line">    for(var j=0;j&lt;arr1.length;j++) &#123;</span><br><span class="line">      var num=arr1[j].charCodeAt();</span><br><span class="line">      if(num&gt;=65&amp;&amp;num&lt;=90) &#123;</span><br><span class="line">        arr1[j]=num+13&gt;90?String.fromCharCode(64+(num+13-90)):String.fromCharCode(num + 13);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    str1.push(arr1.join(&quot;&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"> return str1.join(&quot; &quot;);</span><br><span class="line"> //return String.charCodeAt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Change the inputs below to test</span><br><span class="line">rot13(&quot;Z&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;个人JS学习的实战记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="编程" scheme="http://wittyfans.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JS" scheme="http://wittyfans.com/tags/JS/"/>
    
      <category term="前端" scheme="http://wittyfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PS菜单中英文对照表</title>
    <link href="http://wittyfans.com/coding/%E6%95%B4%E7%90%86%E6%9C%80%E5%85%A8PS-photoshop%E8%8F%9C%E5%8D%95%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7%E8%A1%A8.html"/>
    <id>http://wittyfans.com/coding/整理最全PS-photoshop菜单中英文对照表.html</id>
    <published>2017-05-22T02:58:23.000Z</published>
    <updated>2018-03-15T14:47:07.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学PS，买了一本Photoshop书，发现书中的菜单都是英文的，遂在网上搜集了一些资料整理如下，转载请注明！</p></blockquote><a id="more"></a> <h1 id="File-文件"><a href="#File-文件" class="headerlink" title="File:文件"></a>File:文件</h1><ul><li>New:新建 </li><li>Open:打开 </li><li>Open As:打开为 </li><li>Open Recent:最近打开文件 </li><li>Close:关闭 </li><li>Save:存储 </li><li>Save As:存储为 </li><li>Save for Web:存储为Web所用格式 </li><li>Revert:恢复 </li><li>Place:置入 </li><li>Import:输入 </li><li>PDF Image:PDF图象导入 </li><li>Annotations:注释 </li><li>Export:输出 </li><li>Manage Workflow:管理工作流程 </li><li>Check In:登记 </li><li>Undo Check Out:还原注销 </li><li>Upload To Server:上载到服务器 </li><li>Add To Workflow:添加到工作流程 </li><li>Open From Workflow:从工作流程打开 </li><li>Automate:自动 </li><li>Batch:批处理 </li><li>Create Droplet:创建快捷批处理 </li><li>Conditional Mode Change:条件模式更改 </li><li>Contact Sheet:联系表 </li><li>Fix Image:**图像 </li><li>Multi:Page PDF to PSD:多页面PDF文件到PSD文件 </li><li>Picture package:图片包 </li><li>Web Photo Gallery:Web照片画廊 </li><li>File Info:文件简介 </li><li>Print Options:打印选项 </li><li>Page Setup:页面设置 </li><li>Print:打印 </li><li>Jump to:跳转到 </li><li>Exit:退出 </li></ul><h1 id="Edit-编辑"><a href="#Edit-编辑" class="headerlink" title="Edit:编辑"></a>Edit:编辑</h1><ul><li>Undo:还原  </li><li>Step Forward:向前  </li><li>Step Backward:返回  </li><li>Fade:消退  </li><li>Cut:剪切  </li><li>Copy:拷贝  </li><li>Copy Merged:合并拷贝  </li><li>Paste:粘贴  </li><li>Paste Into:粘贴入  </li><li>Clear:清除  </li><li>Fill:填充  </li><li>Stroke:描边  </li><li>Free Transform:自由变形  </li><li>Transform:变换  <ul><li>Again:再次  </li><li>Sacle:缩放  </li><li>Rotate:旋转  </li><li>Skew:斜切  </li><li>Distort:扭曲  </li><li>Prespective:透视  </li><li>Rotate 180°:旋转180度  </li><li>Rotate 90°CW:顺时针旋转90度  </li><li>Rotate 90°CCW:逆时针旋转90度  </li><li>Flip Hpeizontal:水平翻转 </li><li>Flip Vertical:垂直翻转  </li></ul></li><li>Define Brush:定义画笔  </li><li>Define Pattern:设置图案  </li><li>Define Custom Shape:定义自定形状  </li><li>Purge:清除内存数据  <ul><li>Undo:还原  </li><li>Clipboard:剪贴板 </li><li>Histories:历史纪录  </li><li>All:全部  </li></ul></li><li>Color Settings:颜色设置  </li><li>Preset Manager:预置管理器  </li><li>Preferences:预设  </li><li>General:常规  </li><li>Saving Files:存储文件  </li><li>Display ＆ Cursors:显示与光标  </li><li>Transparency ＆ Gamut:透明区域与色域  </li><li>Units ＆ Rulers:单位与标尺  </li><li>Guides ＆ Grid:参考线与网格  </li><li>Plug </li><li>Memory ＆ Image Cache:内存和图像高速缓存  </li><li>Adobe Online </li><li>Workflows Options:工作流程选项  </li></ul><h1 id="Image-图像"><a href="#Image-图像" class="headerlink" title="Image:图像"></a>Image:图像</h1><ul><li>Mode:模式 <ul><li>Bitmap:位图 </li><li>Grayscale:灰度 </li><li>Duotone:双色调 </li><li>Indexed Color:索引色 </li><li>RGB Color:RGB色 </li><li>CMYK Color:CMYK色 </li><li>Lab Color:Lab色 </li><li>Multichannel:多通道 </li><li>8 Bits/Channel:8位通道 </li><li>16 Bits/Channel:16位通道 </li><li>Color Table:颜色表 </li><li>Assing Profile:制定配置文件 </li><li>Convert to Profile:转换为配置文件 </li></ul></li><li>Adjust:调整 <ul><li>Levels:色阶 </li><li>Auto Laves:自动色阶 </li><li>Auto Contrast:自动对比度 </li><li>Curves:曲线 </li><li>Color Balance:色彩平衡 </li><li>Brightness/Contrast:亮度/对比度 </li><li>Hue/Saturation:色相/饱和度 </li><li>Desaturate:去色 </li><li>Replace Color:替换颜色 </li><li>Selective Color:可选颜色 </li><li>Channel Mixer:通道混合器 </li><li>Gradient Map:渐变映射 </li><li>Invert:反相 </li><li>Equalize:色彩均化 </li><li>Threshold:阈值 </li><li>Posterize:色调分离 </li><li>Variations:变化 </li></ul></li><li>Duplicate:复制 </li><li>Apply Image:应用图像 </li><li>Calculations:计算 </li><li>Image Size:图像大小 </li><li>Canvas Size:画布大小 </li><li>Rotate Canvas:旋转画布 <ul><li>180°:180度 </li><li>90°CW:顺时针90度 </li><li>90°CCW:逆时针90度 </li><li>Arbitrary:任意角度 </li><li>Flip Horizontal:水平翻转 </li><li>Flip Vertical:垂直翻转 </li></ul></li><li>Crop:裁切 </li><li>Trim:修整 </li><li>Reverl All:显示全部 </li><li>Histogram:直方图 </li><li>Trap:陷印 </li><li>Extract:抽出 </li><li>Liquify:液化 </li></ul><h1 id="Layer-图层"><a href="#Layer-图层" class="headerlink" title="Layer:图层"></a>Layer:图层</h1><ul><li>New:新建 <ul><li>Layer:图层 </li><li>Background From Layer:背景图层 </li><li>Layer Set:图层组 </li><li>Layer Set From Linked:图层组来自链接的 </li><li>Layer via Copy:通过拷贝的图层 </li><li>Layer via Cut:通过剪切的图层 </li></ul></li><li>Duplicate Layer:复制图层 </li><li>Delete Layer:删除图层 </li><li>Layer Properties:图层属性 </li><li>Layer Style:图层样式 <ul><li>Blending Options:混合选项 </li><li>Drop Shadow:投影 </li><li>Inner Shadow:内阴影 </li><li>Outer Glow:外发光 </li><li>Inner Glow:内发光 </li><li>Bevel and Emboss:斜面和浮雕 </li><li>Satin:光泽 </li><li>Color Overlay:颜色叠加 </li><li>Gradient Overlay:渐变叠加 </li><li>Pattern Overlay:图案叠加 </li><li>Stroke:描边 </li><li>Copy Layer Effects:拷贝图层样式 </li><li>Paste Layer Effects:粘贴图层样式 </li><li>Paste Layer Effects To Linked:将图层样式粘贴的链接的 </li><li>Clear Layer Effects:清除图层样式 </li><li>Global Light:全局光 </li><li>Create Layer:创建图层 </li><li>Hide All Effects:显示/隐藏全部效果 </li><li>Scale Effects:缩放效果 </li></ul></li><li>New Fill Layer:新填充图层 <ul><li>Solid Color:纯色 </li><li>Gradient:渐变 </li><li>Pattern:图案 </li></ul></li><li>New Adjustment Layer:新调整图层 <ul><li>Levels:色阶 </li><li>Curves:曲线 </li><li>Color Balance:色彩平衡 </li><li>Brightness/Contrast:亮度/对比度 </li><li>Hue/Saturation:色相/饱和度 </li><li>Selective Color:可选颜色 </li><li>Channel Mixer:通道混合器 </li><li>Gradient Map:渐变映射 </li><li>Invert:反相 </li><li>Threshold:阈值 </li><li>Posterize:色调分离 </li></ul></li><li>Change Layer Content:更改图层内容 </li><li>Layer Content Options:图层内容选项 </li><li>Type:文字 <ul><li>Create Work Path:创建工作路径 </li><li>Convert to Shape:转变为形状 </li><li>Horizontal:水平 </li><li>Vertical:垂直 </li><li>Anti-Alias None:消除锯齿无 </li><li>Anti-Alias Crisp:消除锯齿明晰 </li><li>Anti-Alias Strong:消除锯齿强 </li><li>Anti-Alias Smooth:消除锯齿平滑 </li><li>Covert To Paragraph Text:转换为段落文字 </li><li>Warp Text:文字变形 </li><li>Update All Text Layers:更新所有文本图层 </li><li>Replace All Missing Fonts:替换所以缺欠文字 </li></ul></li><li>Rasterize:栅格化 <ul><li>Type:文字 </li><li>Shape:形状 </li><li>Fill Content:填充内容 </li><li>Layer Clipping Path:图层剪贴路径 </li><li>Layer:图层 </li><li>Linked Layers:链接图层 </li><li>All Layers:所以图层 </li></ul></li><li>New Layer Based Slice:基于图层的切片 </li><li>Add Layer Mask:添加图层蒙板 <ul><li>Reveal All:显示全部 </li><li>Hide All:隐藏全部 </li><li>Reveal Selection:显示选区 </li><li>Hide Selection:隐藏选区 </li></ul></li><li>Enable Layer Mask:启用图层蒙板 </li><li>Add Layer Clipping Path:添加图层剪切路径 <ul><li>Reveal All:显示全部 </li><li>Hide All:隐藏全部 </li><li>Current Path:当前路径 </li></ul></li><li>Enable Layer Clipping Path:启用图层剪切路径 </li><li>Group Linked:于前一图层编组 </li><li>UnGroup:取消编组 </li><li>Arrange:排列 <ul><li>Bring to Front:置为顶层 </li><li>Bring Forward:前移一层 </li><li>Send Backward:后移一层 </li><li>Send to Back:置为底层 </li></ul></li><li>Arrange Linked:对齐链接图层 <ul><li>Top Edges:顶边 </li><li>Vertical Center:垂直居中 </li><li>Bottom Edges:底边 </li><li>Left Edges:左边 </li><li>Horizontal Center:水平居中 </li><li>Right Edges:右边 </li></ul></li><li>Distribute Linked:分布链接的 <ul><li>Top Edges:顶边 </li><li>Vertical Center:垂直居中 </li><li>Bottom Edges:底边 </li><li>Left Edges:左边 </li><li>Horizontal Center:水平居中 </li><li>Right Edges:右边 </li></ul></li><li>Lock All Linked Layers:锁定所有链接图层 </li><li>Merge Linked:合并链接图层 </li><li>Merge Visible:合并可见图层 </li><li>Flatten Image:合并图层 </li><li>Matting:修边 <ul><li>Define:去边 </li><li>Remove Black Matte:移去黑色杂边 </li><li>Remove White Matte:移去白色杂边 </li></ul></li></ul><h1 id="Selection-选择"><a href="#Selection-选择" class="headerlink" title="Selection:选择"></a>Selection:选择</h1><ul><li>All:全部 </li><li>Deselect:取消选择 </li><li>Reselect:重新选择 </li><li>Inverse:反选 </li><li>Color Range:色彩范围 </li><li>Feather:羽化 </li><li>Modify:修改 <ul><li>Border:扩边 </li><li>Smooth:平滑 </li><li>Expand:扩展 </li><li>Contract:收缩 </li></ul></li><li>Grow:扩大选区 </li><li>Similar:选区相似 </li><li>Transform Selection:变换选区 </li><li>Load Selection:载入选区 </li><li>Save Selection:存储选区 </li></ul><h1 id="Filter-滤镜"><a href="#Filter-滤镜" class="headerlink" title="Filter:滤镜"></a>Filter:滤镜</h1><ul><li>Last Filter:上次滤镜操作 </li><li>Artistic:艺术效果 <ul><li>Colored Pencil:彩色铅笔 </li><li>Cutout:剪贴画 </li><li>Dry Brush:干笔画 </li><li>Film Grain:胶片颗粒 </li><li>Fresco:壁画 </li><li>Neon Glow:霓虹灯光 </li><li>Paint Daubs:涂抹棒 </li><li>Palette Knife:调色刀 </li><li>Plastic Wrap:塑料包装 </li><li>Poster Edges:海报边缘 </li><li>Rough Pastels:粗糙彩笔 </li><li>Smudge Stick:绘画涂抹 </li><li>Sponge:海绵 </li><li>Underpainting:底纹效果 </li><li>Watercolor:水彩 </li></ul></li><li>Blur:模糊 <ul><li>Blur:模糊 </li><li>Blur More:进一步模糊 </li><li>Gaussian Blur:高斯模糊 </li><li>Motion Blur:动态模糊 </li><li>Radial Blur:径向模糊 </li><li>Smart Blur:特殊模糊 </li></ul></li><li>Brush Strokes:画笔描边 <ul><li>Accented Edges:强化边缘 </li><li>Angled Stroke:成角的线条 </li><li>Crosshatch:阴影线 </li><li>Dark Strokes:深色线条 </li><li>Ink Outlines:油墨概况 </li><li>Spatter:喷笔 </li><li>Sprayed Strokes:喷色线条 </li><li>Sumi:e:总量 </li></ul></li><li>Distort:扭曲 <ul><li>Diffuse Glow:扩散亮光 </li><li>Displace:置换 </li><li>Glass:玻璃 </li><li>Ocean Ripple:海洋波纹 </li><li>Pinch:挤压 </li><li>Polar Coordinates:极坐标 </li><li>Ripple:波纹 </li><li>Shear:切变 </li><li>Spherize:球面化 </li><li>Twirl:旋转扭曲 </li><li>Wave:波浪 </li><li>Zigzag:水波 </li></ul></li><li>Noise:杂色 <ul><li>Add Noise:加入杂色 </li><li>Despeckle:去斑 </li><li>Dust ＆ Scratches:蒙尘与划痕 </li><li>Median:中间值 </li></ul></li><li>Pixelate:像素化 <ul><li>Color Halftone:彩色半调 </li><li>Crystallize:晶格化 </li><li>Facet:彩块化 </li><li>Fragment:碎片 </li><li>Mezzotint:铜版雕刻 </li><li>Mosaic:马赛克 </li><li>Pointillize:点状化 </li></ul></li><li>Render:渲染 <ul><li>3D Transform:3D 变换 </li><li>Clouds:云彩 </li><li>Difference Clouds:分层云彩 </li><li>Lens Flare:镜头光晕 </li><li>Lighting Effects:光照效果 </li><li>Texture Fill:纹理填充 </li></ul></li><li>Sharpen:锐化 <ul><li>Sharpen:锐化 </li><li>Sharpen Edges:锐化边缘 </li><li>Sharpen More:进一步锐化 </li><li>Unsharp Mask:USM 锐化 </li></ul></li><li>Sketch:素描 <ul><li>Bas Relief:基底凸现 </li><li>Chalk ＆ Charcoal:粉笔和炭笔 </li><li>Charcoal </li><li>Chrome:铬黄 </li><li>Conte Crayon:彩色粉笔 </li><li>Graphic Pen:绘图笔 </li><li>Halftone Pattern:半色调图案 </li><li>Note Paper:便条纸 </li><li>Photocopy:副本 </li><li>Plaster:塑料效果 </li><li>Reticulation:网状 </li><li>Stamp:图章 </li><li>Torn Edges:撕边 </li><li>Water Paper:水彩纸 </li></ul></li><li>Stylize:风格化 <ul><li>Diffuse:扩散 </li><li>Emboss:浮雕 </li><li>Extrude:突出 </li><li>Find Edges:查找边缘 </li><li>Glowing Edges:照亮边缘 </li><li>Solarize:曝光过度 </li><li>Tiles:拼贴 </li><li>Trace Contour:等高线 </li><li>Wind:风 </li></ul></li><li>Texture::纹理 <ul><li>Craquelure:龟裂缝 </li><li>Grain:颗粒 </li><li>Mosained Tiles:马赛克拼贴 </li><li>Patchwork:拼缀图 </li><li>Stained Glass:染色玻璃 </li><li>Texturixer:纹理化 </li></ul></li><li>Video:视频 <ul><li>De:Interlace:逐行 </li><li>NTSC Colors:NTSC色彩 </li></ul></li><li>Other:其它 <ul><li>Custom:自定义 </li><li>High Pass:高反差保留 </li><li>Maximum:最大值 </li><li>Minimum:最小值 </li><li>Offset:位移 </li></ul></li><li>Digimarc <ul><li>Embed Watermark:嵌入水印 </li><li>Read Watermark:读取水印 </li></ul></li></ul><h1 id="View-视图"><a href="#View-视图" class="headerlink" title="View:视图"></a>View:视图</h1><ul><li>New View:新视图 </li><li>Proof Setup:校样设置 <ul><li>Custom:自定 </li><li>Working CMYK:处理CMYK </li><li>Working Cyan Plate:处理青版 </li><li>Working Magenta Plate:处理洋红版 </li><li>Working Yellow Plate:处理黄版 </li><li>Working Black Plate:处理黑版 </li><li>Working CMY Plate:处理CMY版 </li><li>Macintosh RGB </li><li>Windows RGB </li><li>Monitor RGB:显示器RGB </li><li>Simulate Paper White:模拟纸白 </li><li>Simulate Ink Black:模拟墨黑 </li></ul></li><li>Proof Color:校样颜色 </li><li>Gamut Wiring:色域警告 </li><li>Zoom In:放大 </li><li>Zoom Out:缩小 </li><li>Fit on Screen:满画布显示 </li><li>Actual Pixels:实际象素 </li><li>Print Size:打印尺寸 </li><li>Show Extras:显示额外的 </li><li>Show:显示 <ul><li>Selection Edges:选区边缘 </li><li>Target Path:目标路径 </li><li>Grid:网格 </li><li>Guides:参考线 </li><li>Slices:切片 </li><li>Notes:注释 </li><li>All:全部 </li><li>None:无 </li><li>Show Extras Options:显示额外选项 </li></ul></li><li>Show Rulers:显示标尺 </li><li>Snap:对齐 </li><li>Snap To:对齐到 <ul><li>Guides:参考线 </li><li>Grid:网格 </li><li>Slices:切片 </li><li>Document Bounds:文档边界 </li><li>All:全部 </li><li>None:无 </li></ul></li><li>Show Guides:锁定参考线 </li><li>Clear Guides:清除参考线 </li><li>New Guides:新参考线 </li><li>Lock Slices:锁定切片 </li><li>Clear Slices:清除切片 </li></ul><h1 id="Windows-窗口"><a href="#Windows-窗口" class="headerlink" title="Windows:窗口"></a>Windows:窗口</h1><ul><li>Cascade:层叠 </li><li>Tile:拼贴 </li><li>Arrange Icons:排列图标 </li><li>Close All:关闭全部 </li><li>Show/Hide Tools:显示/隐藏工具 </li><li>Show/Hide Options:显示/隐藏选项 </li><li>Show/Hide Navigator:显示/隐藏导航 </li><li>Show/Hide Info:显示/隐藏信息 </li><li>Show/Hide Color:显示/隐藏颜色 </li><li>Show/Hide Swatches:显示/隐藏色板 </li><li>Show/Hide Styles:显示/隐藏样式 </li><li>Show/Hide History:显示/隐藏历史记录 </li><li>Show/Hide Actions:显示/隐藏动作 </li><li>Show/Hide Layers:显示/隐藏图层 </li><li>Show/Hide Channels:显示/隐藏通道 </li><li>Show/Hide Paths:显示/隐藏路径 </li><li>Show/Hide Character:显示/隐藏字符 </li><li>Show/Hide Paragraph:显示/隐藏段落 </li><li>Show/Hide Status Bar:显示/隐藏状态栏 </li><li>Reset Palette Locations:复位调板位置</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="">豆瓣</a>(<a href="https://www.douban.com/group/topic/47679348/" target="_blank" rel="noopener">https://www.douban.com/group/topic/47679348/</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学PS，买了一本Photoshop书，发现书中的菜单都是英文的，遂在网上搜集了一些资料整理如下，转载请注明！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://wittyfans.com/categories/coding/"/>
    
    
      <category term="参考" scheme="http://wittyfans.com/tags/%E5%8F%82%E8%80%83/"/>
    
      <category term="PS" scheme="http://wittyfans.com/tags/PS/"/>
    
      <category term="PhotoShop" scheme="http://wittyfans.com/tags/PhotoShop/"/>
    
      <category term="翻译" scheme="http://wittyfans.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
